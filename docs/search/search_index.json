{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"LFortran Documentation LFortran is a modern open-source (BSD licensed) interactive Fortran compiler built on top of LLVM. It can execute user's code interactively to allow exploratory work (much like Python, MATLAB or Julia) as well as compile to binaries with the goal to run user's code on modern architectures such as multi-core CPUs and GPUs. Website: https://lfortran.org/ Main repository: https://gitlab.com/lfortran/lfortran Try online using Binder: Feature Highlights LFortran is in development, there are features that work today, and there are features that are being implemented. You can also check out the Development Status section for more information on features being supported and being worked on. Works today Interactive, Jupyter support LFortran can be used from Jupyter as a Fortran kernel, allowing a Python/Julia style rapid prototyping and exploratory workflow (see the static or interactive example notebook). Or it can be used from the command-line in an interactive prompt (REPL). Clean, modular design, usable as a library LFortran is structured around two independent modules, AST and ASR, both of which are standalone (completely independent of the rest of LFortran) and users are encouraged to use them independently for other applications and build tools on top. See the Design and Developer Tutorial documents for more details. Interoperation with GFortran LFortran can parse GFortran module files into an ASR and generate a Fortran wrapper that can be compiled with any Fortran compiler and linked with the original GFortran compiled module. Create executables It can create executables just like other Fortran compilers. Runs on Linux, Mac and Windows All three platforms are regularly tested by our CI. Planned These features are under development, there is a link to the corresponding issue so that you can track the progress by following it. Native interoperation with other languages (and other Fortran compilers) It can automatically call code written in other languages (such as C or Python) just by using the use statement, see #44 . It understands other Fortran compilers module files (one can just \"use\" them) and their ABI to link correctly (GFortran is supported, other compilers are planned, see #56 ), which allows to use LFortran with production codes today. Modern hardware support Thanks to LLVM, the goal of LFortran is to run on modern hardware and take advantage of native Fortran language constructs (such as do concurrent ) to run on multi-core CPUs and GPUs, see #57 . Full Fortran 2018 support Currently only a subset of Fortran is implemented, but the goal is to have a full implementation of the latest Fortran 2018 standard, see #58 . Please vote on issues in our issue tracker that you want us to prioritize (feel free to create new ones if we are missing anything). Roadmap Here is our roadmap how to get all the planned features above implemented: Port code generation to use ASR and pass all the current tests ( #74 ). Remove the old code generation and old semantics, that used to annotate the AST tree, which was messy. Get GFortran module files working with use module, both assumed-size and assumed-shape arrays ( #52 ). This will allow right away to use production codes with LFortran. Do these at the same time: a) Implement more Fortran features, until eventually full Fortran 2018 is supported ( #58 ). b) Gradually move to C++ for robustness and speed ( #70 ). The Python API will not change (or only minimally), so the user experience from Python will not change. c) Implement all the other cool features: use module for C and Python and automatic wrappers ( #44 ), modern hardware support ( #57 ), generating an older standard of Fortran ( #72 ), Fortran doctest feature ( #73 ), SymPy integration ( #71 ), language service for IDEs ( #12 ), and other ideas ( #29 ). The step 1. is an internal refactoring that will not take long. The step 2. will allow LFortran to be used interactively with production codes right away (the production code will get compiled with GFortran, then one \"uses\" any module in LFortran and functions/subroutines can be interactively called, the module itself can use any GFortran supported feature, but the API must fit into the subset that LFortran understands --- for large number of applications simple functions/subroutines with array arguments are enough). This will make LFortran usable for first users and one can always use GFortran temporarily until LFortran supports the given feature. We expect to be finished with the step 2. by the end of summer 2019, hopefully sooner. Finally the step 3. will improve LFortran overall, allowing the first users to contribute back, growing the community and making LFortran gradually useful for more and more people.","title":"Home"},{"location":"#lfortran-documentation","text":"LFortran is a modern open-source (BSD licensed) interactive Fortran compiler built on top of LLVM. It can execute user's code interactively to allow exploratory work (much like Python, MATLAB or Julia) as well as compile to binaries with the goal to run user's code on modern architectures such as multi-core CPUs and GPUs. Website: https://lfortran.org/ Main repository: https://gitlab.com/lfortran/lfortran Try online using Binder:","title":"LFortran Documentation"},{"location":"#feature-highlights","text":"LFortran is in development, there are features that work today, and there are features that are being implemented. You can also check out the Development Status section for more information on features being supported and being worked on.","title":"Feature Highlights"},{"location":"#works-today","text":"Interactive, Jupyter support LFortran can be used from Jupyter as a Fortran kernel, allowing a Python/Julia style rapid prototyping and exploratory workflow (see the static or interactive example notebook). Or it can be used from the command-line in an interactive prompt (REPL). Clean, modular design, usable as a library LFortran is structured around two independent modules, AST and ASR, both of which are standalone (completely independent of the rest of LFortran) and users are encouraged to use them independently for other applications and build tools on top. See the Design and Developer Tutorial documents for more details. Interoperation with GFortran LFortran can parse GFortran module files into an ASR and generate a Fortran wrapper that can be compiled with any Fortran compiler and linked with the original GFortran compiled module. Create executables It can create executables just like other Fortran compilers. Runs on Linux, Mac and Windows All three platforms are regularly tested by our CI.","title":"Works today"},{"location":"#planned","text":"These features are under development, there is a link to the corresponding issue so that you can track the progress by following it. Native interoperation with other languages (and other Fortran compilers) It can automatically call code written in other languages (such as C or Python) just by using the use statement, see #44 . It understands other Fortran compilers module files (one can just \"use\" them) and their ABI to link correctly (GFortran is supported, other compilers are planned, see #56 ), which allows to use LFortran with production codes today. Modern hardware support Thanks to LLVM, the goal of LFortran is to run on modern hardware and take advantage of native Fortran language constructs (such as do concurrent ) to run on multi-core CPUs and GPUs, see #57 . Full Fortran 2018 support Currently only a subset of Fortran is implemented, but the goal is to have a full implementation of the latest Fortran 2018 standard, see #58 . Please vote on issues in our issue tracker that you want us to prioritize (feel free to create new ones if we are missing anything).","title":"Planned"},{"location":"#roadmap","text":"Here is our roadmap how to get all the planned features above implemented: Port code generation to use ASR and pass all the current tests ( #74 ). Remove the old code generation and old semantics, that used to annotate the AST tree, which was messy. Get GFortran module files working with use module, both assumed-size and assumed-shape arrays ( #52 ). This will allow right away to use production codes with LFortran. Do these at the same time: a) Implement more Fortran features, until eventually full Fortran 2018 is supported ( #58 ). b) Gradually move to C++ for robustness and speed ( #70 ). The Python API will not change (or only minimally), so the user experience from Python will not change. c) Implement all the other cool features: use module for C and Python and automatic wrappers ( #44 ), modern hardware support ( #57 ), generating an older standard of Fortran ( #72 ), Fortran doctest feature ( #73 ), SymPy integration ( #71 ), language service for IDEs ( #12 ), and other ideas ( #29 ). The step 1. is an internal refactoring that will not take long. The step 2. will allow LFortran to be used interactively with production codes right away (the production code will get compiled with GFortran, then one \"uses\" any module in LFortran and functions/subroutines can be interactively called, the module itself can use any GFortran supported feature, but the API must fit into the subset that LFortran understands --- for large number of applications simple functions/subroutines with array arguments are enough). This will make LFortran usable for first users and one can always use GFortran temporarily until LFortran supports the given feature. We expect to be finished with the step 2. by the end of summer 2019, hopefully sooner. Finally the step 3. will improve LFortran overall, allowing the first users to contribute back, growing the community and making LFortran gradually useful for more and more people.","title":"Roadmap"},{"location":"AST%20and%20ASR/","text":"Difference between an AST and ASR Let us take a simple Fortran code: integer function f(a, b) result(r) integer, intent(in) :: a, b integer :: c, d c = a + b - d r = c * a end function and look at how the AST and ASR looks like. AST from lfortran.ast import src_to_ast, print_tree from lfortran.ast.ast_to_src import ast_to_src src = \"\"\"\\ integer function f(a, b) result(r) integer, intent(in) :: a, b integer :: c, d c = a + b - d r = c * a end function \"\"\" ast = src_to_ast(src, translation_unit=False) print_tree(ast) Legend: Node , Field, Token program_unit.Function \u251c\u2500 name= 'f' \u251c\u2500 args=\u2193 \u2502 \u251c\u2500 AST.arg \u2502 \u2502 \u2570\u2500 arg= 'a' \u2502 \u2570\u2500 AST.arg \u2502 \u2570\u2500 arg= 'b' \u251c\u2500 return_type= None \u251c\u2500 return_var= expr.Name \u2502 \u2570\u2500 id= 'r' \u251c\u2500 bind= None \u251c\u2500 use=[] \u251c\u2500 decl=\u2193 \u2502 \u251c\u2500 unit_decl2.Declaration \u2502 \u2502 \u2570\u2500 vars=\u2193 \u2502 \u2502 \u251c\u2500 AST.decl \u2502 \u2502 \u2502 \u251c\u2500 sym= 'a' \u2502 \u2502 \u2502 \u251c\u2500 sym_type= 'integer' \u2502 \u2502 \u2502 \u251c\u2500 dims=[] \u2502 \u2502 \u2502 \u251c\u2500 attrs=\u2193 \u2502 \u2502 \u2502 \u2502 \u2570\u2500 attribute.Attribute \u2502 \u2502 \u2502 \u2502 \u251c\u2500 name= 'intent' \u2502 \u2502 \u2502 \u2502 \u2570\u2500 args=\u2193 \u2502 \u2502 \u2502 \u2502 \u2570\u2500 AST.attribute_arg \u2502 \u2502 \u2502 \u2502 \u2570\u2500 arg= 'in' \u2502 \u2502 \u2502 \u2570\u2500 initializer= None \u2502 \u2502 \u2570\u2500 AST.decl \u2502 \u2502 \u251c\u2500 sym= 'b' \u2502 \u2502 \u251c\u2500 sym_type= 'integer' \u2502 \u2502 \u251c\u2500 dims=[] \u2502 \u2502 \u251c\u2500 attrs=\u2193 \u2502 \u2502 \u2502 \u2570\u2500 attribute.Attribute \u2502 \u2502 \u2502 \u251c\u2500 name= 'intent' \u2502 \u2502 \u2502 \u2570\u2500 args=\u2193 \u2502 \u2502 \u2502 \u2570\u2500 AST.attribute_arg \u2502 \u2502 \u2502 \u2570\u2500 arg= 'in' \u2502 \u2502 \u2570\u2500 initializer= None \u2502 \u2570\u2500 unit_decl2.Declaration \u2502 \u2570\u2500 vars=\u2193 \u2502 \u251c\u2500 AST.decl \u2502 \u2502 \u251c\u2500 sym= 'c' \u2502 \u2502 \u251c\u2500 sym_type= 'integer' \u2502 \u2502 \u251c\u2500 dims=[] \u2502 \u2502 \u251c\u2500 attrs=[] \u2502 \u2502 \u2570\u2500 initializer= None \u2502 \u2570\u2500 AST.decl \u2502 \u251c\u2500 sym= 'd' \u2502 \u251c\u2500 sym_type= 'integer' \u2502 \u251c\u2500 dims=[] \u2502 \u251c\u2500 attrs=[] \u2502 \u2570\u2500 initializer= None \u251c\u2500 body=\u2193 \u2502 \u251c\u2500 stmt.Assignment \u2502 \u2502 \u251c\u2500 target= expr.Name \u2502 \u2502 \u2502 \u2570\u2500 id= 'c' \u2502 \u2502 \u2570\u2500 value= expr.BinOp \u2502 \u2502 \u251c\u2500 left= expr.BinOp \u2502 \u2502 \u2502 \u251c\u2500 left= expr.Name \u2502 \u2502 \u2502 \u2502 \u2570\u2500 id= 'a' \u2502 \u2502 \u2502 \u251c\u2500 op= operator.Add \u2502 \u2502 \u2502 \u2570\u2500 right= expr.Name \u2502 \u2502 \u2502 \u2570\u2500 id= 'b' \u2502 \u2502 \u251c\u2500 op= operator.Sub \u2502 \u2502 \u2570\u2500 right= expr.Name \u2502 \u2502 \u2570\u2500 id= 'd' \u2502 \u2570\u2500 stmt.Assignment \u2502 \u251c\u2500 target= expr.Name \u2502 \u2502 \u2570\u2500 id= 'r' \u2502 \u2570\u2500 value= expr.BinOp \u2502 \u251c\u2500 left= expr.Name \u2502 \u2502 \u2570\u2500 id= 'c' \u2502 \u251c\u2500 op= operator.Mul \u2502 \u2570\u2500 right= expr.Name \u2502 \u2570\u2500 id= 'a' \u2570\u2500 contains=[] The AST does not have any semantic information, but has nodes to represent declarations such as integer, intent(in) :: a . Variables such as a are represented by a Name node, and are not connected to their declarations yet. ASR from lfortran.semantic.ast_to_asr import ast_to_asr from lfortran.asr.pprint import pprint_asr asr = ast_to_asr(ast) pprint_asr(asr) unit.TranslationUnit \u251c\u2500 global_scope=Scope \u2502 \u2570\u2500 f = fn.Function \u2502 \u251c\u2500 name= 'f' \u2502 \u251c\u2500 args=\u2193 \u2502 \u2502 \u251c\u2500 a \u2502 \u2502 \u2570\u2500 b \u2502 \u251c\u2500 body=\u2193 \u2502 \u2502 \u251c\u2500 stmt.Assignment \u2502 \u2502 \u2502 \u251c\u2500 target= c \u2502 \u2502 \u2502 \u2570\u2500 value= expr.BinOp \u2502 \u2502 \u2502 \u251c\u2500 left= expr.BinOp \u2502 \u2502 \u2502 \u2502 \u251c\u2500 left= a \u2502 \u2502 \u2502 \u2502 \u251c\u2500 op= operator.Add \u2502 \u2502 \u2502 \u2502 \u251c\u2500 right= b \u2502 \u2502 \u2502 \u2502 \u2570\u2500 type= ttype.Integer \u2502 \u2502 \u2502 \u2502 \u251c\u2500 kind= 4 \u2502 \u2502 \u2502 \u2502 \u2570\u2500 dims=[] \u2502 \u2502 \u2502 \u251c\u2500 op= operator.Sub \u2502 \u2502 \u2502 \u251c\u2500 right= d \u2502 \u2502 \u2502 \u2570\u2500 type= ttype.Integer \u2502 \u2502 \u2502 \u251c\u2500 kind= 4 \u2502 \u2502 \u2502 \u2570\u2500 dims=[] \u2502 \u2502 \u2570\u2500 stmt.Assignment \u2502 \u2502 \u251c\u2500 target= r \u2502 \u2502 \u2570\u2500 value= expr.BinOp \u2502 \u2502 \u251c\u2500 left= c \u2502 \u2502 \u251c\u2500 op= operator.Mul \u2502 \u2502 \u251c\u2500 right= a \u2502 \u2502 \u2570\u2500 type= ttype.Integer \u2502 \u2502 \u251c\u2500 kind= 4 \u2502 \u2502 \u2570\u2500 dims=[] \u2502 \u251c\u2500 bind= None \u2502 \u251c\u2500 return_var= r \u2502 \u251c\u2500 module= None \u2502 \u2570\u2500 symtab=Scope \u2502 \u251c\u2500 a = expr.VariableOld \u2502 \u2502 \u251c\u2500 name= 'a' \u2502 \u2502 \u251c\u2500 intent= 'in' \u2502 \u2502 \u251c\u2500 dummy= True \u2502 \u2502 \u2570\u2500 type= ttype.Integer \u2502 \u2502 \u251c\u2500 kind= 4 \u2502 \u2502 \u2570\u2500 dims=[] \u2502 \u251c\u2500 b = expr.VariableOld \u2502 \u2502 \u251c\u2500 name= 'b' \u2502 \u2502 \u251c\u2500 intent= 'in' \u2502 \u2502 \u251c\u2500 dummy= True \u2502 \u2502 \u2570\u2500 type= ttype.Integer \u2502 \u2502 \u251c\u2500 kind= 4 \u2502 \u2502 \u2570\u2500 dims=[] \u2502 \u251c\u2500 r = expr.VariableOld \u2502 \u2502 \u251c\u2500 name= 'r' \u2502 \u2502 \u251c\u2500 intent= None \u2502 \u2502 \u251c\u2500 dummy= True \u2502 \u2502 \u2570\u2500 type= ttype.Integer \u2502 \u2502 \u251c\u2500 kind= 4 \u2502 \u2502 \u2570\u2500 dims=[] \u2502 \u251c\u2500 c = expr.VariableOld \u2502 \u2502 \u251c\u2500 name= 'c' \u2502 \u2502 \u251c\u2500 intent= None \u2502 \u2502 \u251c\u2500 dummy= False \u2502 \u2502 \u2570\u2500 type= ttype.Integer \u2502 \u2502 \u251c\u2500 kind= 4 \u2502 \u2502 \u2570\u2500 dims=[] \u2502 \u2570\u2500 d = expr.VariableOld \u2502 \u251c\u2500 name= 'd' \u2502 \u251c\u2500 intent= None \u2502 \u251c\u2500 dummy= False \u2502 \u2570\u2500 type= ttype.Integer \u2502 \u251c\u2500 kind= 4 \u2502 \u2570\u2500 dims=[] \u2570\u2500 items=[] The ASR has all the semantic information (types, etc.), nodes like Function have a symbol table and do not have any declaration nodes. Variables are simply pointers to the symbol table. Discussion The above was a simple example. Things get more apparent for more complicated examples, such as: integer function f2b(a) result(r) use gfort_interop, only: c_desc1_int32 integer, intent(in) :: a(:) interface integer function f2b_c_wrapper(a) bind(c, name=\"__mod1_MOD_f2b\") use gfort_interop, only: c_desc1_t type(c_desc1_t), intent(in) :: a end function end interface r = f2b_c_wrapper(c_desc1_int32(a)) end function AST must represent all the use statements and the interface block, and keep things semantically consistent. ASR, on the other hand, keeps track of the c_desc1_int32 , c_desc1_t and f2b_c_wrapper in the symbol table and it knows they are defined in the gfort_interop module, and so ASR does not have any of these declaration nodes. When converting from ASR to AST, LFortran will create all the appropriate AST declaration nodes automatically and correctly.","title":"Difference between an AST and ASR"},{"location":"AST%20and%20ASR/#difference-between-an-ast-and-asr","text":"Let us take a simple Fortran code: integer function f(a, b) result(r) integer, intent(in) :: a, b integer :: c, d c = a + b - d r = c * a end function and look at how the AST and ASR looks like.","title":"Difference between an AST and ASR"},{"location":"AST%20and%20ASR/#ast","text":"from lfortran.ast import src_to_ast, print_tree from lfortran.ast.ast_to_src import ast_to_src src = \"\"\"\\ integer function f(a, b) result(r) integer, intent(in) :: a, b integer :: c, d c = a + b - d r = c * a end function \"\"\" ast = src_to_ast(src, translation_unit=False) print_tree(ast) Legend: Node , Field, Token program_unit.Function \u251c\u2500 name= 'f' \u251c\u2500 args=\u2193 \u2502 \u251c\u2500 AST.arg \u2502 \u2502 \u2570\u2500 arg= 'a' \u2502 \u2570\u2500 AST.arg \u2502 \u2570\u2500 arg= 'b' \u251c\u2500 return_type= None \u251c\u2500 return_var= expr.Name \u2502 \u2570\u2500 id= 'r' \u251c\u2500 bind= None \u251c\u2500 use=[] \u251c\u2500 decl=\u2193 \u2502 \u251c\u2500 unit_decl2.Declaration \u2502 \u2502 \u2570\u2500 vars=\u2193 \u2502 \u2502 \u251c\u2500 AST.decl \u2502 \u2502 \u2502 \u251c\u2500 sym= 'a' \u2502 \u2502 \u2502 \u251c\u2500 sym_type= 'integer' \u2502 \u2502 \u2502 \u251c\u2500 dims=[] \u2502 \u2502 \u2502 \u251c\u2500 attrs=\u2193 \u2502 \u2502 \u2502 \u2502 \u2570\u2500 attribute.Attribute \u2502 \u2502 \u2502 \u2502 \u251c\u2500 name= 'intent' \u2502 \u2502 \u2502 \u2502 \u2570\u2500 args=\u2193 \u2502 \u2502 \u2502 \u2502 \u2570\u2500 AST.attribute_arg \u2502 \u2502 \u2502 \u2502 \u2570\u2500 arg= 'in' \u2502 \u2502 \u2502 \u2570\u2500 initializer= None \u2502 \u2502 \u2570\u2500 AST.decl \u2502 \u2502 \u251c\u2500 sym= 'b' \u2502 \u2502 \u251c\u2500 sym_type= 'integer' \u2502 \u2502 \u251c\u2500 dims=[] \u2502 \u2502 \u251c\u2500 attrs=\u2193 \u2502 \u2502 \u2502 \u2570\u2500 attribute.Attribute \u2502 \u2502 \u2502 \u251c\u2500 name= 'intent' \u2502 \u2502 \u2502 \u2570\u2500 args=\u2193 \u2502 \u2502 \u2502 \u2570\u2500 AST.attribute_arg \u2502 \u2502 \u2502 \u2570\u2500 arg= 'in' \u2502 \u2502 \u2570\u2500 initializer= None \u2502 \u2570\u2500 unit_decl2.Declaration \u2502 \u2570\u2500 vars=\u2193 \u2502 \u251c\u2500 AST.decl \u2502 \u2502 \u251c\u2500 sym= 'c' \u2502 \u2502 \u251c\u2500 sym_type= 'integer' \u2502 \u2502 \u251c\u2500 dims=[] \u2502 \u2502 \u251c\u2500 attrs=[] \u2502 \u2502 \u2570\u2500 initializer= None \u2502 \u2570\u2500 AST.decl \u2502 \u251c\u2500 sym= 'd' \u2502 \u251c\u2500 sym_type= 'integer' \u2502 \u251c\u2500 dims=[] \u2502 \u251c\u2500 attrs=[] \u2502 \u2570\u2500 initializer= None \u251c\u2500 body=\u2193 \u2502 \u251c\u2500 stmt.Assignment \u2502 \u2502 \u251c\u2500 target= expr.Name \u2502 \u2502 \u2502 \u2570\u2500 id= 'c' \u2502 \u2502 \u2570\u2500 value= expr.BinOp \u2502 \u2502 \u251c\u2500 left= expr.BinOp \u2502 \u2502 \u2502 \u251c\u2500 left= expr.Name \u2502 \u2502 \u2502 \u2502 \u2570\u2500 id= 'a' \u2502 \u2502 \u2502 \u251c\u2500 op= operator.Add \u2502 \u2502 \u2502 \u2570\u2500 right= expr.Name \u2502 \u2502 \u2502 \u2570\u2500 id= 'b' \u2502 \u2502 \u251c\u2500 op= operator.Sub \u2502 \u2502 \u2570\u2500 right= expr.Name \u2502 \u2502 \u2570\u2500 id= 'd' \u2502 \u2570\u2500 stmt.Assignment \u2502 \u251c\u2500 target= expr.Name \u2502 \u2502 \u2570\u2500 id= 'r' \u2502 \u2570\u2500 value= expr.BinOp \u2502 \u251c\u2500 left= expr.Name \u2502 \u2502 \u2570\u2500 id= 'c' \u2502 \u251c\u2500 op= operator.Mul \u2502 \u2570\u2500 right= expr.Name \u2502 \u2570\u2500 id= 'a' \u2570\u2500 contains=[] The AST does not have any semantic information, but has nodes to represent declarations such as integer, intent(in) :: a . Variables such as a are represented by a Name node, and are not connected to their declarations yet.","title":"AST"},{"location":"AST%20and%20ASR/#asr","text":"from lfortran.semantic.ast_to_asr import ast_to_asr from lfortran.asr.pprint import pprint_asr asr = ast_to_asr(ast) pprint_asr(asr) unit.TranslationUnit \u251c\u2500 global_scope=Scope \u2502 \u2570\u2500 f = fn.Function \u2502 \u251c\u2500 name= 'f' \u2502 \u251c\u2500 args=\u2193 \u2502 \u2502 \u251c\u2500 a \u2502 \u2502 \u2570\u2500 b \u2502 \u251c\u2500 body=\u2193 \u2502 \u2502 \u251c\u2500 stmt.Assignment \u2502 \u2502 \u2502 \u251c\u2500 target= c \u2502 \u2502 \u2502 \u2570\u2500 value= expr.BinOp \u2502 \u2502 \u2502 \u251c\u2500 left= expr.BinOp \u2502 \u2502 \u2502 \u2502 \u251c\u2500 left= a \u2502 \u2502 \u2502 \u2502 \u251c\u2500 op= operator.Add \u2502 \u2502 \u2502 \u2502 \u251c\u2500 right= b \u2502 \u2502 \u2502 \u2502 \u2570\u2500 type= ttype.Integer \u2502 \u2502 \u2502 \u2502 \u251c\u2500 kind= 4 \u2502 \u2502 \u2502 \u2502 \u2570\u2500 dims=[] \u2502 \u2502 \u2502 \u251c\u2500 op= operator.Sub \u2502 \u2502 \u2502 \u251c\u2500 right= d \u2502 \u2502 \u2502 \u2570\u2500 type= ttype.Integer \u2502 \u2502 \u2502 \u251c\u2500 kind= 4 \u2502 \u2502 \u2502 \u2570\u2500 dims=[] \u2502 \u2502 \u2570\u2500 stmt.Assignment \u2502 \u2502 \u251c\u2500 target= r \u2502 \u2502 \u2570\u2500 value= expr.BinOp \u2502 \u2502 \u251c\u2500 left= c \u2502 \u2502 \u251c\u2500 op= operator.Mul \u2502 \u2502 \u251c\u2500 right= a \u2502 \u2502 \u2570\u2500 type= ttype.Integer \u2502 \u2502 \u251c\u2500 kind= 4 \u2502 \u2502 \u2570\u2500 dims=[] \u2502 \u251c\u2500 bind= None \u2502 \u251c\u2500 return_var= r \u2502 \u251c\u2500 module= None \u2502 \u2570\u2500 symtab=Scope \u2502 \u251c\u2500 a = expr.VariableOld \u2502 \u2502 \u251c\u2500 name= 'a' \u2502 \u2502 \u251c\u2500 intent= 'in' \u2502 \u2502 \u251c\u2500 dummy= True \u2502 \u2502 \u2570\u2500 type= ttype.Integer \u2502 \u2502 \u251c\u2500 kind= 4 \u2502 \u2502 \u2570\u2500 dims=[] \u2502 \u251c\u2500 b = expr.VariableOld \u2502 \u2502 \u251c\u2500 name= 'b' \u2502 \u2502 \u251c\u2500 intent= 'in' \u2502 \u2502 \u251c\u2500 dummy= True \u2502 \u2502 \u2570\u2500 type= ttype.Integer \u2502 \u2502 \u251c\u2500 kind= 4 \u2502 \u2502 \u2570\u2500 dims=[] \u2502 \u251c\u2500 r = expr.VariableOld \u2502 \u2502 \u251c\u2500 name= 'r' \u2502 \u2502 \u251c\u2500 intent= None \u2502 \u2502 \u251c\u2500 dummy= True \u2502 \u2502 \u2570\u2500 type= ttype.Integer \u2502 \u2502 \u251c\u2500 kind= 4 \u2502 \u2502 \u2570\u2500 dims=[] \u2502 \u251c\u2500 c = expr.VariableOld \u2502 \u2502 \u251c\u2500 name= 'c' \u2502 \u2502 \u251c\u2500 intent= None \u2502 \u2502 \u251c\u2500 dummy= False \u2502 \u2502 \u2570\u2500 type= ttype.Integer \u2502 \u2502 \u251c\u2500 kind= 4 \u2502 \u2502 \u2570\u2500 dims=[] \u2502 \u2570\u2500 d = expr.VariableOld \u2502 \u251c\u2500 name= 'd' \u2502 \u251c\u2500 intent= None \u2502 \u251c\u2500 dummy= False \u2502 \u2570\u2500 type= ttype.Integer \u2502 \u251c\u2500 kind= 4 \u2502 \u2570\u2500 dims=[] \u2570\u2500 items=[] The ASR has all the semantic information (types, etc.), nodes like Function have a symbol table and do not have any declaration nodes. Variables are simply pointers to the symbol table.","title":"ASR"},{"location":"AST%20and%20ASR/#discussion","text":"The above was a simple example. Things get more apparent for more complicated examples, such as: integer function f2b(a) result(r) use gfort_interop, only: c_desc1_int32 integer, intent(in) :: a(:) interface integer function f2b_c_wrapper(a) bind(c, name=\"__mod1_MOD_f2b\") use gfort_interop, only: c_desc1_t type(c_desc1_t), intent(in) :: a end function end interface r = f2b_c_wrapper(c_desc1_int32(a)) end function AST must represent all the use statements and the interface block, and keep things semantically consistent. ASR, on the other hand, keeps track of the c_desc1_int32 , c_desc1_t and f2b_c_wrapper in the symbol table and it knows they are defined in the gfort_interop module, and so ASR does not have any of these declaration nodes. When converting from ASR to AST, LFortran will create all the appropriate AST declaration nodes automatically and correctly.","title":"Discussion"},{"location":"design/","text":"LFortran Design High Level Overview LFortran is structured around two independent modules, AST and ASR, both of which are standalone (completely independent of the rest of LFortran) and users are encouraged to use them independently for other applications and build tools on top: Abstract Syntax Tree (AST), module lfortran.ast : Represents any Fortran source code, strictly based on syntax, no semantic is included. The AST module can convert itself to Fortran source code. Abstract Semantic Representation (ASR), module lfortran.asr : Represents a valid Fortran source code, all semantic is included. Invalid Fortran code is not allowed (an error will be given). The ASR module can convert itself to an AST. The LFortran compiler is then composed of the following independent stages: Parsing: converts Fotran source code to an AST Semantic: converts an AST to an ASR High level optimizations: optimize ASR to a possibly faster/simpler ASR (things like inlining functions, eliminating redundant expressions or statements, etc.) LLVM IR code generation and lower level optimizations: converts an ASR to an LLVM IR. This stage also does all other optimizations that do not produce an ASR, but still make sense to do before passing to LLVM IR. Machine code generation: LLVM then does all its optimizations and generates machine code (such as a binary executable, a library, an object file, or it is loaded and executed using JIT as part of the interactive LFortran session or in a Jupyter kernel). LFortran is structured as a library, and so one can for example use the parser to obtain an AST and do something with it, or one can then use the semantic analyzer to obtain ASR and do something with it. One can generate the ASR directly (e.g., from SymPy) and then either convert to AST and to a Fortran source code, or use LFortran to compile it to machine code directly. In other words, one can use LFortran to easily convert between the three equivalent representations: Fortran source code Abstract Syntax Tree (AST) Abstract Semantic Representation (ASR) They are all equivalent in the following sense: Any ASR can always be converted to an equivalent AST Any AST can always be converted to an equivalent Fortran source code Any Fortran source code can always be either converted to an equivalent AST or one gets a syntax error Any AST can always be either converted to an equivalent ASR or one gets a semantic error So when a conversion can be done, they are equivalent, and the conversion can always be done unless the code is invalid. ASR Design Details The ASR is designed to have the following features: ASR is still semantically equivalent to the original Fortran code (it did not lose any semantic information). ASR can be converted to AST, and AST to Fortran source code which is functionally equivalent to the original. ASR is as simple as possible: it does not contain any information that could not be inferred from ASR. The ASR C++ classes (down the road) are designed similarly to SymEngine: they are constructed once and after that they are immutable. The constructor checks in Debug more that all the requirements are met (e.g., that all Variables in a Function have a dummy argument set, that explicit-shape arrays are not allocatable and all other Fortran requirements to make it a valid code), but in Release mode it quickly constructs the class without checks. Then there are builder classes that construct the ASR C++ classes to meet requirements (checked in Debug mode) and the builder gives an error message if a code is not a valid Fortran code, and if it doesn't give an error message, then the ASR C++ classes are constructed correctly. Thus by construction, the ASR classes always contain valid Fortran code and the rest of LFortran can depend on it. Notes: Information that is lost when parsing source to AST: whitespace, multiline/single line if statement distinction, case sensitivity of keywords. Information that is lost when going from AST to ASR: detailed syntax how variables were defined and the order of type attributes (whether array dimension is using the dimension attribute, or parentheses at the variable; or how many variables there are per declaration line or their order), as ASR only represents the aggregated type information in the symbol table. ASR is the simplest way to generate Fortran code, as one does not have to worry about the detailed syntax (as in AST) about how and where things are declared. One specifies the symbol table for a module, then for each symbol (functions, global variables, types, ...) one specifies the local variables and if this is an interface then one needs to specify where one can find an implementation, otherwise a body is supplied with statements, those nodes are almost the same as in AST, except that each variable is just a reference to a symbol in the symbol table (so by construction one cannot have undefined variables). The symbol table for each node such as Function or Module also references its parent (for example a function references a module, a module references the global scope). The ASR can be directly converted to an AST without gathering any other information. And the AST directly to Fortran source code. The ASR is always representing a semantically valid Fortran code. This is enforced by checks in the ASR C++ constructors (in Debug build). When an ASR is used, one can assume it is valid. Fortran 2008 Fortran 2008 standard chapter 2 \"Fortran concepts\" specifies that Fortran code is a collection of program units (either all in one file, or in separate files), where each program unit is one of: main program module or submodule function or subroutine Note: It can also be a block data program unit, that is used to provide initial values for data objects in named common blocks , but we do not recommend the use of common blocks (use modules instead). LFortran Extension We extend the Fortran language by introducing a global scope , which is not only the list of program units (as in F2008) but can also include statements, declarations, use statements and expressions. We define global scope as a collection of the following items: main program module or submodule function or subroutine use statement declaration statement expression In addition, if a variable is not defined in an assignment statement (such as x = 5+3 ) then the type of the variable is inferred from the right hand side (e.g., x in x = 5+3 would be of type integer , and y in y = 5._dp would be of type real(dp) ). This rule only applies at the top level of global scope . Types must be fully specified inside main programs, modules, functions and subroutines, just like in F2008. The global scope has its own symbol table. The main program and module/submodule do not see any symbols from this symbol table. But functions, subroutines, statements and expressions at the top level of global scope use and operate on this symbol table. The global scope has the following symbols predefined in the symbol table: the usual standard set of Fortran functions (such as size , sin , cos , ...) the dp double precision symbol, so that one can use 5._dp for double precision. Each item in the global scope is interpreted as follows: main program is compiled into an executable with the same name and executed; modules, functions and subroutines are compiled and loaded; use statement and declaration adds those symbols with the proper type into the global scope symbol table, but do not generate any code; statement is wrapped into an anonymous subroutine with no arguments, compiled, loaded and executed; expression is wrapped into an anonymous function with no arguments returning the expression, compiled, loaded, executed and the return value is returned to the user. The global scope is always interpreted, item by item, per the previous paragraph. It is meant to allow interactive usage, experimentations and writing simple scripts. Code in global scope must be interpreted using lfortran . For more complex (production) code it is recommended to turn it into modules and programs (by wrapping loose statements into subroutines or functions and by adding type declarations) and compile it with lfortran or any other Fortran compiler. Here are some examples of valid code in global scope : Example 1 a = 5 print *, a Example 2 a = 5 subroutine p() print *, a end subroutine call p() Example 3 module a implicit none integer :: i end module use a, only: i i = 5 Example 4 x = [1, 2, 3] y = [1, 2, 1] call plot(x, y, \"o-\") Design Considerations The LFortran extension of Fortran was chosen in a way so as to minimize the number of changes. In particular, only the top level of the global scope has relaxed some of the Fortran rules (such as making specifying types optional) so as to allow simple and quick interactive usage, but inside functions, subroutines, modules or programs this relaxation does not apply. The number of changes were kept to minimum in order to make it straightforward to turn code at global scope into standard compliant Fortran code using programs and modules, so that it can be compiled by any Fortran compiler.","title":"LFortran Design"},{"location":"design/#lfortran-design","text":"","title":"LFortran Design"},{"location":"design/#high-level-overview","text":"LFortran is structured around two independent modules, AST and ASR, both of which are standalone (completely independent of the rest of LFortran) and users are encouraged to use them independently for other applications and build tools on top: Abstract Syntax Tree (AST), module lfortran.ast : Represents any Fortran source code, strictly based on syntax, no semantic is included. The AST module can convert itself to Fortran source code. Abstract Semantic Representation (ASR), module lfortran.asr : Represents a valid Fortran source code, all semantic is included. Invalid Fortran code is not allowed (an error will be given). The ASR module can convert itself to an AST. The LFortran compiler is then composed of the following independent stages: Parsing: converts Fotran source code to an AST Semantic: converts an AST to an ASR High level optimizations: optimize ASR to a possibly faster/simpler ASR (things like inlining functions, eliminating redundant expressions or statements, etc.) LLVM IR code generation and lower level optimizations: converts an ASR to an LLVM IR. This stage also does all other optimizations that do not produce an ASR, but still make sense to do before passing to LLVM IR. Machine code generation: LLVM then does all its optimizations and generates machine code (such as a binary executable, a library, an object file, or it is loaded and executed using JIT as part of the interactive LFortran session or in a Jupyter kernel). LFortran is structured as a library, and so one can for example use the parser to obtain an AST and do something with it, or one can then use the semantic analyzer to obtain ASR and do something with it. One can generate the ASR directly (e.g., from SymPy) and then either convert to AST and to a Fortran source code, or use LFortran to compile it to machine code directly. In other words, one can use LFortran to easily convert between the three equivalent representations: Fortran source code Abstract Syntax Tree (AST) Abstract Semantic Representation (ASR) They are all equivalent in the following sense: Any ASR can always be converted to an equivalent AST Any AST can always be converted to an equivalent Fortran source code Any Fortran source code can always be either converted to an equivalent AST or one gets a syntax error Any AST can always be either converted to an equivalent ASR or one gets a semantic error So when a conversion can be done, they are equivalent, and the conversion can always be done unless the code is invalid.","title":"High Level Overview"},{"location":"design/#asr-design-details","text":"The ASR is designed to have the following features: ASR is still semantically equivalent to the original Fortran code (it did not lose any semantic information). ASR can be converted to AST, and AST to Fortran source code which is functionally equivalent to the original. ASR is as simple as possible: it does not contain any information that could not be inferred from ASR. The ASR C++ classes (down the road) are designed similarly to SymEngine: they are constructed once and after that they are immutable. The constructor checks in Debug more that all the requirements are met (e.g., that all Variables in a Function have a dummy argument set, that explicit-shape arrays are not allocatable and all other Fortran requirements to make it a valid code), but in Release mode it quickly constructs the class without checks. Then there are builder classes that construct the ASR C++ classes to meet requirements (checked in Debug mode) and the builder gives an error message if a code is not a valid Fortran code, and if it doesn't give an error message, then the ASR C++ classes are constructed correctly. Thus by construction, the ASR classes always contain valid Fortran code and the rest of LFortran can depend on it.","title":"ASR Design Details"},{"location":"design/#notes","text":"Information that is lost when parsing source to AST: whitespace, multiline/single line if statement distinction, case sensitivity of keywords. Information that is lost when going from AST to ASR: detailed syntax how variables were defined and the order of type attributes (whether array dimension is using the dimension attribute, or parentheses at the variable; or how many variables there are per declaration line or their order), as ASR only represents the aggregated type information in the symbol table. ASR is the simplest way to generate Fortran code, as one does not have to worry about the detailed syntax (as in AST) about how and where things are declared. One specifies the symbol table for a module, then for each symbol (functions, global variables, types, ...) one specifies the local variables and if this is an interface then one needs to specify where one can find an implementation, otherwise a body is supplied with statements, those nodes are almost the same as in AST, except that each variable is just a reference to a symbol in the symbol table (so by construction one cannot have undefined variables). The symbol table for each node such as Function or Module also references its parent (for example a function references a module, a module references the global scope). The ASR can be directly converted to an AST without gathering any other information. And the AST directly to Fortran source code. The ASR is always representing a semantically valid Fortran code. This is enforced by checks in the ASR C++ constructors (in Debug build). When an ASR is used, one can assume it is valid.","title":"Notes:"},{"location":"design/#fortran-2008","text":"Fortran 2008 standard chapter 2 \"Fortran concepts\" specifies that Fortran code is a collection of program units (either all in one file, or in separate files), where each program unit is one of: main program module or submodule function or subroutine Note: It can also be a block data program unit, that is used to provide initial values for data objects in named common blocks , but we do not recommend the use of common blocks (use modules instead).","title":"Fortran 2008"},{"location":"design/#lfortran-extension","text":"We extend the Fortran language by introducing a global scope , which is not only the list of program units (as in F2008) but can also include statements, declarations, use statements and expressions. We define global scope as a collection of the following items: main program module or submodule function or subroutine use statement declaration statement expression In addition, if a variable is not defined in an assignment statement (such as x = 5+3 ) then the type of the variable is inferred from the right hand side (e.g., x in x = 5+3 would be of type integer , and y in y = 5._dp would be of type real(dp) ). This rule only applies at the top level of global scope . Types must be fully specified inside main programs, modules, functions and subroutines, just like in F2008. The global scope has its own symbol table. The main program and module/submodule do not see any symbols from this symbol table. But functions, subroutines, statements and expressions at the top level of global scope use and operate on this symbol table. The global scope has the following symbols predefined in the symbol table: the usual standard set of Fortran functions (such as size , sin , cos , ...) the dp double precision symbol, so that one can use 5._dp for double precision. Each item in the global scope is interpreted as follows: main program is compiled into an executable with the same name and executed; modules, functions and subroutines are compiled and loaded; use statement and declaration adds those symbols with the proper type into the global scope symbol table, but do not generate any code; statement is wrapped into an anonymous subroutine with no arguments, compiled, loaded and executed; expression is wrapped into an anonymous function with no arguments returning the expression, compiled, loaded, executed and the return value is returned to the user. The global scope is always interpreted, item by item, per the previous paragraph. It is meant to allow interactive usage, experimentations and writing simple scripts. Code in global scope must be interpreted using lfortran . For more complex (production) code it is recommended to turn it into modules and programs (by wrapping loose statements into subroutines or functions and by adding type declarations) and compile it with lfortran or any other Fortran compiler. Here are some examples of valid code in global scope :","title":"LFortran Extension"},{"location":"design/#example-1","text":"a = 5 print *, a","title":"Example 1"},{"location":"design/#example-2","text":"a = 5 subroutine p() print *, a end subroutine call p()","title":"Example 2"},{"location":"design/#example-3","text":"module a implicit none integer :: i end module use a, only: i i = 5","title":"Example 3"},{"location":"design/#example-4","text":"x = [1, 2, 3] y = [1, 2, 1] call plot(x, y, \"o-\")","title":"Example 4"},{"location":"design/#design-considerations","text":"The LFortran extension of Fortran was chosen in a way so as to minimize the number of changes. In particular, only the top level of the global scope has relaxed some of the Fortran rules (such as making specifying types optional) so as to allow simple and quick interactive usage, but inside functions, subroutines, modules or programs this relaxation does not apply. The number of changes were kept to minimum in order to make it straightforward to turn code at global scope into standard compliant Fortran code using programs and modules, so that it can be compiled by any Fortran compiler.","title":"Design Considerations"},{"location":"developer_tutorial/","text":"Developer Tutorial This is a tutorial for anybody who wants to either develop LFortran or build tools on top. Introduction LFortran is structured around two independent modules, AST and ASR, both of which are standalone (completely independent of the rest of LFortran) and users are encouraged to use them independently for other applications and build tools on top: Abstract Syntax Tree (AST), module lfortran.ast : Represents any Fortran source code, strictly based on syntax, no semantic is included. The AST module can convert itself to Fortran source code. Abstract Semantic Representation (ASR), module lfortran.asr : Represents a valid Fortran source code, all semantic is included. Invalid Fortran code is not allowed (an error will be given). The ASR module can convert itself to an AST. Abstract Syntax Tree (AST) Fortran source code can be parsed into an AST using the src_to_ast() function: from lfortran.ast import src_to_ast, print_tree from lfortran.ast.ast_to_src import ast_to_src src = \"\"\"\\ integer function f(a, b) result(r) integer, intent(in) :: a, b r = a + b end function \"\"\" ast = src_to_ast(src, translation_unit=False) We can pretty print it using print_tree() ( #59 ): print_tree(ast) Legend: Node , Field, Token program_unit.Function \u251c\u2500 name= 'f' \u251c\u2500 args=\u2193 \u2502 \u251c\u2500 AST.arg \u2502 \u2502 \u2570\u2500 arg= 'a' \u2502 \u2570\u2500 AST.arg \u2502 \u2570\u2500 arg= 'b' \u251c\u2500 return_type= None \u251c\u2500 return_var= expr.Name \u2502 \u2570\u2500 id= 'r' \u251c\u2500 bind= None \u251c\u2500 use=[] \u251c\u2500 decl=\u2193 \u2502 \u2570\u2500 unit_decl2.Declaration \u2502 \u2570\u2500 vars=\u2193 \u2502 \u251c\u2500 AST.decl \u2502 \u2502 \u251c\u2500 sym= 'a' \u2502 \u2502 \u251c\u2500 sym_type= 'integer' \u2502 \u2502 \u251c\u2500 dims=[] \u2502 \u2502 \u251c\u2500 attrs=\u2193 \u2502 \u2502 \u2502 \u2570\u2500 attribute.Attribute \u2502 \u2502 \u2502 \u251c\u2500 name= 'intent' \u2502 \u2502 \u2502 \u2570\u2500 args=\u2193 \u2502 \u2502 \u2502 \u2570\u2500 AST.attribute_arg \u2502 \u2502 \u2502 \u2570\u2500 arg= 'in' \u2502 \u2502 \u2570\u2500 initializer= None \u2502 \u2570\u2500 AST.decl \u2502 \u251c\u2500 sym= 'b' \u2502 \u251c\u2500 sym_type= 'integer' \u2502 \u251c\u2500 dims=[] \u2502 \u251c\u2500 attrs=\u2193 \u2502 \u2502 \u2570\u2500 attribute.Attribute \u2502 \u2502 \u251c\u2500 name= 'intent' \u2502 \u2502 \u2570\u2500 args=\u2193 \u2502 \u2502 \u2570\u2500 AST.attribute_arg \u2502 \u2502 \u2570\u2500 arg= 'in' \u2502 \u2570\u2500 initializer= None \u251c\u2500 body=\u2193 \u2502 \u2570\u2500 stmt.Assignment \u2502 \u251c\u2500 target= expr.Name \u2502 \u2502 \u2570\u2500 id= 'r' \u2502 \u2570\u2500 value= expr.BinOp \u2502 \u251c\u2500 left= expr.Name \u2502 \u2502 \u2570\u2500 id= 'a' \u2502 \u251c\u2500 op= operator.Add \u2502 \u2570\u2500 right= expr.Name \u2502 \u2570\u2500 id= 'b' \u2570\u2500 contains=[] We can convert AST to Fortran source code using ast_to_src() : print(ast_to_src(ast)) function f(a, b) result(r) integer, intent(in) :: a integer, intent(in) :: b r = a + b end function All AST nodes and their arguments are described in AST.asdl . Abstract Semantic Representation (ASR) We can convert AST to ASR using the ast_to_asr() function: from lfortran.semantic.ast_to_asr import ast_to_asr from lfortran.asr.pprint import pprint_asr asr = ast_to_asr(ast) We can pretty print using the pprint_asr() function: pprint_asr(asr) unit.TranslationUnit \u251c\u2500 global_scope=Scope \u2502 \u2570\u2500 f = fn.Function \u2502 \u251c\u2500 name= 'f' \u2502 \u251c\u2500 args=\u2193 \u2502 \u2502 \u251c\u2500 a \u2502 \u2502 \u2570\u2500 b \u2502 \u251c\u2500 body=\u2193 \u2502 \u2502 \u2570\u2500 stmt.Assignment \u2502 \u2502 \u251c\u2500 target= r \u2502 \u2502 \u2570\u2500 value= expr.BinOp \u2502 \u2502 \u251c\u2500 left= a \u2502 \u2502 \u251c\u2500 op= operator.Add \u2502 \u2502 \u251c\u2500 right= b \u2502 \u2502 \u2570\u2500 type= ttype.Integer \u2502 \u2502 \u251c\u2500 kind= 4 \u2502 \u2502 \u2570\u2500 dims=[] \u2502 \u251c\u2500 bind= None \u2502 \u251c\u2500 return_var= r \u2502 \u251c\u2500 module= None \u2502 \u2570\u2500 symtab=Scope \u2502 \u251c\u2500 a = expr.VariableOld \u2502 \u2502 \u251c\u2500 name= 'a' \u2502 \u2502 \u251c\u2500 intent= 'in' \u2502 \u2502 \u251c\u2500 dummy= True \u2502 \u2502 \u2570\u2500 type= ttype.Integer \u2502 \u2502 \u251c\u2500 kind= 4 \u2502 \u2502 \u2570\u2500 dims=[] \u2502 \u251c\u2500 b = expr.VariableOld \u2502 \u2502 \u251c\u2500 name= 'b' \u2502 \u2502 \u251c\u2500 intent= 'in' \u2502 \u2502 \u251c\u2500 dummy= True \u2502 \u2502 \u2570\u2500 type= ttype.Integer \u2502 \u2502 \u251c\u2500 kind= 4 \u2502 \u2502 \u2570\u2500 dims=[] \u2502 \u2570\u2500 r = expr.VariableOld \u2502 \u251c\u2500 name= 'r' \u2502 \u251c\u2500 intent= None \u2502 \u251c\u2500 dummy= True \u2502 \u2570\u2500 type= ttype.Integer \u2502 \u251c\u2500 kind= 4 \u2502 \u2570\u2500 dims=[] \u2570\u2500 items=[] For example to get the variables defined in the function scope: asr.global_scope.symbols[\"f\"].symtab.symbols.keys() dict_keys(['a', 'b', 'r']) We can convert ASR to AST and to source code: from lfortran.asr.asr_to_ast import asr_to_ast print(ast_to_src(asr_to_ast(asr))) integer function f(a, b) result(r) integer, intent(in) :: a integer, intent(in) :: b r = a + b end function All ASR nodes and their arguments are described in ASR.asdl .","title":"Developer Tutorial"},{"location":"developer_tutorial/#developer-tutorial","text":"This is a tutorial for anybody who wants to either develop LFortran or build tools on top.","title":"Developer Tutorial"},{"location":"developer_tutorial/#introduction","text":"LFortran is structured around two independent modules, AST and ASR, both of which are standalone (completely independent of the rest of LFortran) and users are encouraged to use them independently for other applications and build tools on top: Abstract Syntax Tree (AST), module lfortran.ast : Represents any Fortran source code, strictly based on syntax, no semantic is included. The AST module can convert itself to Fortran source code. Abstract Semantic Representation (ASR), module lfortran.asr : Represents a valid Fortran source code, all semantic is included. Invalid Fortran code is not allowed (an error will be given). The ASR module can convert itself to an AST.","title":"Introduction"},{"location":"developer_tutorial/#abstract-syntax-tree-ast","text":"Fortran source code can be parsed into an AST using the src_to_ast() function: from lfortran.ast import src_to_ast, print_tree from lfortran.ast.ast_to_src import ast_to_src src = \"\"\"\\ integer function f(a, b) result(r) integer, intent(in) :: a, b r = a + b end function \"\"\" ast = src_to_ast(src, translation_unit=False) We can pretty print it using print_tree() ( #59 ): print_tree(ast) Legend: Node , Field, Token program_unit.Function \u251c\u2500 name= 'f' \u251c\u2500 args=\u2193 \u2502 \u251c\u2500 AST.arg \u2502 \u2502 \u2570\u2500 arg= 'a' \u2502 \u2570\u2500 AST.arg \u2502 \u2570\u2500 arg= 'b' \u251c\u2500 return_type= None \u251c\u2500 return_var= expr.Name \u2502 \u2570\u2500 id= 'r' \u251c\u2500 bind= None \u251c\u2500 use=[] \u251c\u2500 decl=\u2193 \u2502 \u2570\u2500 unit_decl2.Declaration \u2502 \u2570\u2500 vars=\u2193 \u2502 \u251c\u2500 AST.decl \u2502 \u2502 \u251c\u2500 sym= 'a' \u2502 \u2502 \u251c\u2500 sym_type= 'integer' \u2502 \u2502 \u251c\u2500 dims=[] \u2502 \u2502 \u251c\u2500 attrs=\u2193 \u2502 \u2502 \u2502 \u2570\u2500 attribute.Attribute \u2502 \u2502 \u2502 \u251c\u2500 name= 'intent' \u2502 \u2502 \u2502 \u2570\u2500 args=\u2193 \u2502 \u2502 \u2502 \u2570\u2500 AST.attribute_arg \u2502 \u2502 \u2502 \u2570\u2500 arg= 'in' \u2502 \u2502 \u2570\u2500 initializer= None \u2502 \u2570\u2500 AST.decl \u2502 \u251c\u2500 sym= 'b' \u2502 \u251c\u2500 sym_type= 'integer' \u2502 \u251c\u2500 dims=[] \u2502 \u251c\u2500 attrs=\u2193 \u2502 \u2502 \u2570\u2500 attribute.Attribute \u2502 \u2502 \u251c\u2500 name= 'intent' \u2502 \u2502 \u2570\u2500 args=\u2193 \u2502 \u2502 \u2570\u2500 AST.attribute_arg \u2502 \u2502 \u2570\u2500 arg= 'in' \u2502 \u2570\u2500 initializer= None \u251c\u2500 body=\u2193 \u2502 \u2570\u2500 stmt.Assignment \u2502 \u251c\u2500 target= expr.Name \u2502 \u2502 \u2570\u2500 id= 'r' \u2502 \u2570\u2500 value= expr.BinOp \u2502 \u251c\u2500 left= expr.Name \u2502 \u2502 \u2570\u2500 id= 'a' \u2502 \u251c\u2500 op= operator.Add \u2502 \u2570\u2500 right= expr.Name \u2502 \u2570\u2500 id= 'b' \u2570\u2500 contains=[] We can convert AST to Fortran source code using ast_to_src() : print(ast_to_src(ast)) function f(a, b) result(r) integer, intent(in) :: a integer, intent(in) :: b r = a + b end function All AST nodes and their arguments are described in AST.asdl .","title":"Abstract Syntax Tree (AST)"},{"location":"developer_tutorial/#abstract-semantic-representation-asr","text":"We can convert AST to ASR using the ast_to_asr() function: from lfortran.semantic.ast_to_asr import ast_to_asr from lfortran.asr.pprint import pprint_asr asr = ast_to_asr(ast) We can pretty print using the pprint_asr() function: pprint_asr(asr) unit.TranslationUnit \u251c\u2500 global_scope=Scope \u2502 \u2570\u2500 f = fn.Function \u2502 \u251c\u2500 name= 'f' \u2502 \u251c\u2500 args=\u2193 \u2502 \u2502 \u251c\u2500 a \u2502 \u2502 \u2570\u2500 b \u2502 \u251c\u2500 body=\u2193 \u2502 \u2502 \u2570\u2500 stmt.Assignment \u2502 \u2502 \u251c\u2500 target= r \u2502 \u2502 \u2570\u2500 value= expr.BinOp \u2502 \u2502 \u251c\u2500 left= a \u2502 \u2502 \u251c\u2500 op= operator.Add \u2502 \u2502 \u251c\u2500 right= b \u2502 \u2502 \u2570\u2500 type= ttype.Integer \u2502 \u2502 \u251c\u2500 kind= 4 \u2502 \u2502 \u2570\u2500 dims=[] \u2502 \u251c\u2500 bind= None \u2502 \u251c\u2500 return_var= r \u2502 \u251c\u2500 module= None \u2502 \u2570\u2500 symtab=Scope \u2502 \u251c\u2500 a = expr.VariableOld \u2502 \u2502 \u251c\u2500 name= 'a' \u2502 \u2502 \u251c\u2500 intent= 'in' \u2502 \u2502 \u251c\u2500 dummy= True \u2502 \u2502 \u2570\u2500 type= ttype.Integer \u2502 \u2502 \u251c\u2500 kind= 4 \u2502 \u2502 \u2570\u2500 dims=[] \u2502 \u251c\u2500 b = expr.VariableOld \u2502 \u2502 \u251c\u2500 name= 'b' \u2502 \u2502 \u251c\u2500 intent= 'in' \u2502 \u2502 \u251c\u2500 dummy= True \u2502 \u2502 \u2570\u2500 type= ttype.Integer \u2502 \u2502 \u251c\u2500 kind= 4 \u2502 \u2502 \u2570\u2500 dims=[] \u2502 \u2570\u2500 r = expr.VariableOld \u2502 \u251c\u2500 name= 'r' \u2502 \u251c\u2500 intent= None \u2502 \u251c\u2500 dummy= True \u2502 \u2570\u2500 type= ttype.Integer \u2502 \u251c\u2500 kind= 4 \u2502 \u2570\u2500 dims=[] \u2570\u2500 items=[] For example to get the variables defined in the function scope: asr.global_scope.symbols[\"f\"].symtab.symbols.keys() dict_keys(['a', 'b', 'r']) We can convert ASR to AST and to source code: from lfortran.asr.asr_to_ast import asr_to_ast print(ast_to_src(asr_to_ast(asr))) integer function f(a, b) result(r) integer, intent(in) :: a integer, intent(in) :: b r = a + b end function All ASR nodes and their arguments are described in ASR.asdl .","title":"Abstract Semantic Representation (ASR)"},{"location":"installation/","text":"Installation All the instructions below work on Linux, macOS and Windows. Binaries The recommended way to install LFortran is using Conda. Install Conda for example by installing the Miniconda installation. Then create a new environment (you can choose any name, here we chose lf ) and activate it: conda create -n lf conda activate lf Then install LFortran by: conda install lfortran -c conda-forge Now the lf environment has the lfort compiler available, you can start the interactive prompt by executing lfort , or see the command line options using lfort -h . To install the Jupyter kernel, do: conda install jupyter fortran_kernel -c conda-forge Now you can create a Fortran based Jupyter notebook by executing: jupyter notebook and selecting New->Fortran . From a Tarball Using Pip One can install from source by pip installing LFortran. An example: conda create -n lf python=3.7 conda activate lf pip install lfortran Pip will automatically download all build and run time dependencies, compile and install LFortran. The only prerequisite that you have to have is a working C compiler. Now the lf environment has the lfort compiler available, you can start the interactive prompt by executing lfort , or see the command line options using lfort -h . Optional: run tests: pytest --pyargs lfortran You can also install any tarball from https://lfortran.org/download/ directly, e.g.: pip install https://lfortran.github.io/tarballs/release/lfortran-0.1.14.tar.gz or equivalently by: wget https://lfortran.github.io/tarballs/release/lfortran-0.1.14.tar.gz tar xzf lfortran-0.1.14.tar.gz cd lfortran-0.1.14 pip install . From Git Prepare the environment: conda create -n lf python=3.7 pytest llvmlite prompt_toolkit antlr-python-runtime scikit-build antlr cmake make -c conda-forge conda activate lf Clone the LFortran git repository: git clone https://gitlab.com/lfortran/lfortran cd lfortran Build: ./build.sh Run tests: pytest Run an interactive prompt: ./lfort Note About Dependencies End users (and distributions) are encouraged to use the tarball from https://lfortran.org/download/ , which only depends on Python and a few Python packages ( llvmlite , pytest , prompt_toolkit and antlr4-python3-runtime ). The LFortran standard library needs to be compiled and it needs a C compiler. Down the road (see our roadmap ), LFortran will be gradually rewritten in C++, so it will also depend on a C++ compiler. The tarball is generated automatically by our CI (continuous integration) and contains some autogenerated files: the parser, which is generated by ANTLR4 (requires Java) and the AST and ASR nodes, which is generated by an ASDL translator (requires Python). The Java requirement is only needed when using git directly, the tarball does not depend on Java in any way. The same tarball is accessible from our Downloads page as well as from PyPI.","title":"Installation"},{"location":"installation/#installation","text":"All the instructions below work on Linux, macOS and Windows.","title":"Installation"},{"location":"installation/#binaries","text":"The recommended way to install LFortran is using Conda. Install Conda for example by installing the Miniconda installation. Then create a new environment (you can choose any name, here we chose lf ) and activate it: conda create -n lf conda activate lf Then install LFortran by: conda install lfortran -c conda-forge Now the lf environment has the lfort compiler available, you can start the interactive prompt by executing lfort , or see the command line options using lfort -h . To install the Jupyter kernel, do: conda install jupyter fortran_kernel -c conda-forge Now you can create a Fortran based Jupyter notebook by executing: jupyter notebook and selecting New->Fortran .","title":"Binaries"},{"location":"installation/#from-a-tarball-using-pip","text":"One can install from source by pip installing LFortran. An example: conda create -n lf python=3.7 conda activate lf pip install lfortran Pip will automatically download all build and run time dependencies, compile and install LFortran. The only prerequisite that you have to have is a working C compiler. Now the lf environment has the lfort compiler available, you can start the interactive prompt by executing lfort , or see the command line options using lfort -h . Optional: run tests: pytest --pyargs lfortran You can also install any tarball from https://lfortran.org/download/ directly, e.g.: pip install https://lfortran.github.io/tarballs/release/lfortran-0.1.14.tar.gz or equivalently by: wget https://lfortran.github.io/tarballs/release/lfortran-0.1.14.tar.gz tar xzf lfortran-0.1.14.tar.gz cd lfortran-0.1.14 pip install .","title":"From a Tarball Using Pip"},{"location":"installation/#from-git","text":"Prepare the environment: conda create -n lf python=3.7 pytest llvmlite prompt_toolkit antlr-python-runtime scikit-build antlr cmake make -c conda-forge conda activate lf Clone the LFortran git repository: git clone https://gitlab.com/lfortran/lfortran cd lfortran Build: ./build.sh Run tests: pytest Run an interactive prompt: ./lfort","title":"From Git"},{"location":"installation/#note-about-dependencies","text":"End users (and distributions) are encouraged to use the tarball from https://lfortran.org/download/ , which only depends on Python and a few Python packages ( llvmlite , pytest , prompt_toolkit and antlr4-python3-runtime ). The LFortran standard library needs to be compiled and it needs a C compiler. Down the road (see our roadmap ), LFortran will be gradually rewritten in C++, so it will also depend on a C++ compiler. The tarball is generated automatically by our CI (continuous integration) and contains some autogenerated files: the parser, which is generated by ANTLR4 (requires Java) and the AST and ASR nodes, which is generated by an ASDL translator (requires Python). The Java requirement is only needed when using git directly, the tarball does not depend on Java in any way. The same tarball is accessible from our Downloads page as well as from PyPI.","title":"Note About Dependencies"},{"location":"language/","text":"Fortran Language Background and Motivation Fortran was designed from the ground up to naturally and simply translate mathematics to code that compiles and runs at maximum speed. And being specifically targeted for such fundamentally computational tasks, it contains a broad range of key functionality within the language itself, standard across all platforms, with no need for external libraries that may or may not be well optimized or maintained, at present or down the road. Some highlights: Multidimensional arrays which can be allocated and indexed as the math/science dictates (not restricted to start at 0 or 1) and can be sliced as desired (as, e.g., in MATLAB); Operators which operate naturally upon the aforementioned arrays/matrices, as they do scalars; Complex numbers; Special functions; Structures and pointers for more general data representation. Because the essentials are contained in the language itself, it is simple to read and write, without need of choosing from among or deciphering a proliferation of external classes to do the same thing. And because the essentials are self-contained, compilers can provide detailed compile-time (e.g., argument mismatch) and run-time (e.g., memory access) checks, as well as highly optimized executables, directly from natural, readable code without need of extensive optimization heroics by the developer. See our blog posts for more information: Why We Created LFortran Why to Use Fortran For New Projects How to Learn Fortran Fortran is relatively quick to learn because it is so much simpler and smaller than C/C++ (in practice, that is, with all needed libraries included). If you are interested in learning more, please see our webpage at fortran90.org with recommended practices for writing code, side by side comparison with Python/NumPy, links to other online Fortran resources and books, and an FAQ.","title":"Fortran Language"},{"location":"language/#fortran-language","text":"","title":"Fortran Language"},{"location":"language/#background-and-motivation","text":"Fortran was designed from the ground up to naturally and simply translate mathematics to code that compiles and runs at maximum speed. And being specifically targeted for such fundamentally computational tasks, it contains a broad range of key functionality within the language itself, standard across all platforms, with no need for external libraries that may or may not be well optimized or maintained, at present or down the road. Some highlights: Multidimensional arrays which can be allocated and indexed as the math/science dictates (not restricted to start at 0 or 1) and can be sliced as desired (as, e.g., in MATLAB); Operators which operate naturally upon the aforementioned arrays/matrices, as they do scalars; Complex numbers; Special functions; Structures and pointers for more general data representation. Because the essentials are contained in the language itself, it is simple to read and write, without need of choosing from among or deciphering a proliferation of external classes to do the same thing. And because the essentials are self-contained, compilers can provide detailed compile-time (e.g., argument mismatch) and run-time (e.g., memory access) checks, as well as highly optimized executables, directly from natural, readable code without need of extensive optimization heroics by the developer. See our blog posts for more information: Why We Created LFortran Why to Use Fortran For New Projects","title":"Background and Motivation"},{"location":"language/#how-to-learn-fortran","text":"Fortran is relatively quick to learn because it is so much simpler and smaller than C/C++ (in practice, that is, with all needed libraries included). If you are interested in learning more, please see our webpage at fortran90.org with recommended practices for writing code, side by side comparison with Python/NumPy, links to other online Fortran resources and books, and an FAQ.","title":"How to Learn Fortran"},{"location":"progress/","text":"LFortran Development Status Development LFortran is currently under development and some of the features of Fortran might not be supported currently. The information regarding which functions are currently supported and which one's are still being worked on will be available in this section. You can submit any new issue you find while using LFortran to our issue tracker . You can also check out any of the issues mentioned in the sections below and provide suggestions and ideas to help us get the feature implemented. Fortran Standards Supported LFortran currently supports a subset of the latest Fortran standard Fortran 2018. This document describes details about which features are supported and which are not. Related Issues: #120 Features Supported LFortran is currently in development and you might find some unsupported features while using it. We are working on fixing the issues and improving and expanding LFortran. You can also help out by reporting any new bug you find or you can check out any of the issues mentioned in the section and help us implement the feature faster. Currently Supported: AST Genreation ASR Generation for most nodes Fortran Modules Functions Subroutines Basic data types like int, float, character Binary Operations Conditional and iterative statements Printing Not Supported/Currently in Development Strings and Arrays Nested Function Definitions Complex Numbers Optional Arguments ASR not created for a few features supported by LFortran Conditional and iterative statements Function Calls Arithmatic assignment(like a = 10) Assignments with binary operations including any number Logical Variables Print Statements Intrinsic Fortran Functions like abs, sin, cos etc. Related Issues #114 Strings #121 ASR #122 Nested Function Definitions #125 Complex Numbers #126 Optional Arguments Intrinsic Functions LFortran does not support some of the standard intrinsic functions for the Fortran standard. Work is being done on having support for these functions. The testing for the functions is still being done. The list will be updated with the rest of the functions soon. Currently Supported: log Not Suported/Currently in Development: abs sqrt sin cos tan asin acos atan exp int real nint floor fraction real max min mod","title":"LFortran Development Status"},{"location":"progress/#lfortran-development-status","text":"","title":"LFortran Development Status"},{"location":"progress/#development","text":"LFortran is currently under development and some of the features of Fortran might not be supported currently. The information regarding which functions are currently supported and which one's are still being worked on will be available in this section. You can submit any new issue you find while using LFortran to our issue tracker . You can also check out any of the issues mentioned in the sections below and provide suggestions and ideas to help us get the feature implemented.","title":"Development"},{"location":"progress/#fortran-standards-supported","text":"LFortran currently supports a subset of the latest Fortran standard Fortran 2018. This document describes details about which features are supported and which are not.","title":"Fortran Standards Supported"},{"location":"progress/#related-issues","text":"#120","title":"Related Issues:"},{"location":"progress/#features-supported","text":"LFortran is currently in development and you might find some unsupported features while using it. We are working on fixing the issues and improving and expanding LFortran. You can also help out by reporting any new bug you find or you can check out any of the issues mentioned in the section and help us implement the feature faster.","title":"Features Supported"},{"location":"progress/#currently-supported","text":"AST Genreation ASR Generation for most nodes Fortran Modules Functions Subroutines Basic data types like int, float, character Binary Operations Conditional and iterative statements Printing","title":"Currently Supported:"},{"location":"progress/#not-supportedcurrently-in-development","text":"Strings and Arrays Nested Function Definitions Complex Numbers Optional Arguments ASR not created for a few features supported by LFortran Conditional and iterative statements Function Calls Arithmatic assignment(like a = 10) Assignments with binary operations including any number Logical Variables Print Statements Intrinsic Fortran Functions like abs, sin, cos etc.","title":"Not Supported/Currently in Development"},{"location":"progress/#related-issues_1","text":"#114 Strings #121 ASR #122 Nested Function Definitions #125 Complex Numbers #126 Optional Arguments","title":"Related Issues"},{"location":"progress/#intrinsic-functions","text":"LFortran does not support some of the standard intrinsic functions for the Fortran standard. Work is being done on having support for these functions. The testing for the functions is still being done. The list will be updated with the rest of the functions soon.","title":"Intrinsic Functions"},{"location":"progress/#currently-supported_1","text":"log","title":"Currently Supported:"},{"location":"progress/#not-suportedcurrently-in-development","text":"abs sqrt sin cos tan asin acos atan exp int real nint floor fraction real max min mod","title":"Not Suported/Currently in Development:"}]}