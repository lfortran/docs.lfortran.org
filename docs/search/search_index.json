{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"LFortran Documentation LFortran is a modern open-source (BSD licensed) interactive Fortran compiler built on top of LLVM. It can execute user's code interactively to allow exploratory work (much like Python, MATLAB or Julia) as well as compile to binaries with the goal to run user's code on modern architectures such as multi-core CPUs and GPUs. Website: https://lfortran.org/ Main repository: https://github.com/lfortran/lfortran Try online using Binder: Feature Highlights LFortran is in development, there are features that work today, and there are features that are being implemented. You can also check out the Development Status section for more information on features being supported and being worked on. Works today Interactive, Jupyter support LFortran can be used from Jupyter as a Fortran kernel, allowing a Python/Julia style rapid prototyping and exploratory workflow (see the static or interactive example notebook). Or it can be used from the command-line in an interactive prompt (REPL). Clean, modular design, usable as a library LFortran is structured around two independent modules, AST and ASR, both of which are standalone (completely independent of the rest of LFortran) and users are encouraged to use them independently for other applications and build tools on top. See the Design and Developer Tutorial documents for more details. Interoperation with GFortran LFortran can parse GFortran module files into an ASR and generate a Fortran wrapper that can be compiled with any Fortran compiler and linked with the original GFortran compiled module. Create executables It can create executables just like other Fortran compilers. Runs on Linux, Mac and Windows All three platforms are regularly tested by our CI. Planned These features are under development, there is a link to the corresponding issue so that you can track the progress by following it. Native interoperation with other languages (and other Fortran compilers) It can automatically call code written in other languages (such as C or Python) just by using the use statement, see #44 . It understands other Fortran compilers module files (one can just \"use\" them) and their ABI to link correctly (GFortran is supported, other compilers are planned, see #56 ), which allows to use LFortran with production codes today. Modern hardware support Thanks to LLVM, the goal of LFortran is to run on modern hardware and take advantage of native Fortran language constructs (such as do concurrent ) to run on multi-core CPUs and GPUs, see #57 . Full Fortran 2018 support Currently only a subset of Fortran is implemented, but the goal is to have a full implementation of the latest Fortran 2018 standard, see #58 . Please vote on issues in our issue tracker that you want us to prioritize (feel free to create new ones if we are missing anything). Roadmap Here is our roadmap how to get all the planned features above implemented: Port code generation to use ASR and pass all the current tests ( #74 ). Remove the old code generation and old semantics, that used to annotate the AST tree, which was messy. Get GFortran module files working with use module, both assumed-size and assumed-shape arrays ( #52 ). This will allow right away to use production codes with LFortran. Do these at the same time: a) Implement more Fortran features, until eventually full Fortran 2018 is supported ( #58 ). b) Gradually move to C++ for robustness and speed ( #70 ). The Python API will not change (or only minimally), so the user experience from Python will not change. c) Implement all the other cool features: use module for C and Python and automatic wrappers ( #44 ), modern hardware support ( #57 ), generating an older standard of Fortran ( #72 ), Fortran doctest feature ( #73 ), SymPy integration ( #71 ), language service for IDEs ( #12 ), and other ideas ( #29 ). The step 1. is an internal refactoring that will not take long. The step 2. will allow LFortran to be used interactively with production codes right away (the production code will get compiled with GFortran, then one \"uses\" any module in LFortran and functions/subroutines can be interactively called, the module itself can use any GFortran supported feature, but the API must fit into the subset that LFortran understands --- for large number of applications simple functions/subroutines with array arguments are enough). This will make LFortran usable for first users and one can always use GFortran temporarily until LFortran supports the given feature. We expect to be finished with the step 2. by the end of summer 2019, hopefully sooner. Finally the step 3. will improve LFortran overall, allowing the first users to contribute back, growing the community and making LFortran gradually useful for more and more people.","title":"Home"},{"location":"#lfortran-documentation","text":"LFortran is a modern open-source (BSD licensed) interactive Fortran compiler built on top of LLVM. It can execute user's code interactively to allow exploratory work (much like Python, MATLAB or Julia) as well as compile to binaries with the goal to run user's code on modern architectures such as multi-core CPUs and GPUs. Website: https://lfortran.org/ Main repository: https://github.com/lfortran/lfortran Try online using Binder:","title":"LFortran Documentation"},{"location":"#feature-highlights","text":"LFortran is in development, there are features that work today, and there are features that are being implemented. You can also check out the Development Status section for more information on features being supported and being worked on.","title":"Feature Highlights"},{"location":"#works-today","text":"Interactive, Jupyter support LFortran can be used from Jupyter as a Fortran kernel, allowing a Python/Julia style rapid prototyping and exploratory workflow (see the static or interactive example notebook). Or it can be used from the command-line in an interactive prompt (REPL). Clean, modular design, usable as a library LFortran is structured around two independent modules, AST and ASR, both of which are standalone (completely independent of the rest of LFortran) and users are encouraged to use them independently for other applications and build tools on top. See the Design and Developer Tutorial documents for more details. Interoperation with GFortran LFortran can parse GFortran module files into an ASR and generate a Fortran wrapper that can be compiled with any Fortran compiler and linked with the original GFortran compiled module. Create executables It can create executables just like other Fortran compilers. Runs on Linux, Mac and Windows All three platforms are regularly tested by our CI.","title":"Works today"},{"location":"#planned","text":"These features are under development, there is a link to the corresponding issue so that you can track the progress by following it. Native interoperation with other languages (and other Fortran compilers) It can automatically call code written in other languages (such as C or Python) just by using the use statement, see #44 . It understands other Fortran compilers module files (one can just \"use\" them) and their ABI to link correctly (GFortran is supported, other compilers are planned, see #56 ), which allows to use LFortran with production codes today. Modern hardware support Thanks to LLVM, the goal of LFortran is to run on modern hardware and take advantage of native Fortran language constructs (such as do concurrent ) to run on multi-core CPUs and GPUs, see #57 . Full Fortran 2018 support Currently only a subset of Fortran is implemented, but the goal is to have a full implementation of the latest Fortran 2018 standard, see #58 . Please vote on issues in our issue tracker that you want us to prioritize (feel free to create new ones if we are missing anything).","title":"Planned"},{"location":"#roadmap","text":"Here is our roadmap how to get all the planned features above implemented: Port code generation to use ASR and pass all the current tests ( #74 ). Remove the old code generation and old semantics, that used to annotate the AST tree, which was messy. Get GFortran module files working with use module, both assumed-size and assumed-shape arrays ( #52 ). This will allow right away to use production codes with LFortran. Do these at the same time: a) Implement more Fortran features, until eventually full Fortran 2018 is supported ( #58 ). b) Gradually move to C++ for robustness and speed ( #70 ). The Python API will not change (or only minimally), so the user experience from Python will not change. c) Implement all the other cool features: use module for C and Python and automatic wrappers ( #44 ), modern hardware support ( #57 ), generating an older standard of Fortran ( #72 ), Fortran doctest feature ( #73 ), SymPy integration ( #71 ), language service for IDEs ( #12 ), and other ideas ( #29 ). The step 1. is an internal refactoring that will not take long. The step 2. will allow LFortran to be used interactively with production codes right away (the production code will get compiled with GFortran, then one \"uses\" any module in LFortran and functions/subroutines can be interactively called, the module itself can use any GFortran supported feature, but the API must fit into the subset that LFortran understands --- for large number of applications simple functions/subroutines with array arguments are enough). This will make LFortran usable for first users and one can always use GFortran temporarily until LFortran supports the given feature. We expect to be finished with the step 2. by the end of summer 2019, hopefully sooner. Finally the step 3. will improve LFortran overall, allowing the first users to contribute back, growing the community and making LFortran gradually useful for more and more people.","title":"Roadmap"},{"location":"ast_and_asr/","text":"Difference between an AST and ASR Let us take a simple Fortran code: integer function f ( a , b ) result ( r ) integer , intent ( in ) :: a , b integer :: c , d c = a + b - d r = c * a end function and look at how the AST and ASR looks like. AST %% showast integer function f ( a , b ) result ( r ) integer , intent ( in ) :: a , b integer :: c , d c = a + b - d r = c * a end function ( TranslationUnit [( Function f [(a) (b)] [( AttrType TypeInteger [] () None )] r () () [] [] [] [( Declaration ( AttrType TypeInteger [] () None ) [( AttrIntent In )] [(a [] [] () None ()) (b [] [] () None ())] ()) ( Declaration ( AttrType TypeInteger [] () None ) [] [(c [] [] () None ()) (d [] [] () None ())] ())] [( = 0 c (- (+ a b ) d ) ()) ( = 0 r (* c a ) ())] [])]) The AST does not have any semantic information, but has nodes to represent declarations such as integer, intent(in) :: a . Variables such as a are represented by a Name node, and are not connected to their declarations yet. ASR %% showasr integer function f ( a , b ) result ( r ) integer , intent ( in ) :: a , b integer :: c , d c = a + b - d r = c * a end function ( TranslationUnit ( SymbolTable 1 {f: ( Function ( SymbolTable 2 {a: ( Variable 2 a In () () Default ( Integer 4 []) Source Public Required .false.), b: ( Variable 2 b In () () Default ( Integer 4 []) Source Public Required .false.), c: ( Variable 2 c Local () () Default ( Integer 4 []) Source Public Required .false.), d: ( Variable 2 d Local () () Default ( Integer 4 []) Source Public Required .false.), r: ( Variable 2 r ReturnVar () () Default ( Integer 4 []) Source Public Required .false.)}) f [( Var 2 a ) ( Var 2 b )] [] [( = ( Var 2 c ) ( IntegerBinOp ( IntegerBinOp ( Var 2 a ) Add ( Var 2 b ) ( Integer 4 []) ()) Sub ( Var 2 d ) ( Integer 4 []) ()) ()) ( = ( Var 2 r ) ( IntegerBinOp ( Var 2 c ) Mul ( Var 2 a ) ( Integer 4 []) ()) ())] ( Var 2 r ) Source Public Implementation () .false. .false. .false.)}) []) The ASR has all the semantic information (types, etc.), nodes like Function have a symbol table and do not have any declaration nodes. Variables are simply pointers to the symbol table. Discussion The above was a simple example. Things get more apparent for more complicated examples, such as: integer function f2b ( a ) result ( r ) use gfort_interop , only : c_desc1_int32 integer , intent ( in ) :: a (:) interface integer function f2b_c_wrapper ( a ) bind ( c , name = \"__mod1_MOD_f2b\" ) use gfort_interop , only : c_desc1_t type ( c_desc1_t ), intent ( in ) :: a end function end interface r = f2b_c_wrapper ( c_desc1_int32 ( a )) end function AST must represent all the use statements and the interface block, and keep things semantically consistent. ASR, on the other hand, keeps track of the c_desc1_int32 , c_desc1_t and f2b_c_wrapper in the symbol table and it knows they are defined in the gfort_interop module, and so ASR does not have any of these declaration nodes. When converting from ASR to AST, LFortran will create all the appropriate AST declaration nodes automatically and correctly.","title":"Difference between an AST and ASR"},{"location":"ast_and_asr/#difference-between-an-ast-and-asr","text":"Let us take a simple Fortran code: integer function f ( a , b ) result ( r ) integer , intent ( in ) :: a , b integer :: c , d c = a + b - d r = c * a end function and look at how the AST and ASR looks like.","title":"Difference between an AST and ASR"},{"location":"ast_and_asr/#ast","text":"%% showast integer function f ( a , b ) result ( r ) integer , intent ( in ) :: a , b integer :: c , d c = a + b - d r = c * a end function ( TranslationUnit [( Function f [(a) (b)] [( AttrType TypeInteger [] () None )] r () () [] [] [] [( Declaration ( AttrType TypeInteger [] () None ) [( AttrIntent In )] [(a [] [] () None ()) (b [] [] () None ())] ()) ( Declaration ( AttrType TypeInteger [] () None ) [] [(c [] [] () None ()) (d [] [] () None ())] ())] [( = 0 c (- (+ a b ) d ) ()) ( = 0 r (* c a ) ())] [])]) The AST does not have any semantic information, but has nodes to represent declarations such as integer, intent(in) :: a . Variables such as a are represented by a Name node, and are not connected to their declarations yet.","title":"AST"},{"location":"ast_and_asr/#asr","text":"%% showasr integer function f ( a , b ) result ( r ) integer , intent ( in ) :: a , b integer :: c , d c = a + b - d r = c * a end function ( TranslationUnit ( SymbolTable 1 {f: ( Function ( SymbolTable 2 {a: ( Variable 2 a In () () Default ( Integer 4 []) Source Public Required .false.), b: ( Variable 2 b In () () Default ( Integer 4 []) Source Public Required .false.), c: ( Variable 2 c Local () () Default ( Integer 4 []) Source Public Required .false.), d: ( Variable 2 d Local () () Default ( Integer 4 []) Source Public Required .false.), r: ( Variable 2 r ReturnVar () () Default ( Integer 4 []) Source Public Required .false.)}) f [( Var 2 a ) ( Var 2 b )] [] [( = ( Var 2 c ) ( IntegerBinOp ( IntegerBinOp ( Var 2 a ) Add ( Var 2 b ) ( Integer 4 []) ()) Sub ( Var 2 d ) ( Integer 4 []) ()) ()) ( = ( Var 2 r ) ( IntegerBinOp ( Var 2 c ) Mul ( Var 2 a ) ( Integer 4 []) ()) ())] ( Var 2 r ) Source Public Implementation () .false. .false. .false.)}) []) The ASR has all the semantic information (types, etc.), nodes like Function have a symbol table and do not have any declaration nodes. Variables are simply pointers to the symbol table.","title":"ASR"},{"location":"ast_and_asr/#discussion","text":"The above was a simple example. Things get more apparent for more complicated examples, such as: integer function f2b ( a ) result ( r ) use gfort_interop , only : c_desc1_int32 integer , intent ( in ) :: a (:) interface integer function f2b_c_wrapper ( a ) bind ( c , name = \"__mod1_MOD_f2b\" ) use gfort_interop , only : c_desc1_t type ( c_desc1_t ), intent ( in ) :: a end function end interface r = f2b_c_wrapper ( c_desc1_int32 ( a )) end function AST must represent all the use statements and the interface block, and keep things semantically consistent. ASR, on the other hand, keeps track of the c_desc1_int32 , c_desc1_t and f2b_c_wrapper in the symbol table and it knows they are defined in the gfort_interop module, and so ASR does not have any of these declaration nodes. When converting from ASR to AST, LFortran will create all the appropriate AST declaration nodes automatically and correctly.","title":"Discussion"},{"location":"contributing/","text":"Contributing We welcome contributions from anyone, even if you are new to open source. It might sound daunting to contribute to a compiler at first, but please do, it is not complicated. We will help you with any technical issues and help improve your contribution so that it can be merged. Basic Setup To contribute, make sure your set up: Your username + email Your ~/.gitconfig Your shell prompt to display the current branch name Fork LFortran Step 1. Create a fork of the project repository Step 2. Set up your SSH key with GitHub Step 3. Clone the project repository from GitHub and set up your remote repository git clone https://github.com/lfortran/lfortran.git cd lfortran git remote add REMOTE_NAME git@github.com:YOUR_GITHUB_ID/lfortran.git :fontawesome-solid-edit: REMOTE_NAME is the name of your remote repository and could be any name you like, for example your first name. :fontawesome-solid-edit: YOUR_GITHUB_ID is your user ID on GitHub and should be part of your account path. You can use git remote -v to check if the new remote is set up correctly. Send a New Merge Request Step 1. Create a new branch git checkout -b fix1 Step 2. Make changes in relevant file(s) Step 3. Commit the changes: git add FILE1 (FILE2 ...) git commit -m \"YOUR_COMMIT_MESSAGE\" Here are some great tips on writing good commit messages. Step 4. Check to ensure that your changes look good git log --pretty=oneline --graph --decorate --all Step 5. Send the merge request git push REMOTE_NAME fix1 The command will push the new branch fix1 into your remote repository REMOTE_NAME that you created earlier. Additionally, it will also display a link that you can click on to open the new merge request. After clicking on the link, write a title and a concise description then click the \"Create\" button. Yay you are now all set. Add New Features The example below shows the steps it would take to create a caret binary operator ^ which computes the average value of the two operands. Create New Token(s) We extend the tokenizer.re as well as parser.yy to add the new token ^ . We also tell LFortran how to print the new token in parser.cpp . src/lfortran/parser/tokenizer.re // \"^\" { RET(TK_CARET) } src/lfortran/parser/parser.yy %token TK_CARET \"^\" src/lfortran/parser/parser.cpp std:string token2text(const int token) { switch (token) { T(TK_CARET, \"^\") } } The added code is tested with lfortran --show-tokens examples2/expr2.f90 Parse the New Token Now we have to parse the new operator. We add it to the AST by extending the BinOp with a caret operator and modifying the AST.asdl file. Then we add it in parse.yy to properly parse and generate the new AST in semantics.h .Finally we extend pickle.cpp so that the new operator can print itself. grammar/AST.asdl operator = Add | Sub | Mul | Div | Pow | Caret src/lfortran/parser/parser.yy %left \"^\" expr : id { $$=$1; } | expr \"^\" expr { $$ = CARET($1, $3, @$); } src/lfortran/parser/semantics.h #define CARET(x,y,l) make_BinOp_t(p.m_a, l, EXPR(x), operatorType::Caret, EXPR(y)) src/lfortran/pickle.cpp std::string op2str(const operatorType type) { switch (type) { case (operatorType::Caret) : return \"^\"; } // now the caret operator can print itself } The section is tested with lfortran --show-ast examples/expr2.f90 Implement the Semantics of the New Token We first extend the ASR in ASR.asdl and add ^ as a BinOp operator option. src/libasr/ASR.asdl binop = Add | Sub | Mul | Div | Pow | Caret src/lfortran/semantics/ast_common_visitor.h namespace LFortran { class CommonVisitorMethods { public: inline static void visit_BinOp(Allocator &al, const AST::BinOp_t &x, ASR::expr_t *&left, ASR::expr_t *&right, ASR::asr_t *&asr) { ASR::binopType op; switch (x.m_op) { case (AST::Caret): op = ASR::Caret; break; } if (LFortran::ASRUtils::expr_value(left) != nullptr && LFortran::ASRUtils::expr_value(right) != nullptr) { if (ASR::is_a<LFortran::ASR::Integer_t>(*dest_type)) { int64_t left_value = ASR::down_cast<ASR::IntegerConstant_t>( LFortran::ASRUtils::expr_value(left)) ->m_n; int64_t right_value = ASR::down_cast<ASR::IntegerConstant_t>( LFortran::ASRUtils::expr_value(right)) ->m_n; int64_t result; switch (op) { case (ASR::Caret): result = (left_value + right_value)/2; break; } } } } } } Then we transform it from AST to ASR by extending src/lfortran/semantics/ast_common_visitor.h . We also add it into compile time evaluation triggered by expressions such as e = (2+3)^5 which is evaluated at compile time. An expression such as e = x^5 is evaluated at run time only. The section is tested with lfortran --show-asr examples/expr2.f90 Implement the New Token in LLVM To implement in LLVM, we extend the BinOp translation by handling the new operator. We first add the two numbers then divide by two. src/lfortran/codegen/asr_to_llvm.cpp void visit_BinOp(const ASR::BinOp_t &x) { if (x.m_value) { this->visit_expr_wrapper(x.m_value, true); return; } this->visit_expr_wrapper(x.m_left, true); llvm::Value *left_val = tmp; this->visit_expr_wrapper(x.m_right, true); llvm::Value *right_val = tmp; if (x.m_type->type == ASR::ttypeType::Integer || x.m_type->type == ASR::ttypeType::IntegerPointer) { switch (x.m_op) { case ASR::binopType::Caret: { tmp = builder->CreateAdd(left_val, right_val); llvm::Value *two = llvm::ConstantInt::get(context, llvm::APInt(32, 2, true)); tmp = builder->CreateUDiv(tmp, two); break; }; } } } The section is tested with lfortran --show-llvm examples/expr2.f90 Now when LLVM works, we can test the final executable by: lfortran examples/expr2.f90 ./a.out And it should print 6. It also works interactively: $ lfortran Interactive Fortran. Experimental prototype, not ready for end users. * Use Ctrl-D to exit * Use Enter to submit * Use Alt-Enter or Ctrl-N to make a new line - Editing (Keys: Left, Right, Home, End, Backspace, Delete) - History (Keys: Up, Down) >>> 4^8 1,4 ] 6 >>> integer :: x 1,13 ] >>> x = 4 1,6 ] >>> x^8 1,4 ] 6 Reach Out If you have any questions or need help, please ask as at our mailinglist or a chat . Please note that all participants of this project are expected to follow our Code of Conduct. By participating in this project you agree to abide by its terms. See CODE_OF_CONDUCT.md . By submitting a PR you agree to license your contribution under the LFortran's BSD license unless explicitly noted otherwise.","title":"Contributing"},{"location":"contributing/#contributing","text":"We welcome contributions from anyone, even if you are new to open source. It might sound daunting to contribute to a compiler at first, but please do, it is not complicated. We will help you with any technical issues and help improve your contribution so that it can be merged.","title":"Contributing"},{"location":"contributing/#basic-setup","text":"To contribute, make sure your set up: Your username + email Your ~/.gitconfig Your shell prompt to display the current branch name","title":"Basic Setup"},{"location":"contributing/#fork-lfortran","text":"Step 1. Create a fork of the project repository Step 2. Set up your SSH key with GitHub Step 3. Clone the project repository from GitHub and set up your remote repository git clone https://github.com/lfortran/lfortran.git cd lfortran git remote add REMOTE_NAME git@github.com:YOUR_GITHUB_ID/lfortran.git :fontawesome-solid-edit: REMOTE_NAME is the name of your remote repository and could be any name you like, for example your first name. :fontawesome-solid-edit: YOUR_GITHUB_ID is your user ID on GitHub and should be part of your account path. You can use git remote -v to check if the new remote is set up correctly.","title":"Fork LFortran"},{"location":"contributing/#send-a-new-merge-request","text":"Step 1. Create a new branch git checkout -b fix1 Step 2. Make changes in relevant file(s) Step 3. Commit the changes: git add FILE1 (FILE2 ...) git commit -m \"YOUR_COMMIT_MESSAGE\" Here are some great tips on writing good commit messages. Step 4. Check to ensure that your changes look good git log --pretty=oneline --graph --decorate --all Step 5. Send the merge request git push REMOTE_NAME fix1 The command will push the new branch fix1 into your remote repository REMOTE_NAME that you created earlier. Additionally, it will also display a link that you can click on to open the new merge request. After clicking on the link, write a title and a concise description then click the \"Create\" button. Yay you are now all set.","title":"Send a New Merge Request"},{"location":"contributing/#add-new-features","text":"The example below shows the steps it would take to create a caret binary operator ^ which computes the average value of the two operands.","title":"Add New Features"},{"location":"contributing/#create-new-tokens","text":"We extend the tokenizer.re as well as parser.yy to add the new token ^ . We also tell LFortran how to print the new token in parser.cpp . src/lfortran/parser/tokenizer.re // \"^\" { RET(TK_CARET) } src/lfortran/parser/parser.yy %token TK_CARET \"^\" src/lfortran/parser/parser.cpp std:string token2text(const int token) { switch (token) { T(TK_CARET, \"^\") } } The added code is tested with lfortran --show-tokens examples2/expr2.f90","title":"Create New Token(s)"},{"location":"contributing/#parse-the-new-token","text":"Now we have to parse the new operator. We add it to the AST by extending the BinOp with a caret operator and modifying the AST.asdl file. Then we add it in parse.yy to properly parse and generate the new AST in semantics.h .Finally we extend pickle.cpp so that the new operator can print itself. grammar/AST.asdl operator = Add | Sub | Mul | Div | Pow | Caret src/lfortran/parser/parser.yy %left \"^\" expr : id { $$=$1; } | expr \"^\" expr { $$ = CARET($1, $3, @$); } src/lfortran/parser/semantics.h #define CARET(x,y,l) make_BinOp_t(p.m_a, l, EXPR(x), operatorType::Caret, EXPR(y)) src/lfortran/pickle.cpp std::string op2str(const operatorType type) { switch (type) { case (operatorType::Caret) : return \"^\"; } // now the caret operator can print itself } The section is tested with lfortran --show-ast examples/expr2.f90","title":"Parse the New Token"},{"location":"contributing/#implement-the-semantics-of-the-new-token","text":"We first extend the ASR in ASR.asdl and add ^ as a BinOp operator option. src/libasr/ASR.asdl binop = Add | Sub | Mul | Div | Pow | Caret src/lfortran/semantics/ast_common_visitor.h namespace LFortran { class CommonVisitorMethods { public: inline static void visit_BinOp(Allocator &al, const AST::BinOp_t &x, ASR::expr_t *&left, ASR::expr_t *&right, ASR::asr_t *&asr) { ASR::binopType op; switch (x.m_op) { case (AST::Caret): op = ASR::Caret; break; } if (LFortran::ASRUtils::expr_value(left) != nullptr && LFortran::ASRUtils::expr_value(right) != nullptr) { if (ASR::is_a<LFortran::ASR::Integer_t>(*dest_type)) { int64_t left_value = ASR::down_cast<ASR::IntegerConstant_t>( LFortran::ASRUtils::expr_value(left)) ->m_n; int64_t right_value = ASR::down_cast<ASR::IntegerConstant_t>( LFortran::ASRUtils::expr_value(right)) ->m_n; int64_t result; switch (op) { case (ASR::Caret): result = (left_value + right_value)/2; break; } } } } } } Then we transform it from AST to ASR by extending src/lfortran/semantics/ast_common_visitor.h . We also add it into compile time evaluation triggered by expressions such as e = (2+3)^5 which is evaluated at compile time. An expression such as e = x^5 is evaluated at run time only. The section is tested with lfortran --show-asr examples/expr2.f90","title":"Implement the Semantics of the New Token"},{"location":"contributing/#implement-the-new-token-in-llvm","text":"To implement in LLVM, we extend the BinOp translation by handling the new operator. We first add the two numbers then divide by two. src/lfortran/codegen/asr_to_llvm.cpp void visit_BinOp(const ASR::BinOp_t &x) { if (x.m_value) { this->visit_expr_wrapper(x.m_value, true); return; } this->visit_expr_wrapper(x.m_left, true); llvm::Value *left_val = tmp; this->visit_expr_wrapper(x.m_right, true); llvm::Value *right_val = tmp; if (x.m_type->type == ASR::ttypeType::Integer || x.m_type->type == ASR::ttypeType::IntegerPointer) { switch (x.m_op) { case ASR::binopType::Caret: { tmp = builder->CreateAdd(left_val, right_val); llvm::Value *two = llvm::ConstantInt::get(context, llvm::APInt(32, 2, true)); tmp = builder->CreateUDiv(tmp, two); break; }; } } } The section is tested with lfortran --show-llvm examples/expr2.f90 Now when LLVM works, we can test the final executable by: lfortran examples/expr2.f90 ./a.out And it should print 6. It also works interactively: $ lfortran Interactive Fortran. Experimental prototype, not ready for end users. * Use Ctrl-D to exit * Use Enter to submit * Use Alt-Enter or Ctrl-N to make a new line - Editing (Keys: Left, Right, Home, End, Backspace, Delete) - History (Keys: Up, Down) >>> 4^8 1,4 ] 6 >>> integer :: x 1,13 ] >>> x = 4 1,6 ] >>> x^8 1,4 ] 6","title":"Implement the New Token in LLVM"},{"location":"contributing/#reach-out","text":"If you have any questions or need help, please ask as at our mailinglist or a chat . Please note that all participants of this project are expected to follow our Code of Conduct. By participating in this project you agree to abide by its terms. See CODE_OF_CONDUCT.md . By submitting a PR you agree to license your contribution under the LFortran's BSD license unless explicitly noted otherwise.","title":"Reach Out"},{"location":"design/","text":"LFortran Design High Level Overview LFortran is structured around two independent modules, AST and ASR, both of which are standalone (completely independent of the rest of LFortran) and users are encouraged to use them independently for other applications and build tools on top: Abstract Syntax Tree (AST), module lfortran.ast : Represents any Fortran source code, strictly based on syntax, no semantic is included. The AST module can convert itself to Fortran source code. Abstract Semantic Representation (ASR), module lfortran.asr : Represents a valid Fortran source code, all semantic is included. Invalid Fortran code is not allowed (an error will be given). The ASR module can convert itself to an AST. The LFortran compiler is then composed of the following independent stages: Parsing: converts Fortran source code to an AST Semantic: converts an AST to an ASR High level optimizations: optimize ASR to a possibly faster/simpler ASR (things like inlining functions, eliminating redundant expressions or statements, etc.) LLVM IR code generation and lower level optimizations: converts an ASR to an LLVM IR. This stage also does all other optimizations that do not produce an ASR, but still make sense to do before passing to LLVM IR. Machine code generation: LLVM then does all its optimizations and generates machine code (such as a binary executable, a library, an object file, or it is loaded and executed using JIT as part of the interactive LFortran session or in a Jupyter kernel). LFortran is structured as a library, and so one can for example use the parser to obtain an AST and do something with it, or one can then use the semantic analyzer to obtain ASR and do something with it. One can generate the ASR directly (e.g., from SymPy) and then either convert to AST and to a Fortran source code, or use LFortran to compile it to machine code directly. In other words, one can use LFortran to easily convert between the three equivalent representations: Fortran source code Abstract Syntax Tree (AST) Abstract Semantic Representation (ASR) They are all equivalent in the following sense: Any ASR can always be converted to an equivalent AST Any AST can always be converted to an equivalent Fortran source code Any Fortran source code can always be either converted to an equivalent AST or one gets a syntax error Any AST can always be either converted to an equivalent ASR or one gets a semantic error So when a conversion can be done, they are equivalent, and the conversion can always be done unless the code is invalid. ASR Design Details The ASR is designed to have the following features: ASR is still semantically equivalent to the original Fortran code (it did not lose any semantic information). ASR can be converted to AST, and AST to Fortran source code which is functionally equivalent to the original. ASR is as simple as possible: it does not contain any information that could not be inferred from ASR. The ASR C++ classes (down the road) are designed similarly to SymEngine: they are constructed once and after that they are immutable. The constructor checks in Debug more that all the requirements are met (e.g., that all Variables in a Function have a dummy argument set, that explicit-shape arrays are not allocatable and all other Fortran requirements to make it a valid code), but in Release mode it quickly constructs the class without checks. Then there are builder classes that construct the ASR C++ classes to meet requirements (checked in Debug mode) and the builder gives an error message if a code is not a valid Fortran code, and if it doesn't give an error message, then the ASR C++ classes are constructed correctly. Thus by construction, the ASR classes always contain valid Fortran code and the rest of LFortran can depend on it. Notes: Information that is lost when parsing source to AST: whitespace, multiline/single line if statement distinction, case sensitivity of keywords. Information that is lost when going from AST to ASR: detailed syntax how variables were defined and the order of type attributes (whether array dimension is using the dimension attribute, or parentheses at the variable; or how many variables there are per declaration line or their order), as ASR only represents the aggregated type information in the symbol table. ASR is the simplest way to generate Fortran code, as one does not have to worry about the detailed syntax (as in AST) about how and where things are declared. One specifies the symbol table for a module, then for each symbol (functions, global variables, types, ...) one specifies the local variables and if this is an interface then one needs to specify where one can find an implementation, otherwise a body is supplied with statements, those nodes are almost the same as in AST, except that each variable is just a reference to a symbol in the symbol table (so by construction one cannot have undefined variables). The symbol table for each node such as Function or Module also references its parent (for example a function references a module, a module references the global scope). The ASR can be directly converted to an AST without gathering any other information. And the AST directly to Fortran source code. The ASR is always representing a semantically valid Fortran code. This is enforced by checks in the ASR C++ constructors (in Debug build). When an ASR is used, one can assume it is valid. Fortran 2008 Fortran 2008 standard chapter 2 \"Fortran concepts\" specifies that Fortran code is a collection of program units (either all in one file, or in separate files), where each program unit is one of: main program module or submodule function or subroutine Note: It can also be a block data program unit, that is used to provide initial values for data objects in named common blocks , but we do not recommend the use of common blocks (use modules instead). LFortran Extension We extend the Fortran language by introducing a global scope , which is not only the list of program units (as in F2008) but can also include statements, declarations, use statements and expressions. We define global scope as a collection of the following items: main program module or submodule function or subroutine use statement declaration statement expression In addition, if a variable is not defined in an assignment statement (such as x = 5+3 ) then the type of the variable is inferred from the right hand side (e.g., x in x = 5+3 would be of type integer , and y in y = 5._dp would be of type real(dp) ). This rule only applies at the top level of global scope . Types must be fully specified inside main programs, modules, functions and subroutines, just like in F2008. The global scope has its own symbol table. The main program and module/submodule do not see any symbols from this symbol table. But functions, subroutines, statements and expressions at the top level of global scope use and operate on this symbol table. The global scope has the following symbols predefined in the symbol table: the usual standard set of Fortran functions (such as size , sin , cos , ...) the dp double precision symbol, so that one can use 5._dp for double precision. Each item in the global scope is interpreted as follows: main program is compiled into an executable with the same name and executed; modules, functions and subroutines are compiled and loaded; use statement and declaration adds those symbols with the proper type into the global scope symbol table, but do not generate any code; statement is wrapped into an anonymous subroutine with no arguments, compiled, loaded and executed; expression is wrapped into an anonymous function with no arguments returning the expression, compiled, loaded, executed and the return value is returned to the user. The global scope is always interpreted, item by item, per the previous paragraph. It is meant to allow interactive usage, experimentations and writing simple scripts. Code in global scope must be interpreted using lfortran . For more complex (production) code it is recommended to turn it into modules and programs (by wrapping loose statements into subroutines or functions and by adding type declarations) and compile it with lfortran or any other Fortran compiler. Here are some examples of valid code in global scope : Example 1 a = 5 print * , a Example 2 a = 5 subroutine p () print * , a end subroutine call p () Example 3 module a implicit none integer :: i end module use a , only : i i = 5 Example 4 x = [ 1 , 2 , 3 ] y = [ 1 , 2 , 1 ] call plot ( x , y , \"o-\" ) Design Considerations The LFortran extension of Fortran was chosen in a way so as to minimize the number of changes. In particular, only the top level of the global scope has relaxed some of the Fortran rules (such as making specifying types optional) so as to allow simple and quick interactive usage, but inside functions, subroutines, modules or programs this relaxation does not apply. The number of changes were kept to minimum in order to make it straightforward to turn code at global scope into standard compliant Fortran code using programs and modules, so that it can be compiled by any Fortran compiler.","title":"LFortran Design"},{"location":"design/#lfortran-design","text":"","title":"LFortran Design"},{"location":"design/#high-level-overview","text":"LFortran is structured around two independent modules, AST and ASR, both of which are standalone (completely independent of the rest of LFortran) and users are encouraged to use them independently for other applications and build tools on top: Abstract Syntax Tree (AST), module lfortran.ast : Represents any Fortran source code, strictly based on syntax, no semantic is included. The AST module can convert itself to Fortran source code. Abstract Semantic Representation (ASR), module lfortran.asr : Represents a valid Fortran source code, all semantic is included. Invalid Fortran code is not allowed (an error will be given). The ASR module can convert itself to an AST. The LFortran compiler is then composed of the following independent stages: Parsing: converts Fortran source code to an AST Semantic: converts an AST to an ASR High level optimizations: optimize ASR to a possibly faster/simpler ASR (things like inlining functions, eliminating redundant expressions or statements, etc.) LLVM IR code generation and lower level optimizations: converts an ASR to an LLVM IR. This stage also does all other optimizations that do not produce an ASR, but still make sense to do before passing to LLVM IR. Machine code generation: LLVM then does all its optimizations and generates machine code (such as a binary executable, a library, an object file, or it is loaded and executed using JIT as part of the interactive LFortran session or in a Jupyter kernel). LFortran is structured as a library, and so one can for example use the parser to obtain an AST and do something with it, or one can then use the semantic analyzer to obtain ASR and do something with it. One can generate the ASR directly (e.g., from SymPy) and then either convert to AST and to a Fortran source code, or use LFortran to compile it to machine code directly. In other words, one can use LFortran to easily convert between the three equivalent representations: Fortran source code Abstract Syntax Tree (AST) Abstract Semantic Representation (ASR) They are all equivalent in the following sense: Any ASR can always be converted to an equivalent AST Any AST can always be converted to an equivalent Fortran source code Any Fortran source code can always be either converted to an equivalent AST or one gets a syntax error Any AST can always be either converted to an equivalent ASR or one gets a semantic error So when a conversion can be done, they are equivalent, and the conversion can always be done unless the code is invalid.","title":"High Level Overview"},{"location":"design/#asr-design-details","text":"The ASR is designed to have the following features: ASR is still semantically equivalent to the original Fortran code (it did not lose any semantic information). ASR can be converted to AST, and AST to Fortran source code which is functionally equivalent to the original. ASR is as simple as possible: it does not contain any information that could not be inferred from ASR. The ASR C++ classes (down the road) are designed similarly to SymEngine: they are constructed once and after that they are immutable. The constructor checks in Debug more that all the requirements are met (e.g., that all Variables in a Function have a dummy argument set, that explicit-shape arrays are not allocatable and all other Fortran requirements to make it a valid code), but in Release mode it quickly constructs the class without checks. Then there are builder classes that construct the ASR C++ classes to meet requirements (checked in Debug mode) and the builder gives an error message if a code is not a valid Fortran code, and if it doesn't give an error message, then the ASR C++ classes are constructed correctly. Thus by construction, the ASR classes always contain valid Fortran code and the rest of LFortran can depend on it.","title":"ASR Design Details"},{"location":"design/#notes","text":"Information that is lost when parsing source to AST: whitespace, multiline/single line if statement distinction, case sensitivity of keywords. Information that is lost when going from AST to ASR: detailed syntax how variables were defined and the order of type attributes (whether array dimension is using the dimension attribute, or parentheses at the variable; or how many variables there are per declaration line or their order), as ASR only represents the aggregated type information in the symbol table. ASR is the simplest way to generate Fortran code, as one does not have to worry about the detailed syntax (as in AST) about how and where things are declared. One specifies the symbol table for a module, then for each symbol (functions, global variables, types, ...) one specifies the local variables and if this is an interface then one needs to specify where one can find an implementation, otherwise a body is supplied with statements, those nodes are almost the same as in AST, except that each variable is just a reference to a symbol in the symbol table (so by construction one cannot have undefined variables). The symbol table for each node such as Function or Module also references its parent (for example a function references a module, a module references the global scope). The ASR can be directly converted to an AST without gathering any other information. And the AST directly to Fortran source code. The ASR is always representing a semantically valid Fortran code. This is enforced by checks in the ASR C++ constructors (in Debug build). When an ASR is used, one can assume it is valid.","title":"Notes:"},{"location":"design/#fortran-2008","text":"Fortran 2008 standard chapter 2 \"Fortran concepts\" specifies that Fortran code is a collection of program units (either all in one file, or in separate files), where each program unit is one of: main program module or submodule function or subroutine Note: It can also be a block data program unit, that is used to provide initial values for data objects in named common blocks , but we do not recommend the use of common blocks (use modules instead).","title":"Fortran 2008"},{"location":"design/#lfortran-extension","text":"We extend the Fortran language by introducing a global scope , which is not only the list of program units (as in F2008) but can also include statements, declarations, use statements and expressions. We define global scope as a collection of the following items: main program module or submodule function or subroutine use statement declaration statement expression In addition, if a variable is not defined in an assignment statement (such as x = 5+3 ) then the type of the variable is inferred from the right hand side (e.g., x in x = 5+3 would be of type integer , and y in y = 5._dp would be of type real(dp) ). This rule only applies at the top level of global scope . Types must be fully specified inside main programs, modules, functions and subroutines, just like in F2008. The global scope has its own symbol table. The main program and module/submodule do not see any symbols from this symbol table. But functions, subroutines, statements and expressions at the top level of global scope use and operate on this symbol table. The global scope has the following symbols predefined in the symbol table: the usual standard set of Fortran functions (such as size , sin , cos , ...) the dp double precision symbol, so that one can use 5._dp for double precision. Each item in the global scope is interpreted as follows: main program is compiled into an executable with the same name and executed; modules, functions and subroutines are compiled and loaded; use statement and declaration adds those symbols with the proper type into the global scope symbol table, but do not generate any code; statement is wrapped into an anonymous subroutine with no arguments, compiled, loaded and executed; expression is wrapped into an anonymous function with no arguments returning the expression, compiled, loaded, executed and the return value is returned to the user. The global scope is always interpreted, item by item, per the previous paragraph. It is meant to allow interactive usage, experimentations and writing simple scripts. Code in global scope must be interpreted using lfortran . For more complex (production) code it is recommended to turn it into modules and programs (by wrapping loose statements into subroutines or functions and by adding type declarations) and compile it with lfortran or any other Fortran compiler. Here are some examples of valid code in global scope :","title":"LFortran Extension"},{"location":"design/#example-1","text":"a = 5 print * , a","title":"Example 1"},{"location":"design/#example-2","text":"a = 5 subroutine p () print * , a end subroutine call p ()","title":"Example 2"},{"location":"design/#example-3","text":"module a implicit none integer :: i end module use a , only : i i = 5","title":"Example 3"},{"location":"design/#example-4","text":"x = [ 1 , 2 , 3 ] y = [ 1 , 2 , 1 ] call plot ( x , y , \"o-\" )","title":"Example 4"},{"location":"design/#design-considerations","text":"The LFortran extension of Fortran was chosen in a way so as to minimize the number of changes. In particular, only the top level of the global scope has relaxed some of the Fortran rules (such as making specifying types optional) so as to allow simple and quick interactive usage, but inside functions, subroutines, modules or programs this relaxation does not apply. The number of changes were kept to minimum in order to make it straightforward to turn code at global scope into standard compliant Fortran code using programs and modules, so that it can be compiled by any Fortran compiler.","title":"Design Considerations"},{"location":"developer_tutorial/","text":"Developer Tutorial This is a tutorial for anybody who wants to either develop LFortran or build tools on top. Introduction LFortran is structured around two independent modules, AST and ASR, both of which are standalone (completely independent of the rest of LFortran) and users are encouraged to use them independently for other applications and build tools on top: Abstract Syntax Tree (AST): Represents any Fortran source code, strictly based on syntax, no semantic is included. The AST module can convert itself to Fortran source code. Abstract Semantic Representation (ASR): Represents a valid Fortran source code, all semantic is included. Invalid Fortran code is not allowed (an error will be given). The ASR module can convert itself to an AST. Abstract Syntax Tree (AST) Fortran source code can be parsed into an AST using the src_to_ast() function: integer function f ( a , b ) result ( r ) integer , intent ( in ) :: a , b r = a + b end function We can pretty print it using the %%showast magic: %% showast integer function f ( a , b ) result ( r ) integer , intent ( in ) :: a , b r = a + b end function ( TranslationUnit [( Function f [(a) (b)] [( AttrType TypeInteger [] () None )] r () () [] [] [] [( Declaration ( AttrType TypeInteger [] () None ) [( AttrIntent In )] [(a [] [] () None ()) (b [] [] () None ())] ())] [( = 0 r (+ a b ) ())] [])]) We can convert AST to Fortran source code using %%showfmt : %% showfmt integer function f ( a , b ) result ( r ) integer , intent ( in ) :: a , b r = a + b end function integer function f(a, b) result (r) integer , intent ( in ) :: a, b r = a + b end function f All AST nodes and their arguments are described in AST.asdl . Abstract Semantic Representation (ASR) We can pretty print using the %%showasr magic: %% showasr integer function f ( a , b ) result ( r ) integer , intent ( in ) :: a , b r = a + b end function ( TranslationUnit ( SymbolTable 1 {f: ( Function ( SymbolTable 3 {a: ( Variable 3 a In () () Default ( Integer 4 []) Source Public Required .false.), b: ( Variable 3 b In () () Default ( Integer 4 []) Source Public Required .false.), r: ( Variable 3 r ReturnVar () () Default ( Integer 4 []) Source Public Required .false.)}) f [( Var 3 a ) ( Var 3 b )] [] [( = ( Var 3 r ) ( IntegerBinOp ( Var 3 a ) Add ( Var 3 b ) ( Integer 4 []) ()) ())] ( Var 3 r ) Source Public Implementation () .false. .false. .false.)}) []) All ASR nodes and their arguments are described in ASR.asdl .","title":"Developer Tutorial"},{"location":"developer_tutorial/#developer-tutorial","text":"This is a tutorial for anybody who wants to either develop LFortran or build tools on top.","title":"Developer Tutorial"},{"location":"developer_tutorial/#introduction","text":"LFortran is structured around two independent modules, AST and ASR, both of which are standalone (completely independent of the rest of LFortran) and users are encouraged to use them independently for other applications and build tools on top: Abstract Syntax Tree (AST): Represents any Fortran source code, strictly based on syntax, no semantic is included. The AST module can convert itself to Fortran source code. Abstract Semantic Representation (ASR): Represents a valid Fortran source code, all semantic is included. Invalid Fortran code is not allowed (an error will be given). The ASR module can convert itself to an AST.","title":"Introduction"},{"location":"developer_tutorial/#abstract-syntax-tree-ast","text":"Fortran source code can be parsed into an AST using the src_to_ast() function: integer function f ( a , b ) result ( r ) integer , intent ( in ) :: a , b r = a + b end function We can pretty print it using the %%showast magic: %% showast integer function f ( a , b ) result ( r ) integer , intent ( in ) :: a , b r = a + b end function ( TranslationUnit [( Function f [(a) (b)] [( AttrType TypeInteger [] () None )] r () () [] [] [] [( Declaration ( AttrType TypeInteger [] () None ) [( AttrIntent In )] [(a [] [] () None ()) (b [] [] () None ())] ())] [( = 0 r (+ a b ) ())] [])]) We can convert AST to Fortran source code using %%showfmt : %% showfmt integer function f ( a , b ) result ( r ) integer , intent ( in ) :: a , b r = a + b end function integer function f(a, b) result (r) integer , intent ( in ) :: a, b r = a + b end function f All AST nodes and their arguments are described in AST.asdl .","title":"Abstract Syntax Tree (AST)"},{"location":"developer_tutorial/#abstract-semantic-representation-asr","text":"We can pretty print using the %%showasr magic: %% showasr integer function f ( a , b ) result ( r ) integer , intent ( in ) :: a , b r = a + b end function ( TranslationUnit ( SymbolTable 1 {f: ( Function ( SymbolTable 3 {a: ( Variable 3 a In () () Default ( Integer 4 []) Source Public Required .false.), b: ( Variable 3 b In () () Default ( Integer 4 []) Source Public Required .false.), r: ( Variable 3 r ReturnVar () () Default ( Integer 4 []) Source Public Required .false.)}) f [( Var 3 a ) ( Var 3 b )] [] [( = ( Var 3 r ) ( IntegerBinOp ( Var 3 a ) Add ( Var 3 b ) ( Integer 4 []) ()) ())] ( Var 3 r ) Source Public Implementation () .false. .false. .false.)}) []) All ASR nodes and their arguments are described in ASR.asdl .","title":"Abstract Semantic Representation (ASR)"},{"location":"installation/","text":"Installation All the instructions below work on Linux, macOS and Windows. Binaries The recommended way to install LFortran is using Conda. Install Conda for example by installing the Miniconda installation by following instructions there for your platform. Then create a new environment (you can choose any name, here we chose lf ) and activate it: conda create -n lf conda activate lf Then install LFortran by: conda install lfortran -c conda-forge Now the lf environment has the lfortran compiler available, you can start the interactive prompt by executing lfortran , or see the command line options using lfortran -h . The Jupyter kernel is automatically installed by the above command, so after installing Jupyter itself: conda install jupyter -c conda-forge You can create a Fortran based Jupyter notebook by executing: jupyter notebook and selecting New->Fortran . Build From a Source Tarball This method is the recommended method if you just want to install LFortran, either yourself or in a package manager (Spack, Conda, Debian, etc.). The source tarball has all the generated files included and has minimal dependencies. First we have to install dependencies, for example using Conda: conda create -n lf python cmake llvmdev conda activate lf Then download a tarball from https://lfortran.org/download/ , e.g.: wget https://lfortran.github.io/tarballs/dev/lfortran-0.9.0.tar.gz tar xzf lfortran-0.9.0.tar.gz cd lfortran-0.9.0 And build: cmake -DWITH_LLVM=yes -DCMAKE_INSTALL_PREFIX=`pwd`/inst . make -j8 make install This will install the lfortran into the inst/bin . Build From Git We assume you have C++ compilers installed, as well as git and wget . In Ubuntu, you can also install binutils-dev for stacktraces. If you do not have Conda installed, you can do so on Linux (and similarly on other platforms): wget --no-check-certificate https://repo.continuum.io/miniconda/Miniconda3-latest-Linux-x86_64.sh -O miniconda.sh bash miniconda.sh -b -p $HOME /conda_root export PATH = \" $HOME /conda_root/bin: $PATH \" Then prepare the environment: conda create -n lf -c conda-forge llvmdev = 11 .0.1 bison = 3 .4 re2c python cmake make toml conda activate lf Clone the LFortran git repository: git clone https://github.com/lfortran/lfortran.git cd lfortran Generate files that are needed for the build (this step depends on re2c , bison and python ): ./build0.sh Now the process is the same as installing from the source tarball. For example to build in Debug mode: cmake -DCMAKE_BUILD_TYPE=Debug -DWITH_LLVM=yes -DCMAKE_INSTALL_PREFIX=`pwd`/inst . make -j8 Run tests: ctest ./run_tests.py Run an interactive prompt: ./src/bin/lfortran Build on Windows with Visual Studio Install Conda for example by installing the Miniconda installation by following instructions there for your platform. If not already done, activate the Conda-Installation (cf. Conda installation instructions). First, clone the repo to a local folder. Launch a Conda command interpreter and run the following commands: conda update -q conda conda install -c conda-forge python = 3 .7 re2c m2-bison xonsh llvmdev = 11 .1.0 jupyter xeus = 1 .0.1 xtl nlohmann_json cppzmq jupyter_kernel_test pytest Next, cd to the root of the repository and run . \\b uild0.bat Now, you can launch Visual Studio and open the LFortran folder. Before the first build you have to set up the ZLib -pathes: Go to the CMake-Settings (Project -> CMake Setttings for lfortran) and check Show advanced variables . Scroll to the ZLIB_... variables and set: - ZLIB_INCLUDE_DIR = \\<Conda-Installation-Path>\\Library\\include - ZLIB_LIBRARY_[DEBUG|RELEASE] = \\<Conda-Installation-Path>\\Library\\lib\\zlibstatic.lib Then you can generate the CMake-Cache and build the project. Enabling the Jupyter Kernel To install the Jupyter kernel, install the following Conda packages also: conda install xeus xtl nlohmann_json cppzmq and enable the kernel by -DWITH_XEUS=yes and install into $CONDA_PREFIX . For example: cmake \\ -DCMAKE_BUILD_TYPE=Debug \\ -DWITH_LLVM=yes \\ -DWITH_XEUS=yes \\ -DCMAKE_PREFIX_PATH=\"$CONDA_PREFIX\" \\ -DCMAKE_INSTALL_PREFIX=\"$CONDA_PREFIX\" \\ . cmake --build . -j4 --target install To use it, install Jupyter ( conda install jupyter ) and test that the LFortran kernel was found: jupyter kernelspec list --json Then launch a Jupyter notebook as follows: jupyter notebook Click New->Fortran . To launch a terminal jupyter LFortran console: jupyter console --kernel=fortran Build From Git with Nix One of the ways to ensure exact environment and dependencies is with nix . This will ensure that system dependencies do not interfere with the development environment. If you want, you can report bugs in a nix-shell environment to make it easier for others to reproduce. With Root We start by getting nix . The following multi-user installation will work on any machine with a Linux distribution, MacOS or Windows (via WSL): sh < ( curl -L https://nixos.org/nix/install ) --daemon Without Root If you would like to not provide nix with root access to your machine, on Linux distributions we can use nix-portable . wget https://github.com/DavHau/nix-portable/releases/download/v003/nix-portable Now just prepend all nix-shell commands with NP_RUNTIME=bwrap ./nix-portable . So: # Do not nix-shell --run \"bash\" # Do NP_RUNTIME = bwrap ./nix-portable nix-shell --run \"bash\" Development Now we can enter the development environment: nix-shell --run \"bash\" --cores 4 -j4 --pure ci/shell.nix The --pure flag ensures no system dependencies are used in the environment. The build steps are the same as with the ci : ./build0.sh ./build1.sh To change the compilation environment from gcc (default) to clang we can use --argstr : nix-shell --run \"bash\" --cores 4 -j4 --pure ci/shell.nix --argstr clangOnly \"yes\" Note About Dependencies End users (and distributions) are encouraged to use the tarball from https://lfortran.org/download/ , which only depends on LLVM, CMake and a C++ compiler. The tarball is generated automatically by our CI (continuous integration) and contains some autogenerated files: the parser, the AST and ASR nodes, which is generated by an ASDL translator (requires Python). The instructions from git are to be used when developing LFortran itself. Note for users who do not use Conda Following are the dependencies necessary for installing this repository in development mode, Bison - 3.5.1 LLVM - 11.0.1 re2c - 2.0.3 binutils - 2.31.90 - Make sure that you should enable the required options related to this dependency to build the dynamic libraries (the ones ending with .so ). Stacktraces LFortran can print stacktraces when there is an unhandled exception, as well as on any compiler error with the --show-stacktrace option. This is very helpful for developing the compiler itself to see where in LFortran the problem is. The stacktrace support is turned off by default, to enable it, compile LFortran with the -DWITH_STACKTRACE=yes cmake option after installing the prerequisites on each platform per the instructions below. Ubuntu In Ubuntu, apt install binutils-dev . macOS If you use the default Clang compiler on macOS, then the stacktraces should just work on both Intel and M1 based macOS (the CMake build system automatically invokes the dsymtuil tool and our Python scripts to store the debug information, see src/bin/CMakeLists.txt for more details). If it does not work, please report a bug. If you do not like the default way, an alternative is to use bintutils. For that, first install Spack , then: spack install binutils spack find -p binutils The last command will show a full path to the installed binutils package. Add this path to your shell config file, e.g.: export CMAKE_PREFIX_PATH_LFORTRAN=/Users/ondrej/repos/spack/opt/spack/darwin-catalina-broadwell/apple-clang-11.0.0/binutils-2.36.1-wy6osfm6bp2323g3jpv2sjuttthwx3gd and compile LFortran with the -DCMAKE_PREFIX_PATH=\"$CMAKE_PREFIX_PATH_LFORTRAN;$CONDA_PREFIX\" cmake option. The $CONDA_PREFIX is there if you install some other dependencies (such as llvm ) using Conda, otherwise you can remove it.","title":"Installation"},{"location":"installation/#installation","text":"All the instructions below work on Linux, macOS and Windows.","title":"Installation"},{"location":"installation/#binaries","text":"The recommended way to install LFortran is using Conda. Install Conda for example by installing the Miniconda installation by following instructions there for your platform. Then create a new environment (you can choose any name, here we chose lf ) and activate it: conda create -n lf conda activate lf Then install LFortran by: conda install lfortran -c conda-forge Now the lf environment has the lfortran compiler available, you can start the interactive prompt by executing lfortran , or see the command line options using lfortran -h . The Jupyter kernel is automatically installed by the above command, so after installing Jupyter itself: conda install jupyter -c conda-forge You can create a Fortran based Jupyter notebook by executing: jupyter notebook and selecting New->Fortran .","title":"Binaries"},{"location":"installation/#build-from-a-source-tarball","text":"This method is the recommended method if you just want to install LFortran, either yourself or in a package manager (Spack, Conda, Debian, etc.). The source tarball has all the generated files included and has minimal dependencies. First we have to install dependencies, for example using Conda: conda create -n lf python cmake llvmdev conda activate lf Then download a tarball from https://lfortran.org/download/ , e.g.: wget https://lfortran.github.io/tarballs/dev/lfortran-0.9.0.tar.gz tar xzf lfortran-0.9.0.tar.gz cd lfortran-0.9.0 And build: cmake -DWITH_LLVM=yes -DCMAKE_INSTALL_PREFIX=`pwd`/inst . make -j8 make install This will install the lfortran into the inst/bin .","title":"Build From a Source Tarball"},{"location":"installation/#build-from-git","text":"We assume you have C++ compilers installed, as well as git and wget . In Ubuntu, you can also install binutils-dev for stacktraces. If you do not have Conda installed, you can do so on Linux (and similarly on other platforms): wget --no-check-certificate https://repo.continuum.io/miniconda/Miniconda3-latest-Linux-x86_64.sh -O miniconda.sh bash miniconda.sh -b -p $HOME /conda_root export PATH = \" $HOME /conda_root/bin: $PATH \" Then prepare the environment: conda create -n lf -c conda-forge llvmdev = 11 .0.1 bison = 3 .4 re2c python cmake make toml conda activate lf Clone the LFortran git repository: git clone https://github.com/lfortran/lfortran.git cd lfortran Generate files that are needed for the build (this step depends on re2c , bison and python ): ./build0.sh Now the process is the same as installing from the source tarball. For example to build in Debug mode: cmake -DCMAKE_BUILD_TYPE=Debug -DWITH_LLVM=yes -DCMAKE_INSTALL_PREFIX=`pwd`/inst . make -j8 Run tests: ctest ./run_tests.py Run an interactive prompt: ./src/bin/lfortran","title":"Build From Git"},{"location":"installation/#build-on-windows-with-visual-studio","text":"Install Conda for example by installing the Miniconda installation by following instructions there for your platform. If not already done, activate the Conda-Installation (cf. Conda installation instructions). First, clone the repo to a local folder. Launch a Conda command interpreter and run the following commands: conda update -q conda conda install -c conda-forge python = 3 .7 re2c m2-bison xonsh llvmdev = 11 .1.0 jupyter xeus = 1 .0.1 xtl nlohmann_json cppzmq jupyter_kernel_test pytest Next, cd to the root of the repository and run . \\b uild0.bat Now, you can launch Visual Studio and open the LFortran folder. Before the first build you have to set up the ZLib -pathes: Go to the CMake-Settings (Project -> CMake Setttings for lfortran) and check Show advanced variables . Scroll to the ZLIB_... variables and set: - ZLIB_INCLUDE_DIR = \\<Conda-Installation-Path>\\Library\\include - ZLIB_LIBRARY_[DEBUG|RELEASE] = \\<Conda-Installation-Path>\\Library\\lib\\zlibstatic.lib Then you can generate the CMake-Cache and build the project.","title":"Build on Windows with Visual Studio"},{"location":"installation/#enabling-the-jupyter-kernel","text":"To install the Jupyter kernel, install the following Conda packages also: conda install xeus xtl nlohmann_json cppzmq and enable the kernel by -DWITH_XEUS=yes and install into $CONDA_PREFIX . For example: cmake \\ -DCMAKE_BUILD_TYPE=Debug \\ -DWITH_LLVM=yes \\ -DWITH_XEUS=yes \\ -DCMAKE_PREFIX_PATH=\"$CONDA_PREFIX\" \\ -DCMAKE_INSTALL_PREFIX=\"$CONDA_PREFIX\" \\ . cmake --build . -j4 --target install To use it, install Jupyter ( conda install jupyter ) and test that the LFortran kernel was found: jupyter kernelspec list --json Then launch a Jupyter notebook as follows: jupyter notebook Click New->Fortran . To launch a terminal jupyter LFortran console: jupyter console --kernel=fortran","title":"Enabling the Jupyter Kernel"},{"location":"installation/#build-from-git-with-nix","text":"One of the ways to ensure exact environment and dependencies is with nix . This will ensure that system dependencies do not interfere with the development environment. If you want, you can report bugs in a nix-shell environment to make it easier for others to reproduce.","title":"Build From Git with Nix"},{"location":"installation/#with-root","text":"We start by getting nix . The following multi-user installation will work on any machine with a Linux distribution, MacOS or Windows (via WSL): sh < ( curl -L https://nixos.org/nix/install ) --daemon","title":"With Root"},{"location":"installation/#without-root","text":"If you would like to not provide nix with root access to your machine, on Linux distributions we can use nix-portable . wget https://github.com/DavHau/nix-portable/releases/download/v003/nix-portable Now just prepend all nix-shell commands with NP_RUNTIME=bwrap ./nix-portable . So: # Do not nix-shell --run \"bash\" # Do NP_RUNTIME = bwrap ./nix-portable nix-shell --run \"bash\"","title":"Without Root"},{"location":"installation/#development","text":"Now we can enter the development environment: nix-shell --run \"bash\" --cores 4 -j4 --pure ci/shell.nix The --pure flag ensures no system dependencies are used in the environment. The build steps are the same as with the ci : ./build0.sh ./build1.sh To change the compilation environment from gcc (default) to clang we can use --argstr : nix-shell --run \"bash\" --cores 4 -j4 --pure ci/shell.nix --argstr clangOnly \"yes\"","title":"Development"},{"location":"installation/#note-about-dependencies","text":"End users (and distributions) are encouraged to use the tarball from https://lfortran.org/download/ , which only depends on LLVM, CMake and a C++ compiler. The tarball is generated automatically by our CI (continuous integration) and contains some autogenerated files: the parser, the AST and ASR nodes, which is generated by an ASDL translator (requires Python). The instructions from git are to be used when developing LFortran itself.","title":"Note About Dependencies"},{"location":"installation/#note-for-users-who-do-not-use-conda","text":"Following are the dependencies necessary for installing this repository in development mode, Bison - 3.5.1 LLVM - 11.0.1 re2c - 2.0.3 binutils - 2.31.90 - Make sure that you should enable the required options related to this dependency to build the dynamic libraries (the ones ending with .so ).","title":"Note for users who do not use Conda"},{"location":"installation/#stacktraces","text":"LFortran can print stacktraces when there is an unhandled exception, as well as on any compiler error with the --show-stacktrace option. This is very helpful for developing the compiler itself to see where in LFortran the problem is. The stacktrace support is turned off by default, to enable it, compile LFortran with the -DWITH_STACKTRACE=yes cmake option after installing the prerequisites on each platform per the instructions below.","title":"Stacktraces"},{"location":"installation/#ubuntu","text":"In Ubuntu, apt install binutils-dev .","title":"Ubuntu"},{"location":"installation/#macos","text":"If you use the default Clang compiler on macOS, then the stacktraces should just work on both Intel and M1 based macOS (the CMake build system automatically invokes the dsymtuil tool and our Python scripts to store the debug information, see src/bin/CMakeLists.txt for more details). If it does not work, please report a bug. If you do not like the default way, an alternative is to use bintutils. For that, first install Spack , then: spack install binutils spack find -p binutils The last command will show a full path to the installed binutils package. Add this path to your shell config file, e.g.: export CMAKE_PREFIX_PATH_LFORTRAN=/Users/ondrej/repos/spack/opt/spack/darwin-catalina-broadwell/apple-clang-11.0.0/binutils-2.36.1-wy6osfm6bp2323g3jpv2sjuttthwx3gd and compile LFortran with the -DCMAKE_PREFIX_PATH=\"$CMAKE_PREFIX_PATH_LFORTRAN;$CONDA_PREFIX\" cmake option. The $CONDA_PREFIX is there if you install some other dependencies (such as llvm ) using Conda, otherwise you can remove it.","title":"macOS"},{"location":"language/","text":"Fortran Language Background and Motivation Fortran was designed from the ground up to naturally and simply translate mathematics to code that compiles and runs at maximum speed. And being specifically targeted for such fundamentally computational tasks, it contains a broad range of key functionality within the language itself, standard across all platforms, with no need for external libraries that may or may not be well optimized or maintained, at present or down the road. Some highlights: Multidimensional arrays which can be allocated and indexed as the math/science dictates (not restricted to start at 0 or 1) and can be sliced as desired (as, e.g., in MATLAB); Operators which operate naturally upon the aforementioned arrays/matrices, as they do scalars; Complex numbers; Special functions; Structures and pointers for more general data representation. Because the essentials are contained in the language itself, it is simple to read and write, without need of choosing from among or deciphering a proliferation of external classes to do the same thing. And because the essentials are self-contained, compilers can provide detailed compile-time (e.g., argument mismatch) and run-time (e.g., memory access) checks, as well as highly optimized executables, directly from natural, readable code without need of extensive optimization heroics by the developer. See our blog posts for more information: Why We Created LFortran Why to Use Fortran For New Projects How to Learn Fortran Fortran is relatively quick to learn because it is so much simpler and smaller than C/C++ (in practice, that is, with all needed libraries included). If you are interested in learning more, please see our webpage at fortran90.org with recommended practices for writing code, side by side comparison with Python/NumPy, links to other online Fortran resources and books, and an FAQ.","title":"Fortran Language"},{"location":"language/#fortran-language","text":"","title":"Fortran Language"},{"location":"language/#background-and-motivation","text":"Fortran was designed from the ground up to naturally and simply translate mathematics to code that compiles and runs at maximum speed. And being specifically targeted for such fundamentally computational tasks, it contains a broad range of key functionality within the language itself, standard across all platforms, with no need for external libraries that may or may not be well optimized or maintained, at present or down the road. Some highlights: Multidimensional arrays which can be allocated and indexed as the math/science dictates (not restricted to start at 0 or 1) and can be sliced as desired (as, e.g., in MATLAB); Operators which operate naturally upon the aforementioned arrays/matrices, as they do scalars; Complex numbers; Special functions; Structures and pointers for more general data representation. Because the essentials are contained in the language itself, it is simple to read and write, without need of choosing from among or deciphering a proliferation of external classes to do the same thing. And because the essentials are self-contained, compilers can provide detailed compile-time (e.g., argument mismatch) and run-time (e.g., memory access) checks, as well as highly optimized executables, directly from natural, readable code without need of extensive optimization heroics by the developer. See our blog posts for more information: Why We Created LFortran Why to Use Fortran For New Projects","title":"Background and Motivation"},{"location":"language/#how-to-learn-fortran","text":"Fortran is relatively quick to learn because it is so much simpler and smaller than C/C++ (in practice, that is, with all needed libraries included). If you are interested in learning more, please see our webpage at fortran90.org with recommended practices for writing code, side by side comparison with Python/NumPy, links to other online Fortran resources and books, and an FAQ.","title":"How to Learn Fortran"},{"location":"progress/","text":"LFortran Development Status This page documents what Fortran features are supported by LFortran. For each feature we list a short description, the filename with the test and current status for each parts of the compiler: AST: The code can be parsed to AST ( lfortran --show-ast test.f90 ) ASR: The code can be transformed to ASR ( lfortran --show-asr test.f90 ) LLVM: LFortran can generate LLVM IR ( lfortran --show-llvm test.f90 ) BIN: The LLVM IR can compile to a binary RUN: The binary runs without errors If all are green it means the feature fully works and you can use it in your codes. Otherwise you can see what the status is of each feature. This page is generated automatically using the Compiler Tester repository which contains all the Fortran tests and scripts to run LFortran to produce the tables below. We are looking for contributors to contribute more tests. Our goal is to have a comprehensive Fortran testsuite that can be used to test any Fortran compiler. Testing the LFortran compiler version: $ lfortran --version LFortran version: 0.12.0-491-gaf48ff273 Platform: macOS Default target: x86_64-apple-darwin20.3.0 Topics Full programs that compute something interesting Basic Numerics Directory: tests/programs/numerics Description AST ASR LLVM BIN RUN Filename Pure Fortran sin(x) implementation \u2705 \u2705 \u2705 \u2705 \u2705 t01_sin_implementation.f90 Modules Basic Usage Directory: tests/modules/basic Description AST ASR LLVM BIN RUN Filename Basic modules \u2705 \u2705 \u2705 \u2705 \u2705 t01.f90 Module Functions and Subroutines Directory: tests/modules/procedures Description AST ASR LLVM BIN RUN Filename Module functions \u2705 \u2705 \u2705 \u2705 \u2705 t01.f90 Module subroutines \u2705 \u2705 \u2705 \u2705 \u2705 t02.f90 Nested subroutines \u2705 \u2705 \u2705 \u2705 \u2705 t03.f90 Expressions Arithmetic Operations Directory: tests/expressions/arit Description AST ASR LLVM BIN RUN Filename +,-,*,/,** \u2705 \u2705 \u2705 \u2705 \u2705 basic_operations.f90 Integers Directory: tests/expressions/integers Description AST ASR LLVM BIN RUN Filename integers \u2705 \u2705 \u2705 \u2705 \u2705 integer_kind.f90 relational operations \u2705 \u2705 \u2705 \u2705 \u2705 t01_rel_operations.f90 logical operations \u2705 \u2705 \u2705 \u2705 \u2705 t02_logical_operations.f90 Real Numbers Directory: tests/expressions/reals Description AST ASR LLVM BIN RUN Filename single/double reals \u2705 \u2705 \u2705 \u2705 \u2705 real_kind.f90 defined operator \u2705 \u274c \u274c \u274c \u274c t01_def_op.f90 Complex Numbers Directory: tests/expressions/complex Description AST ASR LLVM BIN RUN Filename single/double complex \u2705 \u2705 \u2705 \u2705 \u2705 complex_kind.f90 Strings Directory: tests/expressions/character Description AST ASR LLVM BIN RUN Filename character \u2705 \u2705 \u2705 \u2705 \u2705 t01_character.f90 string concatenation \u2705 \u2705 \u2705 \u2705 \u2705 t02_concat_operation.f90 Derived Types Directory: tests/expressions/derived_type Description AST ASR LLVM BIN RUN Filename basic derived types \u2705 \u2705 \u2705 \u2705 \u2705 t01_derived_type.f90 Statements Allocate Statement Directory: tests/statements/allocate Description AST ASR LLVM BIN RUN Filename allocate statement \u2705 \u2705 \u2705 \u2705 \u2705 t01.f90 Block Statement Directory: tests/statements/block Description AST ASR LLVM BIN RUN Filename block statement \u2705 \u274c \u274c \u274c \u274c t01.f90 Goto Statement Directory: tests/statements/goto Description AST ASR LLVM BIN RUN Filename computed go-to statement \u2705 \u274c \u274c \u274c \u274c t01.f90 go-to statement \u2705 \u274c \u274c \u274c \u274c t02.f90 If Statement Directory: tests/statements/if Description AST ASR LLVM BIN RUN Filename Test .false. \u2705 \u2705 \u2705 \u2705 \u2705 if_01.f90 single line if statement \u2705 \u2705 \u2705 \u2705 \u2705 if_02.f90 multi line if statement \u2705 \u2705 \u2705 \u2705 \u2705 if_03.f90 nested if statements \u2705 \u2705 \u2705 \u2705 \u2705 if_04.f90 While Statement Directory: tests/statements/while Description AST ASR LLVM BIN RUN Filename Simple while loops \u2705 \u2705 \u2705 \u2705 \u2705 while_01.f90 exit / cycle in while loops \u2705 \u2705 \u2705 \u2705 \u2705 while_02.f90 Print Statement Directory: tests/statements/print Description AST ASR LLVM BIN RUN Filename Basic print \u2705 \u2705 \u2705 \u2705 \u2705 t01.f90 Open, Read, Write, Close Statement Directory: tests/statements/file_io Description AST ASR LLVM BIN RUN Filename open/read/write/close \u2705 \u2705 \u274c \u274c \u274c t01.f90 Intrinsic Functions abs Directory: tests/intrinsic/abs Description AST ASR LLVM BIN RUN Filename scalar single/double real \u2705 \u2705 \u2705 \u2705 \u2705 t01_scalar_real.f90 scalar single/double complex \u2705 \u274c \u274c \u274c \u274c t02_scalar_complex.f90 array 1D single/double real \u2705 \u2705 \u274c \u274c \u274c t03_array1d_real.f90 exp Directory: tests/intrinsic/exp Description AST ASR LLVM BIN RUN Filename scalar single/double real \u2705 \u2705 \u2705 \u2705 \u2705 t01_scalar_real.f90 scalar single/double complex \u2705 \u2705 \u2705 \u2705 \u2705 t02_scalar_complex.f90 array 1D single/double real \u2705 \u2705 \u274c \u274c \u274c t03_array1d_real.f90 log Directory: tests/intrinsic/log Description AST ASR LLVM BIN RUN Filename scalar single/double real \u2705 \u2705 \u2705 \u2705 \u2705 t01_scalar_real.f90 scalar single/double complex \u2705 \u2705 \u2705 \u2705 \u2705 t02_scalar_complex.f90 array 1D single/double real \u2705 \u2705 \u274c \u274c \u274c t03_array1d_real.f90 sqrt Directory: tests/intrinsic/sqrt Description AST ASR LLVM BIN RUN Filename scalar single/double real \u2705 \u2705 \u2705 \u2705 \u2705 t01_scalar_real.f90 scalar single/double complex \u2705 \u274c \u274c \u274c \u274c t02_scalar_complex.f90 array 1D single/double real \u2705 \u2705 \u274c \u274c \u274c t03_array1d_real.f90 sin Directory: tests/intrinsic/sin Description AST ASR LLVM BIN RUN Filename scalar single/double real \u2705 \u2705 \u2705 \u2705 \u2705 t01_scalar_real.f90 scalar single/double complex \u2705 \u274c \u274c \u274c \u274c t02_scalar_complex.f90 array 1D single/double real \u2705 \u2705 \u274c \u274c \u274c t03_array1d_real.f90 cos Directory: tests/intrinsic/cos Description AST ASR LLVM BIN RUN Filename scalar single/double real \u2705 \u2705 \u2705 \u2705 \u2705 t01_scalar_real.f90 scalar single/double complex \u2705 \u2705 \u2705 \u2705 \u2705 t02_scalar_complex.f90 array 1D single/double real \u2705 \u2705 \u274c \u274c \u274c t03_array1d_real.f90 tan Directory: tests/intrinsic/tan Description AST ASR LLVM BIN RUN Filename scalar single/double real \u2705 \u2705 \u2705 \u2705 \u2705 t01_scalar_real.f90 scalar single/double complex \u2705 \u2705 \u2705 \u2705 \u2705 t02_scalar_complex.f90 array 1D single/double real \u2705 \u2705 \u274c \u274c \u274c t03_array1d_real.f90 sinh Directory: tests/intrinsic/sinh Description AST ASR LLVM BIN RUN Filename scalar single/double real \u2705 \u2705 \u2705 \u2705 \u2705 t01_scalar_real.f90 scalar single/double complex \u2705 \u2705 \u2705 \u2705 \u2705 t02_scalar_complex.f90 array 1D single/double real \u2705 \u2705 \u274c \u274c \u274c t03_array1d_real.f90 cosh Directory: tests/intrinsic/cosh Description AST ASR LLVM BIN RUN Filename scalar single/double real \u2705 \u2705 \u2705 \u2705 \u2705 t01_scalar_real.f90 scalar single/double complex \u2705 \u2705 \u2705 \u2705 \u2705 t02_scalar_complex.f90 array 1D single/double real \u2705 \u2705 \u274c \u274c \u274c t03_array1d_real.f90 tanh Directory: tests/intrinsic/tanh Description AST ASR LLVM BIN RUN Filename scalar single/double real \u2705 \u2705 \u2705 \u2705 \u2705 t01_scalar_real.f90 scalar single/double complex \u2705 \u2705 \u2705 \u2705 \u2705 t02_scalar_complex.f90 array 1D single/double real \u2705 \u2705 \u274c \u274c \u274c t03_array1d_real.f90 asin Directory: tests/intrinsic/asin Description AST ASR LLVM BIN RUN Filename scalar single/double real \u2705 \u2705 \u2705 \u2705 \u2705 t01_scalar_real.f90 scalar single/double complex \u2705 \u2705 \u2705 \u2705 \u2705 t02_scalar_complex.f90 array 1D single/double real \u2705 \u2705 \u274c \u274c \u274c t03_array1d_real.f90 acos Directory: tests/intrinsic/acos Description AST ASR LLVM BIN RUN Filename scalar single/double real \u2705 \u2705 \u2705 \u2705 \u2705 t01_scalar_real.f90 scalar single/double complex \u2705 \u2705 \u2705 \u2705 \u2705 t02_scalar_complex.f90 array 1D single/double real \u2705 \u2705 \u274c \u274c \u274c t03_array1d_real.f90 atan Directory: tests/intrinsic/atan Description AST ASR LLVM BIN RUN Filename scalar single/double real \u2705 \u2705 \u2705 \u2705 \u2705 t01_scalar_real.f90 scalar single/double complex \u2705 \u2705 \u2705 \u2705 \u2705 t02_scalar_complex.f90 array 1D single/double real \u2705 \u2705 \u274c \u274c \u274c t03_array1d_real.f90 modulo Directory: tests/intrinsic/modulo Description AST ASR LLVM BIN RUN Filename scalar single/double real \u2705 \u274c \u274c \u274c \u274c t01_scalar_real.f90 array 1D single/double real \u2705 \u2705 \u274c \u274c \u274c t03_array1d_real.f90 mod Directory: tests/intrinsic/mod Description AST ASR LLVM BIN RUN Filename scalar single/double real \u2705 \u274c \u274c \u274c \u274c t01_scalar_real.f90 array 1D single/double real \u2705 \u274c \u274c \u274c \u274c t03_array1d_real.f90 min Directory: tests/intrinsic/min Description AST ASR LLVM BIN RUN Filename scalar single/double real \u2705 \u2705 \u274c \u274c \u274c t01_scalar_real.f90 max Directory: tests/intrinsic/max Description AST ASR LLVM BIN RUN Filename scalar single/double real \u2705 \u2705 \u274c \u274c \u274c t01_scalar_real.f90 int Directory: tests/intrinsic/int Description AST ASR LLVM BIN RUN Filename scalar single/double real \u2705 \u274c \u274c \u274c \u274c t01_scalar_real.f90 real Directory: tests/intrinsic/real Description AST ASR LLVM BIN RUN Filename scalar single/double real \u2705 \u2705 \u2705 \u2705 \u2705 t01_scalar_real.f90 floor Directory: tests/intrinsic/floor Description AST ASR LLVM BIN RUN Filename scalar single/double real \u2705 \u274c \u274c \u274c \u274c t01_scalar_real.f90 nint Directory: tests/intrinsic/nint Description AST ASR LLVM BIN RUN Filename scalar single/double real \u2705 \u274c \u274c \u274c \u274c t01_scalar_real.f90","title":"LFortran Development Status"},{"location":"progress/#lfortran-development-status","text":"This page documents what Fortran features are supported by LFortran. For each feature we list a short description, the filename with the test and current status for each parts of the compiler: AST: The code can be parsed to AST ( lfortran --show-ast test.f90 ) ASR: The code can be transformed to ASR ( lfortran --show-asr test.f90 ) LLVM: LFortran can generate LLVM IR ( lfortran --show-llvm test.f90 ) BIN: The LLVM IR can compile to a binary RUN: The binary runs without errors If all are green it means the feature fully works and you can use it in your codes. Otherwise you can see what the status is of each feature. This page is generated automatically using the Compiler Tester repository which contains all the Fortran tests and scripts to run LFortran to produce the tables below. We are looking for contributors to contribute more tests. Our goal is to have a comprehensive Fortran testsuite that can be used to test any Fortran compiler. Testing the LFortran compiler version: $ lfortran --version LFortran version: 0.12.0-491-gaf48ff273 Platform: macOS Default target: x86_64-apple-darwin20.3.0","title":"LFortran Development Status"},{"location":"progress/#topics","text":"","title":"Topics"},{"location":"progress/#full-programs-that-compute-something-interesting","text":"","title":"Full programs that compute something interesting"},{"location":"progress/#basic-numerics","text":"Directory: tests/programs/numerics Description AST ASR LLVM BIN RUN Filename Pure Fortran sin(x) implementation \u2705 \u2705 \u2705 \u2705 \u2705 t01_sin_implementation.f90","title":"Basic Numerics"},{"location":"progress/#modules","text":"","title":"Modules"},{"location":"progress/#basic-usage","text":"Directory: tests/modules/basic Description AST ASR LLVM BIN RUN Filename Basic modules \u2705 \u2705 \u2705 \u2705 \u2705 t01.f90","title":"Basic Usage"},{"location":"progress/#module-functions-and-subroutines","text":"Directory: tests/modules/procedures Description AST ASR LLVM BIN RUN Filename Module functions \u2705 \u2705 \u2705 \u2705 \u2705 t01.f90 Module subroutines \u2705 \u2705 \u2705 \u2705 \u2705 t02.f90 Nested subroutines \u2705 \u2705 \u2705 \u2705 \u2705 t03.f90","title":"Module Functions and Subroutines"},{"location":"progress/#expressions","text":"","title":"Expressions"},{"location":"progress/#arithmetic-operations","text":"Directory: tests/expressions/arit Description AST ASR LLVM BIN RUN Filename +,-,*,/,** \u2705 \u2705 \u2705 \u2705 \u2705 basic_operations.f90","title":"Arithmetic Operations"},{"location":"progress/#integers","text":"Directory: tests/expressions/integers Description AST ASR LLVM BIN RUN Filename integers \u2705 \u2705 \u2705 \u2705 \u2705 integer_kind.f90 relational operations \u2705 \u2705 \u2705 \u2705 \u2705 t01_rel_operations.f90 logical operations \u2705 \u2705 \u2705 \u2705 \u2705 t02_logical_operations.f90","title":"Integers"},{"location":"progress/#real-numbers","text":"Directory: tests/expressions/reals Description AST ASR LLVM BIN RUN Filename single/double reals \u2705 \u2705 \u2705 \u2705 \u2705 real_kind.f90 defined operator \u2705 \u274c \u274c \u274c \u274c t01_def_op.f90","title":"Real Numbers"},{"location":"progress/#complex-numbers","text":"Directory: tests/expressions/complex Description AST ASR LLVM BIN RUN Filename single/double complex \u2705 \u2705 \u2705 \u2705 \u2705 complex_kind.f90","title":"Complex Numbers"},{"location":"progress/#strings","text":"Directory: tests/expressions/character Description AST ASR LLVM BIN RUN Filename character \u2705 \u2705 \u2705 \u2705 \u2705 t01_character.f90 string concatenation \u2705 \u2705 \u2705 \u2705 \u2705 t02_concat_operation.f90","title":"Strings"},{"location":"progress/#derived-types","text":"Directory: tests/expressions/derived_type Description AST ASR LLVM BIN RUN Filename basic derived types \u2705 \u2705 \u2705 \u2705 \u2705 t01_derived_type.f90","title":"Derived Types"},{"location":"progress/#statements","text":"","title":"Statements"},{"location":"progress/#allocate-statement","text":"Directory: tests/statements/allocate Description AST ASR LLVM BIN RUN Filename allocate statement \u2705 \u2705 \u2705 \u2705 \u2705 t01.f90","title":"Allocate Statement"},{"location":"progress/#block-statement","text":"Directory: tests/statements/block Description AST ASR LLVM BIN RUN Filename block statement \u2705 \u274c \u274c \u274c \u274c t01.f90","title":"Block Statement"},{"location":"progress/#goto-statement","text":"Directory: tests/statements/goto Description AST ASR LLVM BIN RUN Filename computed go-to statement \u2705 \u274c \u274c \u274c \u274c t01.f90 go-to statement \u2705 \u274c \u274c \u274c \u274c t02.f90","title":"Goto Statement"},{"location":"progress/#if-statement","text":"Directory: tests/statements/if Description AST ASR LLVM BIN RUN Filename Test .false. \u2705 \u2705 \u2705 \u2705 \u2705 if_01.f90 single line if statement \u2705 \u2705 \u2705 \u2705 \u2705 if_02.f90 multi line if statement \u2705 \u2705 \u2705 \u2705 \u2705 if_03.f90 nested if statements \u2705 \u2705 \u2705 \u2705 \u2705 if_04.f90","title":"If Statement"},{"location":"progress/#while-statement","text":"Directory: tests/statements/while Description AST ASR LLVM BIN RUN Filename Simple while loops \u2705 \u2705 \u2705 \u2705 \u2705 while_01.f90 exit / cycle in while loops \u2705 \u2705 \u2705 \u2705 \u2705 while_02.f90","title":"While Statement"},{"location":"progress/#print-statement","text":"Directory: tests/statements/print Description AST ASR LLVM BIN RUN Filename Basic print \u2705 \u2705 \u2705 \u2705 \u2705 t01.f90","title":"Print Statement"},{"location":"progress/#open-read-write-close-statement","text":"Directory: tests/statements/file_io Description AST ASR LLVM BIN RUN Filename open/read/write/close \u2705 \u2705 \u274c \u274c \u274c t01.f90","title":"Open, Read, Write, Close Statement"},{"location":"progress/#intrinsic-functions","text":"","title":"Intrinsic Functions"},{"location":"progress/#abs","text":"Directory: tests/intrinsic/abs Description AST ASR LLVM BIN RUN Filename scalar single/double real \u2705 \u2705 \u2705 \u2705 \u2705 t01_scalar_real.f90 scalar single/double complex \u2705 \u274c \u274c \u274c \u274c t02_scalar_complex.f90 array 1D single/double real \u2705 \u2705 \u274c \u274c \u274c t03_array1d_real.f90","title":"abs"},{"location":"progress/#exp","text":"Directory: tests/intrinsic/exp Description AST ASR LLVM BIN RUN Filename scalar single/double real \u2705 \u2705 \u2705 \u2705 \u2705 t01_scalar_real.f90 scalar single/double complex \u2705 \u2705 \u2705 \u2705 \u2705 t02_scalar_complex.f90 array 1D single/double real \u2705 \u2705 \u274c \u274c \u274c t03_array1d_real.f90","title":"exp"},{"location":"progress/#log","text":"Directory: tests/intrinsic/log Description AST ASR LLVM BIN RUN Filename scalar single/double real \u2705 \u2705 \u2705 \u2705 \u2705 t01_scalar_real.f90 scalar single/double complex \u2705 \u2705 \u2705 \u2705 \u2705 t02_scalar_complex.f90 array 1D single/double real \u2705 \u2705 \u274c \u274c \u274c t03_array1d_real.f90","title":"log"},{"location":"progress/#sqrt","text":"Directory: tests/intrinsic/sqrt Description AST ASR LLVM BIN RUN Filename scalar single/double real \u2705 \u2705 \u2705 \u2705 \u2705 t01_scalar_real.f90 scalar single/double complex \u2705 \u274c \u274c \u274c \u274c t02_scalar_complex.f90 array 1D single/double real \u2705 \u2705 \u274c \u274c \u274c t03_array1d_real.f90","title":"sqrt"},{"location":"progress/#sin","text":"Directory: tests/intrinsic/sin Description AST ASR LLVM BIN RUN Filename scalar single/double real \u2705 \u2705 \u2705 \u2705 \u2705 t01_scalar_real.f90 scalar single/double complex \u2705 \u274c \u274c \u274c \u274c t02_scalar_complex.f90 array 1D single/double real \u2705 \u2705 \u274c \u274c \u274c t03_array1d_real.f90","title":"sin"},{"location":"progress/#cos","text":"Directory: tests/intrinsic/cos Description AST ASR LLVM BIN RUN Filename scalar single/double real \u2705 \u2705 \u2705 \u2705 \u2705 t01_scalar_real.f90 scalar single/double complex \u2705 \u2705 \u2705 \u2705 \u2705 t02_scalar_complex.f90 array 1D single/double real \u2705 \u2705 \u274c \u274c \u274c t03_array1d_real.f90","title":"cos"},{"location":"progress/#tan","text":"Directory: tests/intrinsic/tan Description AST ASR LLVM BIN RUN Filename scalar single/double real \u2705 \u2705 \u2705 \u2705 \u2705 t01_scalar_real.f90 scalar single/double complex \u2705 \u2705 \u2705 \u2705 \u2705 t02_scalar_complex.f90 array 1D single/double real \u2705 \u2705 \u274c \u274c \u274c t03_array1d_real.f90","title":"tan"},{"location":"progress/#sinh","text":"Directory: tests/intrinsic/sinh Description AST ASR LLVM BIN RUN Filename scalar single/double real \u2705 \u2705 \u2705 \u2705 \u2705 t01_scalar_real.f90 scalar single/double complex \u2705 \u2705 \u2705 \u2705 \u2705 t02_scalar_complex.f90 array 1D single/double real \u2705 \u2705 \u274c \u274c \u274c t03_array1d_real.f90","title":"sinh"},{"location":"progress/#cosh","text":"Directory: tests/intrinsic/cosh Description AST ASR LLVM BIN RUN Filename scalar single/double real \u2705 \u2705 \u2705 \u2705 \u2705 t01_scalar_real.f90 scalar single/double complex \u2705 \u2705 \u2705 \u2705 \u2705 t02_scalar_complex.f90 array 1D single/double real \u2705 \u2705 \u274c \u274c \u274c t03_array1d_real.f90","title":"cosh"},{"location":"progress/#tanh","text":"Directory: tests/intrinsic/tanh Description AST ASR LLVM BIN RUN Filename scalar single/double real \u2705 \u2705 \u2705 \u2705 \u2705 t01_scalar_real.f90 scalar single/double complex \u2705 \u2705 \u2705 \u2705 \u2705 t02_scalar_complex.f90 array 1D single/double real \u2705 \u2705 \u274c \u274c \u274c t03_array1d_real.f90","title":"tanh"},{"location":"progress/#asin","text":"Directory: tests/intrinsic/asin Description AST ASR LLVM BIN RUN Filename scalar single/double real \u2705 \u2705 \u2705 \u2705 \u2705 t01_scalar_real.f90 scalar single/double complex \u2705 \u2705 \u2705 \u2705 \u2705 t02_scalar_complex.f90 array 1D single/double real \u2705 \u2705 \u274c \u274c \u274c t03_array1d_real.f90","title":"asin"},{"location":"progress/#acos","text":"Directory: tests/intrinsic/acos Description AST ASR LLVM BIN RUN Filename scalar single/double real \u2705 \u2705 \u2705 \u2705 \u2705 t01_scalar_real.f90 scalar single/double complex \u2705 \u2705 \u2705 \u2705 \u2705 t02_scalar_complex.f90 array 1D single/double real \u2705 \u2705 \u274c \u274c \u274c t03_array1d_real.f90","title":"acos"},{"location":"progress/#atan","text":"Directory: tests/intrinsic/atan Description AST ASR LLVM BIN RUN Filename scalar single/double real \u2705 \u2705 \u2705 \u2705 \u2705 t01_scalar_real.f90 scalar single/double complex \u2705 \u2705 \u2705 \u2705 \u2705 t02_scalar_complex.f90 array 1D single/double real \u2705 \u2705 \u274c \u274c \u274c t03_array1d_real.f90","title":"atan"},{"location":"progress/#modulo","text":"Directory: tests/intrinsic/modulo Description AST ASR LLVM BIN RUN Filename scalar single/double real \u2705 \u274c \u274c \u274c \u274c t01_scalar_real.f90 array 1D single/double real \u2705 \u2705 \u274c \u274c \u274c t03_array1d_real.f90","title":"modulo"},{"location":"progress/#mod","text":"Directory: tests/intrinsic/mod Description AST ASR LLVM BIN RUN Filename scalar single/double real \u2705 \u274c \u274c \u274c \u274c t01_scalar_real.f90 array 1D single/double real \u2705 \u274c \u274c \u274c \u274c t03_array1d_real.f90","title":"mod"},{"location":"progress/#min","text":"Directory: tests/intrinsic/min Description AST ASR LLVM BIN RUN Filename scalar single/double real \u2705 \u2705 \u274c \u274c \u274c t01_scalar_real.f90","title":"min"},{"location":"progress/#max","text":"Directory: tests/intrinsic/max Description AST ASR LLVM BIN RUN Filename scalar single/double real \u2705 \u2705 \u274c \u274c \u274c t01_scalar_real.f90","title":"max"},{"location":"progress/#int","text":"Directory: tests/intrinsic/int Description AST ASR LLVM BIN RUN Filename scalar single/double real \u2705 \u274c \u274c \u274c \u274c t01_scalar_real.f90","title":"int"},{"location":"progress/#real","text":"Directory: tests/intrinsic/real Description AST ASR LLVM BIN RUN Filename scalar single/double real \u2705 \u2705 \u2705 \u2705 \u2705 t01_scalar_real.f90","title":"real"},{"location":"progress/#floor","text":"Directory: tests/intrinsic/floor Description AST ASR LLVM BIN RUN Filename scalar single/double real \u2705 \u274c \u274c \u274c \u274c t01_scalar_real.f90","title":"floor"},{"location":"progress/#nint","text":"Directory: tests/intrinsic/nint Description AST ASR LLVM BIN RUN Filename scalar single/double real \u2705 \u274c \u274c \u274c \u274c t01_scalar_real.f90","title":"nint"},{"location":"intrinsics/array/size/","text":"size(x) Returns the size of an array x . Declaration Syntax retval = size ( A [, dim [, kind ]]) integer function size ( x ) Arguments A the input array of any type or rank. dim optional dimension, if present, size returns the size of this dimension. kind optional the kind of the return value. Return values n the size of an array (integer). Description The size intrinsic function returns the size of an array. It returns the product of all dimensions, unless the dim argument is specified, in which case it only returns the size of this particular dimension. The kind argument can be used to specify the integer kind of the result. Types Supported argument type is integer. Examples program intrinsics_size implicit none real :: A ( 3 , 4 ) print * , size ( A ) print * , size ( A , 2 ) end program Result : 12 4 See Also shape , reshape .","title":"size(x)"},{"location":"intrinsics/array/size/#sizex","text":"Returns the size of an array x .","title":"size(x)"},{"location":"intrinsics/array/size/#declaration","text":"","title":"Declaration"},{"location":"intrinsics/array/size/#syntax","text":"retval = size ( A [, dim [, kind ]]) integer function size ( x )","title":"Syntax"},{"location":"intrinsics/array/size/#arguments","text":"A the input array of any type or rank. dim optional dimension, if present, size returns the size of this dimension. kind optional the kind of the return value.","title":"Arguments"},{"location":"intrinsics/array/size/#return-values","text":"n the size of an array (integer).","title":"Return values"},{"location":"intrinsics/array/size/#description","text":"The size intrinsic function returns the size of an array. It returns the product of all dimensions, unless the dim argument is specified, in which case it only returns the size of this particular dimension. The kind argument can be used to specify the integer kind of the result.","title":"Description"},{"location":"intrinsics/array/size/#types","text":"Supported argument type is integer.","title":"Types"},{"location":"intrinsics/array/size/#examples","text":"program intrinsics_size implicit none real :: A ( 3 , 4 ) print * , size ( A ) print * , size ( A , 2 ) end program Result : 12 4","title":"Examples"},{"location":"intrinsics/array/size/#see-also","text":"shape , reshape .","title":"See Also"},{"location":"intrinsics/bit/shiftl/","text":"shiftl(x, shift) Logical shift left function. Declaration Syntax retval = shiftl ( int ( number ), 31 ); integer ( int32 ) function shiftli32 ( i , shift ) Arguments x is an integer input value. shift an unsigned integer value less than or equal to the bit size of x . The possible values are 7, 31, and 63. Return values The return value is of type integer and of the same kind as x . Description shiftl(x, shift) logically left shifts x by shift number of bits. shiftl shifts from LSB( L east S ignificant B it) to MSB( M ost S ignificant B it). Bits shifted from the left end i.e., MSB bits are lost. Zeroes are appended to the opposite right end. Types Supported types in unsigned integer value x and unsigned integer value shift from (7, 31, 63) less than or equal to bit size of x . interface shiftl module procedure shiftli8, shiftli32, shiftli64 end interface contains interface integer(int8) function shiftli8(i, shift) result(r) integer(int8), intent(in) :: i integer :: shift end function integer(int32) function shiftli32(i, shift) result(r) integer(int32) :: i integer :: shift end function integer(int64) function shiftli64(i, shift) result(r) integer(int64) :: i integer :: shift end function end interface Examples program intrinsics_shiftl implicit none integer , parameter :: x = kind ( 2 ) integer :: retval retval = shiftl ( int ( x ), 7 ) print * , retval end program Result: 4 See Also shiftr .","title":"shiftl(x, shift)"},{"location":"intrinsics/bit/shiftl/#shiftlx-shift","text":"Logical shift left function.","title":"shiftl(x, shift)"},{"location":"intrinsics/bit/shiftl/#declaration","text":"","title":"Declaration"},{"location":"intrinsics/bit/shiftl/#syntax","text":"retval = shiftl ( int ( number ), 31 ); integer ( int32 ) function shiftli32 ( i , shift )","title":"Syntax"},{"location":"intrinsics/bit/shiftl/#arguments","text":"x is an integer input value. shift an unsigned integer value less than or equal to the bit size of x . The possible values are 7, 31, and 63.","title":"Arguments"},{"location":"intrinsics/bit/shiftl/#return-values","text":"The return value is of type integer and of the same kind as x .","title":"Return values"},{"location":"intrinsics/bit/shiftl/#description","text":"shiftl(x, shift) logically left shifts x by shift number of bits. shiftl shifts from LSB( L east S ignificant B it) to MSB( M ost S ignificant B it). Bits shifted from the left end i.e., MSB bits are lost. Zeroes are appended to the opposite right end.","title":"Description"},{"location":"intrinsics/bit/shiftl/#types","text":"Supported types in unsigned integer value x and unsigned integer value shift from (7, 31, 63) less than or equal to bit size of x . interface shiftl module procedure shiftli8, shiftli32, shiftli64 end interface contains interface integer(int8) function shiftli8(i, shift) result(r) integer(int8), intent(in) :: i integer :: shift end function integer(int32) function shiftli32(i, shift) result(r) integer(int32) :: i integer :: shift end function integer(int64) function shiftli64(i, shift) result(r) integer(int64) :: i integer :: shift end function end interface","title":"Types"},{"location":"intrinsics/bit/shiftl/#examples","text":"program intrinsics_shiftl implicit none integer , parameter :: x = kind ( 2 ) integer :: retval retval = shiftl ( int ( x ), 7 ) print * , retval end program Result: 4","title":"Examples"},{"location":"intrinsics/bit/shiftl/#see-also","text":"shiftr .","title":"See Also"},{"location":"intrinsics/bit/shiftr/","text":"shiftr(x, shift) Logical shift right function. Declaration Syntax retval = shiftr ( int ( number ), 31 ); integer ( int32 ) function shiftri32 ( i , shift ) Arguments x is an integer input value. shift an unsigned integer value less than or equal to the bit size of x . The possible values are 7, 31, and 63. Return values The return value is of type integer and of the same kind as x . Description shiftr(x, shift) logically right shifts x by shift number of bits. shiftr shifts from MSB( M ost S ignificant B it) to LSB( L east S ignificant B it). Bits shifted from the right end i.e., LSB bits are lost. Zeroes are appended to the opposite left end. Types Supported types in unsigned integer value x and unsigned integer value shift from (7, 31, 63) less than or equal to bit size of x . interface shiftr module procedure shiftri8, shiftri32, shiftri64 end interface contains interface integer(int8) function shiftri8(i, shift) result(r) integer(int8), intent(in) :: i integer :: shift end function integer(int32) function shiftri32(i, shift) result(r) integer(int32) :: i integer :: shift end function integer(int64) function shiftri64(i, shift) result(r) integer(int64) :: i integer :: shift end function end interface Examples program intrinsics_shiftr implicit none integer , parameter :: x = kind ( 4 ) integer :: retval retval = shiftr ( int ( x ), 7 ) print * , retval end program Result: 2 See Also shiftl .","title":"shiftr(x, shift)"},{"location":"intrinsics/bit/shiftr/#shiftrx-shift","text":"Logical shift right function.","title":"shiftr(x, shift)"},{"location":"intrinsics/bit/shiftr/#declaration","text":"","title":"Declaration"},{"location":"intrinsics/bit/shiftr/#syntax","text":"retval = shiftr ( int ( number ), 31 ); integer ( int32 ) function shiftri32 ( i , shift )","title":"Syntax"},{"location":"intrinsics/bit/shiftr/#arguments","text":"x is an integer input value. shift an unsigned integer value less than or equal to the bit size of x . The possible values are 7, 31, and 63.","title":"Arguments"},{"location":"intrinsics/bit/shiftr/#return-values","text":"The return value is of type integer and of the same kind as x .","title":"Return values"},{"location":"intrinsics/bit/shiftr/#description","text":"shiftr(x, shift) logically right shifts x by shift number of bits. shiftr shifts from MSB( M ost S ignificant B it) to LSB( L east S ignificant B it). Bits shifted from the right end i.e., LSB bits are lost. Zeroes are appended to the opposite left end.","title":"Description"},{"location":"intrinsics/bit/shiftr/#types","text":"Supported types in unsigned integer value x and unsigned integer value shift from (7, 31, 63) less than or equal to bit size of x . interface shiftr module procedure shiftri8, shiftri32, shiftri64 end interface contains interface integer(int8) function shiftri8(i, shift) result(r) integer(int8), intent(in) :: i integer :: shift end function integer(int32) function shiftri32(i, shift) result(r) integer(int32) :: i integer :: shift end function integer(int64) function shiftri64(i, shift) result(r) integer(int64) :: i integer :: shift end function end interface","title":"Types"},{"location":"intrinsics/bit/shiftr/#examples","text":"program intrinsics_shiftr implicit none integer , parameter :: x = kind ( 4 ) integer :: retval retval = shiftr ( int ( x ), 7 ) print * , retval end program Result: 2","title":"Examples"},{"location":"intrinsics/bit/shiftr/#see-also","text":"shiftl .","title":"See Also"},{"location":"intrinsics/character/achar/","text":"achar(x, kind) Character represented by in the ASCII character set. Declaration Syntax retval = achar ( x , kind ) character ( len = 1 ) elemental function achar ( x , kind ) Arguments x : the input value of integer type. kind : an optional input value of type integer constant expression for initialization. Return value The return value is of type character of length 1. The return value is of kind kind if optional input value is passed, otherwise the kind is default kind. Description achar(x, kind) returns the character represented by the ASCII character set at x position. If x is outside the ASCII character set integer value, i.e., if x is not represented in the ASCII character set, the return value is undefined. It is a runtime builtin function. Types Supported argument type is integer. interface character ( len = 1 ) function achar ( x , kind ) integer , intent ( in ) :: x integer , optional :: kind end function end interface Examples program intrinsics_achar implicit none character :: exclamation = achar ( 33 ) print * , exclamation end program Result: ! See Also lge .","title":"achar(x, kind)"},{"location":"intrinsics/character/achar/#acharx-kind","text":"Character represented by in the ASCII character set.","title":"achar(x, kind)"},{"location":"intrinsics/character/achar/#declaration","text":"","title":"Declaration"},{"location":"intrinsics/character/achar/#syntax","text":"retval = achar ( x , kind ) character ( len = 1 ) elemental function achar ( x , kind )","title":"Syntax"},{"location":"intrinsics/character/achar/#arguments","text":"x : the input value of integer type. kind : an optional input value of type integer constant expression for initialization.","title":"Arguments"},{"location":"intrinsics/character/achar/#return-value","text":"The return value is of type character of length 1. The return value is of kind kind if optional input value is passed, otherwise the kind is default kind.","title":"Return value"},{"location":"intrinsics/character/achar/#description","text":"achar(x, kind) returns the character represented by the ASCII character set at x position. If x is outside the ASCII character set integer value, i.e., if x is not represented in the ASCII character set, the return value is undefined. It is a runtime builtin function.","title":"Description"},{"location":"intrinsics/character/achar/#types","text":"Supported argument type is integer. interface character ( len = 1 ) function achar ( x , kind ) integer , intent ( in ) :: x integer , optional :: kind end function end interface","title":"Types"},{"location":"intrinsics/character/achar/#examples","text":"program intrinsics_achar implicit none character :: exclamation = achar ( 33 ) print * , exclamation end program Result: !","title":"Examples"},{"location":"intrinsics/character/achar/#see-also","text":"lge .","title":"See Also"},{"location":"intrinsics/character/adjustl/","text":"adjustl(string) Left adjust a string. Declaration Syntax retval = adjustl ( string ) elemental function adjustl ( string ) Arguments string : the input value must be of character type. Return value The return value is of type character and of the same kind as of input value string , with leading spaces removed and same number of spaces appended. Description adjustl(string) adjusts input string by removing any leading spaces and appending same number of spaces. Types Supported argument type is character. interface repeat module procedure repeati32 , repeati64 end interface contains function adjustl ( string ) character ( len =* ), intent ( in ) :: string end function Examples program intrinsics_adjustl use lfortran_intrinsic_string , only : adjustl implicit none character ( * ), parameter :: s1 = \" A B \" print * , adjustl ( s1 ) end program Result: A B See Also lge .","title":"adjustl(string)"},{"location":"intrinsics/character/adjustl/#adjustlstring","text":"Left adjust a string.","title":"adjustl(string)"},{"location":"intrinsics/character/adjustl/#declaration","text":"","title":"Declaration"},{"location":"intrinsics/character/adjustl/#syntax","text":"retval = adjustl ( string ) elemental function adjustl ( string )","title":"Syntax"},{"location":"intrinsics/character/adjustl/#arguments","text":"string : the input value must be of character type.","title":"Arguments"},{"location":"intrinsics/character/adjustl/#return-value","text":"The return value is of type character and of the same kind as of input value string , with leading spaces removed and same number of spaces appended.","title":"Return value"},{"location":"intrinsics/character/adjustl/#description","text":"adjustl(string) adjusts input string by removing any leading spaces and appending same number of spaces.","title":"Description"},{"location":"intrinsics/character/adjustl/#types","text":"Supported argument type is character. interface repeat module procedure repeati32 , repeati64 end interface contains function adjustl ( string ) character ( len =* ), intent ( in ) :: string end function","title":"Types"},{"location":"intrinsics/character/adjustl/#examples","text":"program intrinsics_adjustl use lfortran_intrinsic_string , only : adjustl implicit none character ( * ), parameter :: s1 = \" A B \" print * , adjustl ( s1 ) end program Result: A B","title":"Examples"},{"location":"intrinsics/character/adjustl/#see-also","text":"lge .","title":"See Also"},{"location":"intrinsics/character/adjustr/","text":"adjustr(string) Right adjust a string. Declaration Syntax retval = adjustr ( string ) elemental function adjustr ( string ) Arguments string : the input value must be of character type. Return value The return value is of type character and of the same kind as of input value string , with trailing spaces removed and same number of spaces added at the start. Description adjustr(string) adjusts input string by removing any trailing spaces and adding same number of spaces at the start of the input string. Types Supported argument type is character. interface repeat module procedure repeati32 , repeati64 end interface contains function adjustr ( string ) character ( len =* ), intent ( in ) :: string end function Examples program intrinsics_adjustr use lfortran_intrinsic_string , only : adjustr implicit none character ( * ), parameter :: s1 = \"A B \" print * , adjustr ( s1 ) end program Result: A B See Also adjustl .","title":"adjustr(string)"},{"location":"intrinsics/character/adjustr/#adjustrstring","text":"Right adjust a string.","title":"adjustr(string)"},{"location":"intrinsics/character/adjustr/#declaration","text":"","title":"Declaration"},{"location":"intrinsics/character/adjustr/#syntax","text":"retval = adjustr ( string ) elemental function adjustr ( string )","title":"Syntax"},{"location":"intrinsics/character/adjustr/#arguments","text":"string : the input value must be of character type.","title":"Arguments"},{"location":"intrinsics/character/adjustr/#return-value","text":"The return value is of type character and of the same kind as of input value string , with trailing spaces removed and same number of spaces added at the start.","title":"Return value"},{"location":"intrinsics/character/adjustr/#description","text":"adjustr(string) adjusts input string by removing any trailing spaces and adding same number of spaces at the start of the input string.","title":"Description"},{"location":"intrinsics/character/adjustr/#types","text":"Supported argument type is character. interface repeat module procedure repeati32 , repeati64 end interface contains function adjustr ( string ) character ( len =* ), intent ( in ) :: string end function","title":"Types"},{"location":"intrinsics/character/adjustr/#examples","text":"program intrinsics_adjustr use lfortran_intrinsic_string , only : adjustr implicit none character ( * ), parameter :: s1 = \"A B \" print * , adjustr ( s1 ) end program Result: A B","title":"Examples"},{"location":"intrinsics/character/adjustr/#see-also","text":"adjustl .","title":"See Also"},{"location":"intrinsics/character/len_trim/","text":"len_trim(string) Length of a character string ignoring trailing blank character(s). Declaration Syntax retval = len_trim ( string ) integer elemental function len_trim ( string ) Arguments string the input value of character type. Return value The return value is of type unsigned integer. Description len_trim(string) returns the length of the character argument without including trailing blank character(s). Types Supported argument type is character scalar. interface repeat module procedure repeati32 , repeati64 end interface contains integer elemental function len_trim ( string ) character ( len =* ), intent ( in ) :: string end function Examples program intrinsics_len_trim use lfortran_intrinsic_string , only : len_trim implicit none character ( * ), parameter :: s1 = \" A B \" integer :: retval retval = len_trim ( s1 ) print * , retval end program Result: 4 See Also lge .","title":"len_trim(string)"},{"location":"intrinsics/character/len_trim/#len_trimstring","text":"Length of a character string ignoring trailing blank character(s).","title":"len_trim(string)"},{"location":"intrinsics/character/len_trim/#declaration","text":"","title":"Declaration"},{"location":"intrinsics/character/len_trim/#syntax","text":"retval = len_trim ( string ) integer elemental function len_trim ( string )","title":"Syntax"},{"location":"intrinsics/character/len_trim/#arguments","text":"string the input value of character type.","title":"Arguments"},{"location":"intrinsics/character/len_trim/#return-value","text":"The return value is of type unsigned integer.","title":"Return value"},{"location":"intrinsics/character/len_trim/#description","text":"len_trim(string) returns the length of the character argument without including trailing blank character(s).","title":"Description"},{"location":"intrinsics/character/len_trim/#types","text":"Supported argument type is character scalar. interface repeat module procedure repeati32 , repeati64 end interface contains integer elemental function len_trim ( string ) character ( len =* ), intent ( in ) :: string end function","title":"Types"},{"location":"intrinsics/character/len_trim/#examples","text":"program intrinsics_len_trim use lfortran_intrinsic_string , only : len_trim implicit none character ( * ), parameter :: s1 = \" A B \" integer :: retval retval = len_trim ( s1 ) print * , retval end program Result: 4","title":"Examples"},{"location":"intrinsics/character/len_trim/#see-also","text":"lge .","title":"See Also"},{"location":"intrinsics/character/lge/","text":"lge(x, y) Lexically greater than or equal. Declaration Syntax retval = lge ( x , y ) function lge ( x , y ) Arguments x input value of type character. y input value of type character. x and y can be seen as string A and string B. Return values The return value is of logical true or false type. True if x string is lexically greater than or equal to y . False if they are not. Description lge(x, y) determines if input string x is lexically greater than or equal to input string y . The two strings in comparison are interpreted as containing ASCII character codes. Types Argument types should be of type character literal. module lfortran_intrinsic_string use , intrinsic :: iso_fortran_env , only : i64 => int64 implicit none interface repeat module procedure repeati32 , repeati64 end interface contains function lge ( x , y ) result ( r ) character ( len =* ), intent ( in ) :: x character ( len =* ), intent ( in ) :: y logical :: r end function Examples program intrinsics_lge implicit none character ( len = 10 ) :: s1 = 'abcde' character ( len = 10 ) :: s2 = 'xyz' character ( len = 10 ) :: s3 = 'AB' character ( len = 10 ) :: s4 = 'AAB' print * , lge ( s1 , s2 ) end program Result: false true See Also len_trim .","title":"lge(x, y)"},{"location":"intrinsics/character/lge/#lgex-y","text":"Lexically greater than or equal.","title":"lge(x, y)"},{"location":"intrinsics/character/lge/#declaration","text":"","title":"Declaration"},{"location":"intrinsics/character/lge/#syntax","text":"retval = lge ( x , y ) function lge ( x , y )","title":"Syntax"},{"location":"intrinsics/character/lge/#arguments","text":"x input value of type character. y input value of type character. x and y can be seen as string A and string B.","title":"Arguments"},{"location":"intrinsics/character/lge/#return-values","text":"The return value is of logical true or false type. True if x string is lexically greater than or equal to y . False if they are not.","title":"Return values"},{"location":"intrinsics/character/lge/#description","text":"lge(x, y) determines if input string x is lexically greater than or equal to input string y . The two strings in comparison are interpreted as containing ASCII character codes.","title":"Description"},{"location":"intrinsics/character/lge/#types","text":"Argument types should be of type character literal. module lfortran_intrinsic_string use , intrinsic :: iso_fortran_env , only : i64 => int64 implicit none interface repeat module procedure repeati32 , repeati64 end interface contains function lge ( x , y ) result ( r ) character ( len =* ), intent ( in ) :: x character ( len =* ), intent ( in ) :: y logical :: r end function","title":"Types"},{"location":"intrinsics/character/lge/#examples","text":"program intrinsics_lge implicit none character ( len = 10 ) :: s1 = 'abcde' character ( len = 10 ) :: s2 = 'xyz' character ( len = 10 ) :: s3 = 'AB' character ( len = 10 ) :: s4 = 'AAB' print * , lge ( s1 , s2 ) end program Result: false true","title":"Examples"},{"location":"intrinsics/character/lge/#see-also","text":"len_trim .","title":"See Also"},{"location":"intrinsics/kind-type/kind/","text":"kind(x) Kind of an entity. Declaration Syntax retval = kind ( x ) integer function kind ( x ) Arguments x the input value, can be logical, integer, real, complex, or character. It may be a scalar or array valued i.e., any intrinsic type. Return values The return value is of integer type and of default integer kind. Description kind(x) returns the kind parameter of the input argument x . Types Supported argument types are logical, integer, real, complex, or character. module lfortran_intrinsic_kind implicit none contains integer function kind ( x ) result ( r ) logical ( 4 ), intent ( in ) :: x r = 4 end function integer function skind ( x ) result ( r ) real ( 4 ), intent ( in ) :: x r = 4 end function integer function dkind ( x ) result ( r ) real ( 8 ), intent ( in ) :: x r = 8 end function integer function lkind ( x ) result ( r ) logical ( 4 ), intent ( in ) :: x r = 4 end function end module Examples program intrinsics_kind use lfortran_intrinsic_kind , only : kind implicit none logical :: l4d logical ( 4 ) :: l4 print * , kind ( l4d ) print * , kind ( l4 ) end program Result: 4 4 See Also None.","title":"kind(x)"},{"location":"intrinsics/kind-type/kind/#kindx","text":"Kind of an entity.","title":"kind(x)"},{"location":"intrinsics/kind-type/kind/#declaration","text":"","title":"Declaration"},{"location":"intrinsics/kind-type/kind/#syntax","text":"retval = kind ( x ) integer function kind ( x )","title":"Syntax"},{"location":"intrinsics/kind-type/kind/#arguments","text":"x the input value, can be logical, integer, real, complex, or character. It may be a scalar or array valued i.e., any intrinsic type.","title":"Arguments"},{"location":"intrinsics/kind-type/kind/#return-values","text":"The return value is of integer type and of default integer kind.","title":"Return values"},{"location":"intrinsics/kind-type/kind/#description","text":"kind(x) returns the kind parameter of the input argument x .","title":"Description"},{"location":"intrinsics/kind-type/kind/#types","text":"Supported argument types are logical, integer, real, complex, or character. module lfortran_intrinsic_kind implicit none contains integer function kind ( x ) result ( r ) logical ( 4 ), intent ( in ) :: x r = 4 end function integer function skind ( x ) result ( r ) real ( 4 ), intent ( in ) :: x r = 4 end function integer function dkind ( x ) result ( r ) real ( 8 ), intent ( in ) :: x r = 8 end function integer function lkind ( x ) result ( r ) logical ( 4 ), intent ( in ) :: x r = 4 end function end module","title":"Types"},{"location":"intrinsics/kind-type/kind/#examples","text":"program intrinsics_kind use lfortran_intrinsic_kind , only : kind implicit none logical :: l4d logical ( 4 ) :: l4 print * , kind ( l4d ) print * , kind ( l4 ) end program Result: 4 4","title":"Examples"},{"location":"intrinsics/kind-type/kind/#see-also","text":"None.","title":"See Also"},{"location":"intrinsics/mathematical/trigonometric/acos/","text":"acos(x) Trigonometric arc cosine (inverse cosine) function. Declaration Syntax retval = acos ( x ) elemental real ( p ) function acos ( x ) elemental complex ( p ) function acos ( x ) Arguments x the input value, can be real or complex; less than or equal to 1. Return values The returned value has the kind of the input value and TYPE may be real or complex. Description acos(x) computes the arcsine of the argument x . The arc cosine is the inverse function of the cosine function. It is commonly used in trigonometry to find the angle when the lengths of the hypotenuse and the base side of a right triangle are known. Types Supported argument types float, double, complex float, complex double. interface acos module procedure sacos , dacos , cacos , zacos end interface contains interface elemental real ( sp ) function sacos ( x ) real ( sp ), intent ( in ) :: x end function elemental real ( dp ) function dacos ( x ) real ( dp ), intent ( in ) :: x end function elemental complex ( sp ) function cacos ( x ) complex ( sp ), intent ( in ) :: x end function elemental complex ( dp ) function zacos ( x ) complex ( dp ), intent ( in ) :: x end function end interface Examples program intrinsics_acos implicit none integer , parameter :: arg_x = kind ( 0.0 ) real ( arg_x ) :: x1 real :: retval_x real :: arg_x retval_x = acos ( 0.84147098 ) print * , ret_val_x retval_x = acos ( x1 ) print * , ret_val_x end program Result : 0.570796336 0.570796336 See Also asin , atan .","title":"acos(x)"},{"location":"intrinsics/mathematical/trigonometric/acos/#acosx","text":"Trigonometric arc cosine (inverse cosine) function.","title":"acos(x)"},{"location":"intrinsics/mathematical/trigonometric/acos/#declaration","text":"","title":"Declaration"},{"location":"intrinsics/mathematical/trigonometric/acos/#syntax","text":"retval = acos ( x ) elemental real ( p ) function acos ( x ) elemental complex ( p ) function acos ( x )","title":"Syntax"},{"location":"intrinsics/mathematical/trigonometric/acos/#arguments","text":"x the input value, can be real or complex; less than or equal to 1.","title":"Arguments"},{"location":"intrinsics/mathematical/trigonometric/acos/#return-values","text":"The returned value has the kind of the input value and TYPE may be real or complex.","title":"Return values"},{"location":"intrinsics/mathematical/trigonometric/acos/#description","text":"acos(x) computes the arcsine of the argument x . The arc cosine is the inverse function of the cosine function. It is commonly used in trigonometry to find the angle when the lengths of the hypotenuse and the base side of a right triangle are known.","title":"Description"},{"location":"intrinsics/mathematical/trigonometric/acos/#types","text":"Supported argument types float, double, complex float, complex double. interface acos module procedure sacos , dacos , cacos , zacos end interface contains interface elemental real ( sp ) function sacos ( x ) real ( sp ), intent ( in ) :: x end function elemental real ( dp ) function dacos ( x ) real ( dp ), intent ( in ) :: x end function elemental complex ( sp ) function cacos ( x ) complex ( sp ), intent ( in ) :: x end function elemental complex ( dp ) function zacos ( x ) complex ( dp ), intent ( in ) :: x end function end interface","title":"Types"},{"location":"intrinsics/mathematical/trigonometric/acos/#examples","text":"program intrinsics_acos implicit none integer , parameter :: arg_x = kind ( 0.0 ) real ( arg_x ) :: x1 real :: retval_x real :: arg_x retval_x = acos ( 0.84147098 ) print * , ret_val_x retval_x = acos ( x1 ) print * , ret_val_x end program Result : 0.570796336 0.570796336","title":"Examples"},{"location":"intrinsics/mathematical/trigonometric/acos/#see-also","text":"asin , atan .","title":"See Also"},{"location":"intrinsics/mathematical/trigonometric/acosh/","text":"acosh(x) Inverse hyperbolic cosine function. Declaration Syntax retval = acosh ( x ) elemental real ( p ) function acosh ( x ) elemental complex ( p ) function acosh ( x ) Arguments x the input value, can be real with value greater than or equal to 1 or of type complex. Return values The returned value has the kind of the input value and TYPE may be real or complex. Description acosh(x) computes the inverse hyperbolic cosine function of x . The result type and kind are the same as input value x . If the result is complex, the real part is non-negative, and the imaginary part is expressed in radians and lients in the range \\(-\\pi <= img (acosh(x)) <= \\pi\\) For real values \\(x\\) in the domain \\(x > 1\\) , the inverse hyperbolic cosine satisifies: \\(cosh^{-1}(x) = \\log(x + \\sqrt{(x^2 - 1)})\\) For complex numbers \\(x = x + iy\\) , as well as real values in the domain \\(-\\infty < z <= 1\\) , the call \\(acosh(z)\\) returns complex results. Types Supported argument types float, double, complex float, complex double. interface acosh module procedure sacosh , dacosh , cacosh , zacosh end interface contains interface elemental real ( sp ) function sacosh ( x ) real ( sp ), intent ( in ) :: x end function elemental real ( dp ) function dacosh ( x ) real ( dp ), intent ( in ) :: x end function elemental complex ( sp ) function cacosh ( x ) complex ( sp ), intent ( in ) :: x end function elemental complex ( dp ) function zacosh ( x ) complex ( dp ), intent ( in ) :: x end function end interface Examples program intrinsics_acosh implicit none print * , acosh ( 1.0 ) end program Result : 0.0 See Also asinh , atanh .","title":"acosh(x)"},{"location":"intrinsics/mathematical/trigonometric/acosh/#acoshx","text":"Inverse hyperbolic cosine function.","title":"acosh(x)"},{"location":"intrinsics/mathematical/trigonometric/acosh/#declaration","text":"","title":"Declaration"},{"location":"intrinsics/mathematical/trigonometric/acosh/#syntax","text":"retval = acosh ( x ) elemental real ( p ) function acosh ( x ) elemental complex ( p ) function acosh ( x )","title":"Syntax"},{"location":"intrinsics/mathematical/trigonometric/acosh/#arguments","text":"x the input value, can be real with value greater than or equal to 1 or of type complex.","title":"Arguments"},{"location":"intrinsics/mathematical/trigonometric/acosh/#return-values","text":"The returned value has the kind of the input value and TYPE may be real or complex.","title":"Return values"},{"location":"intrinsics/mathematical/trigonometric/acosh/#description","text":"acosh(x) computes the inverse hyperbolic cosine function of x . The result type and kind are the same as input value x . If the result is complex, the real part is non-negative, and the imaginary part is expressed in radians and lients in the range \\(-\\pi <= img (acosh(x)) <= \\pi\\) For real values \\(x\\) in the domain \\(x > 1\\) , the inverse hyperbolic cosine satisifies: \\(cosh^{-1}(x) = \\log(x + \\sqrt{(x^2 - 1)})\\) For complex numbers \\(x = x + iy\\) , as well as real values in the domain \\(-\\infty < z <= 1\\) , the call \\(acosh(z)\\) returns complex results.","title":"Description"},{"location":"intrinsics/mathematical/trigonometric/acosh/#types","text":"Supported argument types float, double, complex float, complex double. interface acosh module procedure sacosh , dacosh , cacosh , zacosh end interface contains interface elemental real ( sp ) function sacosh ( x ) real ( sp ), intent ( in ) :: x end function elemental real ( dp ) function dacosh ( x ) real ( dp ), intent ( in ) :: x end function elemental complex ( sp ) function cacosh ( x ) complex ( sp ), intent ( in ) :: x end function elemental complex ( dp ) function zacosh ( x ) complex ( dp ), intent ( in ) :: x end function end interface","title":"Types"},{"location":"intrinsics/mathematical/trigonometric/acosh/#examples","text":"program intrinsics_acosh implicit none print * , acosh ( 1.0 ) end program Result : 0.0","title":"Examples"},{"location":"intrinsics/mathematical/trigonometric/acosh/#see-also","text":"asinh , atanh .","title":"See Also"},{"location":"intrinsics/mathematical/trigonometric/asin/","text":"asin(x) Trigonometric arcsine function. Declaration Syntax retval = asin ( x ) elemental real ( p ) function asin ( x ) elemental complex ( p ) function asin ( x ) Arguments x the input value, can be real or complex; less than or equal to 1. Return values The returned value has the kind of the input value and TYPE may be real or complex. Description asin(x) computes the arcsine of the argument x . The arcsine is the inverse function of the sine function. It is commonly used in trigonometry to find the angle when the lengths of the hypotenuse and the opposite side of a right triangle are known. Types Supported argument types float, double, complex float, complex double. interface asin module procedure sasin , dasin , casin , zasin end interface contains interface elemental real ( sp ) function sasin ( x ) real ( sp ), intent ( in ) :: x end function elemental real ( dp ) function dasin ( x ) real ( dp ), intent ( in ) :: x end function elemental complex ( sp ) function casin ( x ) complex ( sp ), intent ( in ) :: x end function elemental complex ( dp ) function zasin ( x ) complex ( dp ), intent ( in ) :: x end function end interface Examples program intrinsics_asin implicit none integer , parameter :: arg_x = kind ( 0.0 ) real ( arg_x ) :: x1 real :: retval_x real :: arg_x retval_x = asin ( 0.84147098 ) print * , ret_val_x retval_x = asin ( x1 ) print * , ret_val_x end program Result : 0.99999 0.99999 See Also acos , atan .","title":"asin(x)"},{"location":"intrinsics/mathematical/trigonometric/asin/#asinx","text":"Trigonometric arcsine function.","title":"asin(x)"},{"location":"intrinsics/mathematical/trigonometric/asin/#declaration","text":"","title":"Declaration"},{"location":"intrinsics/mathematical/trigonometric/asin/#syntax","text":"retval = asin ( x ) elemental real ( p ) function asin ( x ) elemental complex ( p ) function asin ( x )","title":"Syntax"},{"location":"intrinsics/mathematical/trigonometric/asin/#arguments","text":"x the input value, can be real or complex; less than or equal to 1.","title":"Arguments"},{"location":"intrinsics/mathematical/trigonometric/asin/#return-values","text":"The returned value has the kind of the input value and TYPE may be real or complex.","title":"Return values"},{"location":"intrinsics/mathematical/trigonometric/asin/#description","text":"asin(x) computes the arcsine of the argument x . The arcsine is the inverse function of the sine function. It is commonly used in trigonometry to find the angle when the lengths of the hypotenuse and the opposite side of a right triangle are known.","title":"Description"},{"location":"intrinsics/mathematical/trigonometric/asin/#types","text":"Supported argument types float, double, complex float, complex double. interface asin module procedure sasin , dasin , casin , zasin end interface contains interface elemental real ( sp ) function sasin ( x ) real ( sp ), intent ( in ) :: x end function elemental real ( dp ) function dasin ( x ) real ( dp ), intent ( in ) :: x end function elemental complex ( sp ) function casin ( x ) complex ( sp ), intent ( in ) :: x end function elemental complex ( dp ) function zasin ( x ) complex ( dp ), intent ( in ) :: x end function end interface","title":"Types"},{"location":"intrinsics/mathematical/trigonometric/asin/#examples","text":"program intrinsics_asin implicit none integer , parameter :: arg_x = kind ( 0.0 ) real ( arg_x ) :: x1 real :: retval_x real :: arg_x retval_x = asin ( 0.84147098 ) print * , ret_val_x retval_x = asin ( x1 ) print * , ret_val_x end program Result : 0.99999 0.99999","title":"Examples"},{"location":"intrinsics/mathematical/trigonometric/asin/#see-also","text":"acos , atan .","title":"See Also"},{"location":"intrinsics/mathematical/trigonometric/atan/","text":"atan(x) Trigonometric arctangent (inverse arctangent) function. Declaration Syntax retval = atan ( x ) elemental real ( p ) function atan ( x ) elemental complex ( p ) function atan ( x ) Arguments x the input value, can be real or complex; less than or equal to 1. Return values The returned value has the kind of the input value and TYPE may be real or complex. Description atan(x) computes the arctangent of the argument x . The arc tangent is the inverse function of the arctangent function. It is commonly used in trigonometry to find the angle when the lengths of the opposite side of a right triangle and base are known, i.e., perpendicular and base length. Types Supported argument types float, double, complex float, complex double. interface atan module procedure satan , datan , catan , zatan end interface contains interface elemental real ( sp ) function satan ( x ) real ( sp ), intent ( in ) :: x end function elemental real ( dp ) function datan ( x ) real ( dp ), intent ( in ) :: x end function elemental complex ( sp ) function catan ( x ) complex ( sp ), intent ( in ) :: x end function elemental complex ( dp ) function zatan ( x ) complex ( dp ), intent ( in ) :: x end function end interface Examples program intrinsics_atan implicit none integer , parameter :: arg_x = kind ( 0.0 ) real ( arg_x ) :: x1 real :: retval_x real :: arg_x retval_x = atan ( 0.84147098 ) print * , ret_val_x retval_x = atan ( x1 ) print * , ret_val_x end program Result : 0.699521642 0.699521642 See Also asin , acos .","title":"atan(x)"},{"location":"intrinsics/mathematical/trigonometric/atan/#atanx","text":"Trigonometric arctangent (inverse arctangent) function.","title":"atan(x)"},{"location":"intrinsics/mathematical/trigonometric/atan/#declaration","text":"","title":"Declaration"},{"location":"intrinsics/mathematical/trigonometric/atan/#syntax","text":"retval = atan ( x ) elemental real ( p ) function atan ( x ) elemental complex ( p ) function atan ( x )","title":"Syntax"},{"location":"intrinsics/mathematical/trigonometric/atan/#arguments","text":"x the input value, can be real or complex; less than or equal to 1.","title":"Arguments"},{"location":"intrinsics/mathematical/trigonometric/atan/#return-values","text":"The returned value has the kind of the input value and TYPE may be real or complex.","title":"Return values"},{"location":"intrinsics/mathematical/trigonometric/atan/#description","text":"atan(x) computes the arctangent of the argument x . The arc tangent is the inverse function of the arctangent function. It is commonly used in trigonometry to find the angle when the lengths of the opposite side of a right triangle and base are known, i.e., perpendicular and base length.","title":"Description"},{"location":"intrinsics/mathematical/trigonometric/atan/#types","text":"Supported argument types float, double, complex float, complex double. interface atan module procedure satan , datan , catan , zatan end interface contains interface elemental real ( sp ) function satan ( x ) real ( sp ), intent ( in ) :: x end function elemental real ( dp ) function datan ( x ) real ( dp ), intent ( in ) :: x end function elemental complex ( sp ) function catan ( x ) complex ( sp ), intent ( in ) :: x end function elemental complex ( dp ) function zatan ( x ) complex ( dp ), intent ( in ) :: x end function end interface","title":"Types"},{"location":"intrinsics/mathematical/trigonometric/atan/#examples","text":"program intrinsics_atan implicit none integer , parameter :: arg_x = kind ( 0.0 ) real ( arg_x ) :: x1 real :: retval_x real :: arg_x retval_x = atan ( 0.84147098 ) print * , ret_val_x retval_x = atan ( x1 ) print * , ret_val_x end program Result : 0.699521642 0.699521642","title":"Examples"},{"location":"intrinsics/mathematical/trigonometric/atan/#see-also","text":"asin , acos .","title":"See Also"},{"location":"intrinsics/misc/new_line/","text":"new_line(x) New line character. Declaration Syntax retval = new_line ( x ) function new_line ( c ) Arguments The input parameter x must be of type character. It can be a scalar or an array. Return values The return value is a character of length one with the new line character appended of the same kind as of x . Description new_line(x) returns the new line character. The return value is the ASCII newline character. Types Supported input parameter types is character. function new_line ( c ) result ( r ) character ( len = 1 ), intent ( in ) :: c character ( len = 1 ) :: r end function Examples program intrinsics_new_line implicit none print * , 'This is record 1.' // new_line ( 'A' ) // 'This is record 2.' end program Result: This is record 1.A This is record 2. See Also None.","title":"new_line(x)"},{"location":"intrinsics/misc/new_line/#new_linex","text":"New line character.","title":"new_line(x)"},{"location":"intrinsics/misc/new_line/#declaration","text":"","title":"Declaration"},{"location":"intrinsics/misc/new_line/#syntax","text":"retval = new_line ( x ) function new_line ( c )","title":"Syntax"},{"location":"intrinsics/misc/new_line/#arguments","text":"The input parameter x must be of type character. It can be a scalar or an array.","title":"Arguments"},{"location":"intrinsics/misc/new_line/#return-values","text":"The return value is a character of length one with the new line character appended of the same kind as of x .","title":"Return values"},{"location":"intrinsics/misc/new_line/#description","text":"new_line(x) returns the new line character. The return value is the ASCII newline character.","title":"Description"},{"location":"intrinsics/misc/new_line/#types","text":"Supported input parameter types is character. function new_line ( c ) result ( r ) character ( len = 1 ), intent ( in ) :: c character ( len = 1 ) :: r end function","title":"Types"},{"location":"intrinsics/misc/new_line/#examples","text":"program intrinsics_new_line implicit none print * , 'This is record 1.' // new_line ( 'A' ) // 'This is record 2.' end program Result: This is record 1.A This is record 2.","title":"Examples"},{"location":"intrinsics/misc/new_line/#see-also","text":"None.","title":"See Also"},{"location":"intrinsics/numeric/abs/","text":"abs(x) Absolute value. Declaration Syntax retval = abs ( x ) elemental integer function iabs ( x ) elemental real ( sp ) function abs ( x ) Arguments x the input value, can be integer, real, or complex. Return values The return value is of type and kind same as of x . For complex input value, return value is real. Description abs(x) calculates and returns absolute value of x . Result is calculated using mathematical formula: \\(|x|\\) If x is complex, the result is calculated using mathematical formula: \\(\\sqrt{(x^2 + y^2)}\\) Types Supported argument types are real and integer. interface mod module procedure iabs , i8abs , i16abs , i64abs , sabs , dabs , cabs , zabs end interface contains elemental integer ( i16 ) function i16abs ( x ) integer ( i16 ), intent ( in ) :: x end function elemental integer ( i8 ) function i8abs ( x ) integer ( i8 ), intent ( in ) :: x end function elemental integer function iabs ( x ) integer , intent ( in ) :: x end function elemental integer function i64abs ( x ) integer ( i64 ), intent ( in ) :: x end function elemental real ( sp ) function sabs ( x ) real ( sp ), intent ( in ) :: x end function elemental real ( dp ) function dabs ( x ) real ( dp ), intent ( in ) :: x end function elemental real ( sp ) function cabs ( x ) complex ( sp ), intent ( in ) :: x end function elemental real ( dp ) function zabs ( x ) complex ( dp ), intent ( in ) :: x end function Examples program intrinsics_abs implicit none print * , abs ( 1.5 ) print * , abs ( - 1.5 ) end program Result: 1.5 1.5 See Also ceiling , floor .","title":"abs(x)"},{"location":"intrinsics/numeric/abs/#absx","text":"Absolute value.","title":"abs(x)"},{"location":"intrinsics/numeric/abs/#declaration","text":"","title":"Declaration"},{"location":"intrinsics/numeric/abs/#syntax","text":"retval = abs ( x ) elemental integer function iabs ( x ) elemental real ( sp ) function abs ( x )","title":"Syntax"},{"location":"intrinsics/numeric/abs/#arguments","text":"x the input value, can be integer, real, or complex.","title":"Arguments"},{"location":"intrinsics/numeric/abs/#return-values","text":"The return value is of type and kind same as of x . For complex input value, return value is real.","title":"Return values"},{"location":"intrinsics/numeric/abs/#description","text":"abs(x) calculates and returns absolute value of x . Result is calculated using mathematical formula: \\(|x|\\) If x is complex, the result is calculated using mathematical formula: \\(\\sqrt{(x^2 + y^2)}\\)","title":"Description"},{"location":"intrinsics/numeric/abs/#types","text":"Supported argument types are real and integer. interface mod module procedure iabs , i8abs , i16abs , i64abs , sabs , dabs , cabs , zabs end interface contains elemental integer ( i16 ) function i16abs ( x ) integer ( i16 ), intent ( in ) :: x end function elemental integer ( i8 ) function i8abs ( x ) integer ( i8 ), intent ( in ) :: x end function elemental integer function iabs ( x ) integer , intent ( in ) :: x end function elemental integer function i64abs ( x ) integer ( i64 ), intent ( in ) :: x end function elemental real ( sp ) function sabs ( x ) real ( sp ), intent ( in ) :: x end function elemental real ( dp ) function dabs ( x ) real ( dp ), intent ( in ) :: x end function elemental real ( sp ) function cabs ( x ) complex ( sp ), intent ( in ) :: x end function elemental real ( dp ) function zabs ( x ) complex ( dp ), intent ( in ) :: x end function","title":"Types"},{"location":"intrinsics/numeric/abs/#examples","text":"program intrinsics_abs implicit none print * , abs ( 1.5 ) print * , abs ( - 1.5 ) end program Result: 1.5 1.5","title":"Examples"},{"location":"intrinsics/numeric/abs/#see-also","text":"ceiling , floor .","title":"See Also"},{"location":"intrinsics/numeric/aimag/","text":"aimag(x) Imaginary part of complex number. Declaration Syntax retval = aimag ( x ) elemental real ( sp ) function aimag ( x ) elemental real ( dp ) function aimag ( x ) Arguments x the input value must be of complex type. Return values The return value is imaginary part of type real and kind same as of x . Description aimag(x) returns the imaginary part of the input complex argument x . For x complex input value, the result is calculated using mathematical formula: \\(x + iy\\) \\(i\\) the imaginary part is the result. Types Supported argument types are complex. interface aimag module procedure saimag , daimag end interface contains elemental real ( sp ) function saimag ( x ) complex ( sp ), intent ( in ) :: x end function elemental real ( dp ) function daimag ( x ) complex ( dp ), intent ( in ) :: x end function Examples program intrinsics_aimag implicit none print * , aimag ( 1.0 , - 3.0 ) end program Result: -3.0 See Also ceiling , floor .","title":"aimag(x)"},{"location":"intrinsics/numeric/aimag/#aimagx","text":"Imaginary part of complex number.","title":"aimag(x)"},{"location":"intrinsics/numeric/aimag/#declaration","text":"","title":"Declaration"},{"location":"intrinsics/numeric/aimag/#syntax","text":"retval = aimag ( x ) elemental real ( sp ) function aimag ( x ) elemental real ( dp ) function aimag ( x )","title":"Syntax"},{"location":"intrinsics/numeric/aimag/#arguments","text":"x the input value must be of complex type.","title":"Arguments"},{"location":"intrinsics/numeric/aimag/#return-values","text":"The return value is imaginary part of type real and kind same as of x .","title":"Return values"},{"location":"intrinsics/numeric/aimag/#description","text":"aimag(x) returns the imaginary part of the input complex argument x . For x complex input value, the result is calculated using mathematical formula: \\(x + iy\\) \\(i\\) the imaginary part is the result.","title":"Description"},{"location":"intrinsics/numeric/aimag/#types","text":"Supported argument types are complex. interface aimag module procedure saimag , daimag end interface contains elemental real ( sp ) function saimag ( x ) complex ( sp ), intent ( in ) :: x end function elemental real ( dp ) function daimag ( x ) complex ( dp ), intent ( in ) :: x end function","title":"Types"},{"location":"intrinsics/numeric/aimag/#examples","text":"program intrinsics_aimag implicit none print * , aimag ( 1.0 , - 3.0 ) end program Result: -3.0","title":"Examples"},{"location":"intrinsics/numeric/aimag/#see-also","text":"ceiling , floor .","title":"See Also"},{"location":"intrinsics/numeric/aint/","text":"aint(x, [kind]) Truncate to a whole number. Declaration Syntax retval = aint ( x , [ kind ]) elemental real function aint ( x , [ kind ]) Arguments x the input value must be of type real. kind the optional input parameter initialises the kind of the result. Return values The return value is of type integer(kind) if kind is passed as input parameter. If not, default kind real is returned. The return value is equal to or nearest largest whole number greater than or equal to x not exceeding its magnitude. Description aint(x) returns the nearest largest whole number greater than or equal to x not exceeding input value's magnitude. The optional parameter kind specifies the kind of the result. Types Supported argument types is real. Examples program intrinsics_aint print * , aint ( 3.1 ) print * , floor ( - 3.1 ) end program Result: 3 -3 See Also ceiling , mod .","title":"aint(x, [kind])"},{"location":"intrinsics/numeric/aint/#aintx-kind","text":"Truncate to a whole number.","title":"aint(x, [kind])"},{"location":"intrinsics/numeric/aint/#declaration","text":"","title":"Declaration"},{"location":"intrinsics/numeric/aint/#syntax","text":"retval = aint ( x , [ kind ]) elemental real function aint ( x , [ kind ])","title":"Syntax"},{"location":"intrinsics/numeric/aint/#arguments","text":"x the input value must be of type real. kind the optional input parameter initialises the kind of the result.","title":"Arguments"},{"location":"intrinsics/numeric/aint/#return-values","text":"The return value is of type integer(kind) if kind is passed as input parameter. If not, default kind real is returned. The return value is equal to or nearest largest whole number greater than or equal to x not exceeding its magnitude.","title":"Return values"},{"location":"intrinsics/numeric/aint/#description","text":"aint(x) returns the nearest largest whole number greater than or equal to x not exceeding input value's magnitude. The optional parameter kind specifies the kind of the result.","title":"Description"},{"location":"intrinsics/numeric/aint/#types","text":"Supported argument types is real.","title":"Types"},{"location":"intrinsics/numeric/aint/#examples","text":"program intrinsics_aint print * , aint ( 3.1 ) print * , floor ( - 3.1 ) end program Result: 3 -3","title":"Examples"},{"location":"intrinsics/numeric/aint/#see-also","text":"ceiling , mod .","title":"See Also"},{"location":"intrinsics/numeric/ceiling/","text":"ceiling(x) Integer ceiling function Declaration Syntax retval = ceiling ( x ) elemental integer function ceiling ( x ) Arguments The input value x may be of type real or integer. Return values The return value is of type integer and nearest greater integer. Description ceiling(x) returns the least integer greater than or equal to x . Types Supported input parameter types are integer and real. interface ceiling module procedure sceiling , dceiling end interface contains elemental integer function sceiling ( x ) real ( sp ), intent ( in ) :: x end function elemental integer function dceiling ( x ) real ( dp ), intent ( in ) :: x end function Examples program intrinsics_ceiling implicit none real :: x = 6 3.29 print * , ceiling ( x ) print * , ceiling ( - 6 3.29 ) end program Result: 64 -63 See Also floor , mod .","title":"ceiling(x)"},{"location":"intrinsics/numeric/ceiling/#ceilingx","text":"Integer ceiling function","title":"ceiling(x)"},{"location":"intrinsics/numeric/ceiling/#declaration","text":"","title":"Declaration"},{"location":"intrinsics/numeric/ceiling/#syntax","text":"retval = ceiling ( x ) elemental integer function ceiling ( x )","title":"Syntax"},{"location":"intrinsics/numeric/ceiling/#arguments","text":"The input value x may be of type real or integer.","title":"Arguments"},{"location":"intrinsics/numeric/ceiling/#return-values","text":"The return value is of type integer and nearest greater integer.","title":"Return values"},{"location":"intrinsics/numeric/ceiling/#description","text":"ceiling(x) returns the least integer greater than or equal to x .","title":"Description"},{"location":"intrinsics/numeric/ceiling/#types","text":"Supported input parameter types are integer and real. interface ceiling module procedure sceiling , dceiling end interface contains elemental integer function sceiling ( x ) real ( sp ), intent ( in ) :: x end function elemental integer function dceiling ( x ) real ( dp ), intent ( in ) :: x end function","title":"Types"},{"location":"intrinsics/numeric/ceiling/#examples","text":"program intrinsics_ceiling implicit none real :: x = 6 3.29 print * , ceiling ( x ) print * , ceiling ( - 6 3.29 ) end program Result: 64 -63","title":"Examples"},{"location":"intrinsics/numeric/ceiling/#see-also","text":"floor , mod .","title":"See Also"},{"location":"intrinsics/numeric/floor/","text":"floor(x, kind) Integer floor function. Declaration Syntax retval = floor ( x ) elemental integer function floor ( x , kind ) Arguments x the input value must be of type real. kind the optional input parameter must be a scalar integer constant expression. Return values The return value is of type integer(kind) if kind is passed as input parameter. If not, default kind integer is returned. The return value is equal to or nearest greatest integer less than or equal to x . Description floor(x) returns the greatest integer less than or equal to x. It returns an integer value unless spefically specified using second optional paramter. Types Supported argument types is real. interface floor module procedure sfloor_i32 , sfloor_i64 , dfloor_i32 , dfloor_i64 end interface contains elemental integer ( i32 ) function sfloor_i32 ( x , kind ) real ( sp ), intent ( in ) :: x integer ( i32 ), intent ( in ) :: kind end function elemental integer ( i64 ) function sfloor_i64 ( x , kind ) real ( sp ), intent ( in ) :: x integer ( i64 ), intent ( in ) :: kind end function elemental integer ( i32 ) function dfloor_i32 ( x , kind ) real ( dp ), intent ( in ) :: x integer ( i32 ), intent ( in ) :: kind end function elemental integer ( i64 ) function dfloor_i64 ( x , kind ) real ( dp ), intent ( in ) :: x integer ( i64 ), intent ( in ) :: kind end function Examples program intrinsics_floor implicit none real , parameter :: x = 3.1 print * , floor ( x ) print * , floor ( - 3.1 ) end program Result: 3 -4 See Also ceiling , mod .","title":"floor(x, kind)"},{"location":"intrinsics/numeric/floor/#floorx-kind","text":"Integer floor function.","title":"floor(x, kind)"},{"location":"intrinsics/numeric/floor/#declaration","text":"","title":"Declaration"},{"location":"intrinsics/numeric/floor/#syntax","text":"retval = floor ( x ) elemental integer function floor ( x , kind )","title":"Syntax"},{"location":"intrinsics/numeric/floor/#arguments","text":"x the input value must be of type real. kind the optional input parameter must be a scalar integer constant expression.","title":"Arguments"},{"location":"intrinsics/numeric/floor/#return-values","text":"The return value is of type integer(kind) if kind is passed as input parameter. If not, default kind integer is returned. The return value is equal to or nearest greatest integer less than or equal to x .","title":"Return values"},{"location":"intrinsics/numeric/floor/#description","text":"floor(x) returns the greatest integer less than or equal to x. It returns an integer value unless spefically specified using second optional paramter.","title":"Description"},{"location":"intrinsics/numeric/floor/#types","text":"Supported argument types is real. interface floor module procedure sfloor_i32 , sfloor_i64 , dfloor_i32 , dfloor_i64 end interface contains elemental integer ( i32 ) function sfloor_i32 ( x , kind ) real ( sp ), intent ( in ) :: x integer ( i32 ), intent ( in ) :: kind end function elemental integer ( i64 ) function sfloor_i64 ( x , kind ) real ( sp ), intent ( in ) :: x integer ( i64 ), intent ( in ) :: kind end function elemental integer ( i32 ) function dfloor_i32 ( x , kind ) real ( dp ), intent ( in ) :: x integer ( i32 ), intent ( in ) :: kind end function elemental integer ( i64 ) function dfloor_i64 ( x , kind ) real ( dp ), intent ( in ) :: x integer ( i64 ), intent ( in ) :: kind end function","title":"Types"},{"location":"intrinsics/numeric/floor/#examples","text":"program intrinsics_floor implicit none real , parameter :: x = 3.1 print * , floor ( x ) print * , floor ( - 3.1 ) end program Result: 3 -4","title":"Examples"},{"location":"intrinsics/numeric/floor/#see-also","text":"ceiling , mod .","title":"See Also"},{"location":"intrinsics/numeric/mod/","text":"mod(x, y) Modulus or remainder function. Declaration Syntax retval = mod ( x , y ) elemental integer function imod ( x , y ) elemental real ( sp ) function mod ( x , y ) Arguments x the input value, can be integer or real. y second input parameter should be same type and kind as x and not equal to 0. Return values The return value is of type and kind same as of x . The result is calculated using mathematical modulo or remainder as: x - INT (x / y) * y . If y is 0, the result is undefined like any integer value / 0 . Description mod(x, y) calculates and returns modulo or remainder when x is divided by y . The result is calculated using x - INT(x / y) * y i.e., result is remainder when first argument is mathematically divided by second argument. The return value should be less than y . Types Supported argument types are real and integer. interface mod module procedure i8mod , i16mod , imod , i64mod , smod , dmod end interface contains elemental integer ( i16 ) function i16mod ( x , y ) integer ( i16 ), intent ( in ) :: x , y end function elemental integer ( i8 ) function i8mod ( x , y ) integer ( i8 ), intent ( in ) :: x , y end function elemental integer function imod ( x , y ) integer , intent ( in ) :: x , y end function elemental integer function i64mod ( x , y ) integer ( i64 ), intent ( in ) :: x , y end function elemental real ( sp ) function smod ( x , y ) real ( sp ), intent ( in ) :: x , y end function elemental real ( dp ) function dmod ( x , y ) real ( dp ), intent ( in ) :: x , y end function Examples program intrinsics_mod implicit none print * , mod ( - 5 , 3 ) end program Result: -2 See Also ceiling , floor .","title":"mod(x, y)"},{"location":"intrinsics/numeric/mod/#modx-y","text":"Modulus or remainder function.","title":"mod(x, y)"},{"location":"intrinsics/numeric/mod/#declaration","text":"","title":"Declaration"},{"location":"intrinsics/numeric/mod/#syntax","text":"retval = mod ( x , y ) elemental integer function imod ( x , y ) elemental real ( sp ) function mod ( x , y )","title":"Syntax"},{"location":"intrinsics/numeric/mod/#arguments","text":"x the input value, can be integer or real. y second input parameter should be same type and kind as x and not equal to 0.","title":"Arguments"},{"location":"intrinsics/numeric/mod/#return-values","text":"The return value is of type and kind same as of x . The result is calculated using mathematical modulo or remainder as: x - INT (x / y) * y . If y is 0, the result is undefined like any integer value / 0 .","title":"Return values"},{"location":"intrinsics/numeric/mod/#description","text":"mod(x, y) calculates and returns modulo or remainder when x is divided by y . The result is calculated using x - INT(x / y) * y i.e., result is remainder when first argument is mathematically divided by second argument. The return value should be less than y .","title":"Description"},{"location":"intrinsics/numeric/mod/#types","text":"Supported argument types are real and integer. interface mod module procedure i8mod , i16mod , imod , i64mod , smod , dmod end interface contains elemental integer ( i16 ) function i16mod ( x , y ) integer ( i16 ), intent ( in ) :: x , y end function elemental integer ( i8 ) function i8mod ( x , y ) integer ( i8 ), intent ( in ) :: x , y end function elemental integer function imod ( x , y ) integer , intent ( in ) :: x , y end function elemental integer function i64mod ( x , y ) integer ( i64 ), intent ( in ) :: x , y end function elemental real ( sp ) function smod ( x , y ) real ( sp ), intent ( in ) :: x , y end function elemental real ( dp ) function dmod ( x , y ) real ( dp ), intent ( in ) :: x , y end function","title":"Types"},{"location":"intrinsics/numeric/mod/#examples","text":"program intrinsics_mod implicit none print * , mod ( - 5 , 3 ) end program Result: -2","title":"Examples"},{"location":"intrinsics/numeric/mod/#see-also","text":"ceiling , floor .","title":"See Also"}]}