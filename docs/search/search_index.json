{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"LFortran Documentation LFortran is a modern open-source (BSD licensed) interactive Fortran compiler built on top of LLVM. It can execute user's code interactively to allow exploratory work (much like Python, MATLAB or Julia) as well as compile to binaries with the goal to run user's code on modern architectures such as multi-core CPUs and GPUs. Main repository: https://gitlab.com/lfortran/lfortran Try online using Binder: Feature Highlights LFortran is in development, there are features that work today, and there are features that are being implemented. Works today Interactive, Jupyter support LFortran can be used from Jupyter as a Fortran kernel, allowing a Python/Julia style rapid prototyping and exploratory workflow (see the static or interactive example notebook). Or it can be used from the command-line in an interactive prompt (REPL). Clean, modular design, usable as a library LFortran is structured around two independent modules, AST and ASR, both of which are standalone (completely independent of the rest of LFortran) and users are encouraged to use them independently for other applications and build tools on top. See the Design and Developer Tutorial documents for more details. Interoperation with GFortran LFortran can parse GFortran module files into an ASR and generate a Fortran wrapper that can be compiled with any Fortran compiler and linked with the original GFortran compiled module. Create executables It can create executables just like other Fortran compilers. Runs on Linux, Mac and Windows All three platforms are regularly tested by our CI. Planned These features are under development, there is a link to the corresponding issue so that you can track the progress by following it. Native interoperation with other languages (and other Fortran compilers) It can automatically call code written in other languages (such as C or Python) just by using the use statement, see #44 . It understands other Fortran compilers module files (one can just \"use\" them) and their ABI to link correctly (GFortran is supported, other compilers are planned, see #56 ), which allows to use LFortran with production codes today. Modern hardware support Thanks to LLVM, the goal of LFortran is to run on modern hardware and take advantage of native Fortran language constructs (such as do concurrent ) to run on multi-core CPUs and GPUs, see #57 . Full Fortran 2018 support Currently only a subset of Fortran is implemented, but the goal is to have a full implementation of the latest Fortran 2018 standard, see #58 . Please vote on issues in our issue tracker that you want us to prioritize (feel free to create new ones if we are missing anything). Roadmap Here is our roadmap how to get all the planned features above implemented: Port code generation to use ASR and pass all the current tests ( #74 ). Remove the old code generation and old semantics, that used to annotate the AST tree, which was messy. Get GFortran module files working with use module, both assumed-size and assumed-shape arrays ( #52 ). This will allow right away to use production codes with LFortran. Do these at the same time: a) Implement more Fortran features, until eventually full Fortran 2018 is supported ( #58 ). b) Gradually move to C++ for robustness and speed ( #70 ). The Python API will not change (or only minimally), so the user experience from Python will not change. c) Implement all the other cool features: use module for C and Python and automatic wrappers ( #44 ), modern hardware support ( #57 ), generating an older standard of Fortran ( #72 ), Fortran doctest feature ( #73 ), SymPy integration ( #71 ), language service for IDEs ( #12 ), and other ideas ( #29 ). The step 1. is an internal refactoring that will not take long. The step 2. will allow LFortran to be used interactively with production codes right away (the production code will get compiled with GFortran, then one \"uses\" any module in LFortran and functions/subroutines can be interactively called, the module itself can use any GFortran supported feature, but the API must fit into the subset that LFortran understands --- for large number of applications simple functions/subroutines with array arguments are enough). This will make LFortran usable for first users and one can always use GFortran temporarily until LFortran supports the given feature. We expect to be finished with the step 2. by the end of summer 2019, hopefully sooner. Finally the step 3. will improve LFortran overall, allowing the first users to contribute back, growing the community and making LFortran gradually useful for more and more people.","title":"Home"},{"location":"#lfortran-documentation","text":"LFortran is a modern open-source (BSD licensed) interactive Fortran compiler built on top of LLVM. It can execute user's code interactively to allow exploratory work (much like Python, MATLAB or Julia) as well as compile to binaries with the goal to run user's code on modern architectures such as multi-core CPUs and GPUs. Main repository: https://gitlab.com/lfortran/lfortran Try online using Binder:","title":"LFortran Documentation"},{"location":"#feature-highlights","text":"LFortran is in development, there are features that work today, and there are features that are being implemented.","title":"Feature Highlights"},{"location":"#works-today","text":"Interactive, Jupyter support LFortran can be used from Jupyter as a Fortran kernel, allowing a Python/Julia style rapid prototyping and exploratory workflow (see the static or interactive example notebook). Or it can be used from the command-line in an interactive prompt (REPL). Clean, modular design, usable as a library LFortran is structured around two independent modules, AST and ASR, both of which are standalone (completely independent of the rest of LFortran) and users are encouraged to use them independently for other applications and build tools on top. See the Design and Developer Tutorial documents for more details. Interoperation with GFortran LFortran can parse GFortran module files into an ASR and generate a Fortran wrapper that can be compiled with any Fortran compiler and linked with the original GFortran compiled module. Create executables It can create executables just like other Fortran compilers. Runs on Linux, Mac and Windows All three platforms are regularly tested by our CI.","title":"Works today"},{"location":"#planned","text":"These features are under development, there is a link to the corresponding issue so that you can track the progress by following it. Native interoperation with other languages (and other Fortran compilers) It can automatically call code written in other languages (such as C or Python) just by using the use statement, see #44 . It understands other Fortran compilers module files (one can just \"use\" them) and their ABI to link correctly (GFortran is supported, other compilers are planned, see #56 ), which allows to use LFortran with production codes today. Modern hardware support Thanks to LLVM, the goal of LFortran is to run on modern hardware and take advantage of native Fortran language constructs (such as do concurrent ) to run on multi-core CPUs and GPUs, see #57 . Full Fortran 2018 support Currently only a subset of Fortran is implemented, but the goal is to have a full implementation of the latest Fortran 2018 standard, see #58 . Please vote on issues in our issue tracker that you want us to prioritize (feel free to create new ones if we are missing anything).","title":"Planned"},{"location":"#roadmap","text":"Here is our roadmap how to get all the planned features above implemented: Port code generation to use ASR and pass all the current tests ( #74 ). Remove the old code generation and old semantics, that used to annotate the AST tree, which was messy. Get GFortran module files working with use module, both assumed-size and assumed-shape arrays ( #52 ). This will allow right away to use production codes with LFortran. Do these at the same time: a) Implement more Fortran features, until eventually full Fortran 2018 is supported ( #58 ). b) Gradually move to C++ for robustness and speed ( #70 ). The Python API will not change (or only minimally), so the user experience from Python will not change. c) Implement all the other cool features: use module for C and Python and automatic wrappers ( #44 ), modern hardware support ( #57 ), generating an older standard of Fortran ( #72 ), Fortran doctest feature ( #73 ), SymPy integration ( #71 ), language service for IDEs ( #12 ), and other ideas ( #29 ). The step 1. is an internal refactoring that will not take long. The step 2. will allow LFortran to be used interactively with production codes right away (the production code will get compiled with GFortran, then one \"uses\" any module in LFortran and functions/subroutines can be interactively called, the module itself can use any GFortran supported feature, but the API must fit into the subset that LFortran understands --- for large number of applications simple functions/subroutines with array arguments are enough). This will make LFortran usable for first users and one can always use GFortran temporarily until LFortran supports the given feature. We expect to be finished with the step 2. by the end of summer 2019, hopefully sooner. Finally the step 3. will improve LFortran overall, allowing the first users to contribute back, growing the community and making LFortran gradually useful for more and more people.","title":"Roadmap"},{"location":"design/","text":"LFortran Design High Level Overview LFortran is structured around two independent modules, AST and ASR, both of which are standalone (completely independent of the rest of LFortran) and users are encouraged to use them independently for other applications and build tools on top: Abstract Syntax Tree (AST), module lfortran.ast : Represents any Fortran source code, strictly based on syntax, no semantic is included. The AST module can convert itself to Fortran source code. Abstract Semantic Representation (ASR), module lfortran.asr : Represents a valid Fortran source code, all semantic is included. Invalid Fortran code is not allowed (an error will be given). The ASR module can convert itself to an AST. The LFortran compiler is then composed of the following independent stages: Parsing: converts Fotran source code to an AST Semantic: converts an AST to an ASR High level optimizations: optimize ASR to a possibly faster/simpler ASR (things like inlining functions, eliminating redundant expressions or statements, etc.) LLVM IR code generation and lower level optimizations: converts an ASR to an LLVM IR. This stage also does all other optimizations that do not produce an ASR, but still make sense to do before passing to LLVM IR. Machine code generation: LLVM then does all its optimizations and generates machine code (such as a binary executable, a library, an object file, or it is loaded and executed using JIT as part of the interactive LFortran session or in a Jupyter kernel). LFortran is structured as a library, and so one can for example use the parser to obtain an AST and do something with it, or one can then use the semantic analyzer to obtain ASR and do something with it. One can generate the ASR directly (e.g., from SymPy) and then either convert to AST and to a Fortran source code, or use LFortran to compile it to machine code directly. In other words, one can use LFortran to easily convert between the three equivalent representations: Fortran source code Abstract Syntax Tree (AST) Abstract Semantic Representation (ASR) They are all equivalent in the following sense: Any ASR can always be converted to an equivalent AST Any AST can always be converted to an equivalent Fortran source code Any Fortran source code can always be either converted to an equivalent AST or one gets a syntax error Any AST can always be either converted to an equivalent ASR or one gets a semantic error So when a conversion can be done, they are equivalent, and the conversion can always be done unless the code is invalid. ASR Design Details The ASR is designed to have the following features: ASR is still semantically equivalent to the original Fortran code (it did not lose any semantic information). ASR can be converted to AST, and AST to Fortran source code which is functionally equivalent to the original. ASR is as simple as possible: it does not contain any information that could not be inferred from ASR. The ASR C++ classes (down the road) are designed similarly to SymEngine: they are constructed once and after that they are immutable. The constructor checks in Debug more that all the requirements are met (e.g., that all Variables in a Function have a dummy argument set, that explicit-shape arrays are not allocatable and all other Fortran requirements to make it a valid code), but in Release mode it quickly constructs the class without checks. Then there are builder classes that construct the ASR C++ classes to meet requirements (checked in Debug mode) and the builder gives an error message if a code is not a valid Fortran code, and if it doesn't give an error message, then the ASR C++ classes are constructed correctly. Thus by construction, the ASR classes always contain valid Fortran code and the rest of LFortran can depend on it. Note: Information that is lost when parsing source to AST: whitespace, multiline/single line if statement distinction, case sensitivity of keywords. Information that is lost when going from AST to ASR: detailed syntax how variables were defined and the order of type attributes (whether array dimension is using the dimension attribute, or parentheses at the variable; or how many variables there are per declaration line or their order), as ASR only represents the aggregated type information in the symbol table. Note: ASR is the simplest way to generate Fortran code, as one does not have to worry about the detailed syntax (as in AST) about how and where things are declared. One specifies the symbol table for a module, then for each symbol (functions, global variables, types, ...) one specifies the local variables and if this is an interface then one needs to specify where one can find an implementation, otherwise a body is supplied with statements, those nodes are almost the same as in AST, except that each variable is just a reference to a symbol in the symbol table (so by construction one cannot have undefined variables). The symbol table for each node such as Function or Module also references its parent (for example a function references a module, a module references the global scope). The ASR can be directly converted to an AST without gathering any other information. And the AST directly to Fortran source code. The ASR is always representing a semantically valid Fortran code. This is enforced by checks in the ASR C++ constructors (in Debug build). When an ASR is used, one can assume it is valid. Fortran 2008 Fortran 2008 standard chapter 2 \"Fortran concepts\" specifies that Fortran code is a collection of program units (either all in one file, or in separate files), where each program unit is one of: main program module or submodule function or subroutine Note: It can also be a block data program unit, that is used to provide initial values for data objects in named common blocks , but we do not recommend the use of common blocks (use modules instead). LFortran Extension We extend the Fortran language by introducing a global scope , which is not only the list of program units (as in F2008) but can also include statements, declarations, use statements and expressions. We define global scope as a collection of the following items: main program module or submodule function or subroutine use statement declaration statement expression In addition, if a variable is not defined in an assignment statement (such as x = 5+3 ) then the type of the variable is inferred from the right hand side (e.g., x in x = 5+3 would be of type integer , and y in y = 5._dp would be of type real(dp) ). This rule only applies at the top level of global scope . Types must be fully specified inside main programs, modules, functions and subroutines, just like in F2008. The global scope has its own symbol table. The main program and module/submodule do not see any symbols from this symbol table. But functions, subroutines, statements and expressions at the top level of global scope use and operate on this symbol table. The global scope has the following symbols predefined in the symbol table: the usual standard set of Fortran functions (such as size , sin , cos , ...) the dp double precision symbol, so that one can use 5._dp for double precision. Each item in the global scope is interpreted as follows: main program is compiled into an executable with the same name and executed; modules, functions and subroutines are compiled and loaded; use statement and declaration adds those symbols with the proper type into the global scope symbol table, but do not generate any code; statement is wrapped into an anonymous subroutine with no arguments, compiled, loaded and executed; expression is wrapped into an anonymous function with no arguments returning the expression, compiled, loaded, executed and the return value is returned to the user. The global scope is always interpreted, item by item, per the previous paragraph. It is meant to allow interactive usage, experimentations and writing simple scripts. Code in global scope must be interpreted using lfortran . For more complex (production) code it is recommended to turn it into modules and programs (by wrapping loose statements into subroutines or functions and by adding type declarations) and compile it with lfortran or any other Fortran compiler. Here are some examples of valid code in global scope : Example 1 a = 5 print *, a Example 2 a = 5 subroutine p() print *, a end subroutine call p() Example 3 module a implicit none integer :: i end module use a, only: i i = 5 Example 4 x = [1, 2, 3] y = [1, 2, 1] call plot(x, y, \"o-\") Design Considerations The LFortran extension of Fortran was chosen in a way so as to minimize the number of changes. In particular, only the top level of the global scope has relaxed some of the Fortran rules (such as making specifying types optional) so as to allow simple and quick interactive usage, but inside functions, subroutines, modules or programs this relaxation does not apply. The number of changes were kept to minimum in order to make it straightforward to turn code at global scope into standard compliant Fortran code using programs and modules, so that it can be compiled by any Fortran compiler.","title":"LFortran Design"},{"location":"design/#lfortran-design","text":"","title":"LFortran Design"},{"location":"design/#high-level-overview","text":"LFortran is structured around two independent modules, AST and ASR, both of which are standalone (completely independent of the rest of LFortran) and users are encouraged to use them independently for other applications and build tools on top: Abstract Syntax Tree (AST), module lfortran.ast : Represents any Fortran source code, strictly based on syntax, no semantic is included. The AST module can convert itself to Fortran source code. Abstract Semantic Representation (ASR), module lfortran.asr : Represents a valid Fortran source code, all semantic is included. Invalid Fortran code is not allowed (an error will be given). The ASR module can convert itself to an AST. The LFortran compiler is then composed of the following independent stages: Parsing: converts Fotran source code to an AST Semantic: converts an AST to an ASR High level optimizations: optimize ASR to a possibly faster/simpler ASR (things like inlining functions, eliminating redundant expressions or statements, etc.) LLVM IR code generation and lower level optimizations: converts an ASR to an LLVM IR. This stage also does all other optimizations that do not produce an ASR, but still make sense to do before passing to LLVM IR. Machine code generation: LLVM then does all its optimizations and generates machine code (such as a binary executable, a library, an object file, or it is loaded and executed using JIT as part of the interactive LFortran session or in a Jupyter kernel). LFortran is structured as a library, and so one can for example use the parser to obtain an AST and do something with it, or one can then use the semantic analyzer to obtain ASR and do something with it. One can generate the ASR directly (e.g., from SymPy) and then either convert to AST and to a Fortran source code, or use LFortran to compile it to machine code directly. In other words, one can use LFortran to easily convert between the three equivalent representations: Fortran source code Abstract Syntax Tree (AST) Abstract Semantic Representation (ASR) They are all equivalent in the following sense: Any ASR can always be converted to an equivalent AST Any AST can always be converted to an equivalent Fortran source code Any Fortran source code can always be either converted to an equivalent AST or one gets a syntax error Any AST can always be either converted to an equivalent ASR or one gets a semantic error So when a conversion can be done, they are equivalent, and the conversion can always be done unless the code is invalid.","title":"High Level Overview"},{"location":"design/#asr-design-details","text":"The ASR is designed to have the following features: ASR is still semantically equivalent to the original Fortran code (it did not lose any semantic information). ASR can be converted to AST, and AST to Fortran source code which is functionally equivalent to the original. ASR is as simple as possible: it does not contain any information that could not be inferred from ASR. The ASR C++ classes (down the road) are designed similarly to SymEngine: they are constructed once and after that they are immutable. The constructor checks in Debug more that all the requirements are met (e.g., that all Variables in a Function have a dummy argument set, that explicit-shape arrays are not allocatable and all other Fortran requirements to make it a valid code), but in Release mode it quickly constructs the class without checks. Then there are builder classes that construct the ASR C++ classes to meet requirements (checked in Debug mode) and the builder gives an error message if a code is not a valid Fortran code, and if it doesn't give an error message, then the ASR C++ classes are constructed correctly. Thus by construction, the ASR classes always contain valid Fortran code and the rest of LFortran can depend on it. Note: Information that is lost when parsing source to AST: whitespace, multiline/single line if statement distinction, case sensitivity of keywords. Information that is lost when going from AST to ASR: detailed syntax how variables were defined and the order of type attributes (whether array dimension is using the dimension attribute, or parentheses at the variable; or how many variables there are per declaration line or their order), as ASR only represents the aggregated type information in the symbol table. Note: ASR is the simplest way to generate Fortran code, as one does not have to worry about the detailed syntax (as in AST) about how and where things are declared. One specifies the symbol table for a module, then for each symbol (functions, global variables, types, ...) one specifies the local variables and if this is an interface then one needs to specify where one can find an implementation, otherwise a body is supplied with statements, those nodes are almost the same as in AST, except that each variable is just a reference to a symbol in the symbol table (so by construction one cannot have undefined variables). The symbol table for each node such as Function or Module also references its parent (for example a function references a module, a module references the global scope). The ASR can be directly converted to an AST without gathering any other information. And the AST directly to Fortran source code. The ASR is always representing a semantically valid Fortran code. This is enforced by checks in the ASR C++ constructors (in Debug build). When an ASR is used, one can assume it is valid.","title":"ASR Design Details"},{"location":"design/#fortran-2008","text":"Fortran 2008 standard chapter 2 \"Fortran concepts\" specifies that Fortran code is a collection of program units (either all in one file, or in separate files), where each program unit is one of: main program module or submodule function or subroutine Note: It can also be a block data program unit, that is used to provide initial values for data objects in named common blocks , but we do not recommend the use of common blocks (use modules instead).","title":"Fortran 2008"},{"location":"design/#lfortran-extension","text":"We extend the Fortran language by introducing a global scope , which is not only the list of program units (as in F2008) but can also include statements, declarations, use statements and expressions. We define global scope as a collection of the following items: main program module or submodule function or subroutine use statement declaration statement expression In addition, if a variable is not defined in an assignment statement (such as x = 5+3 ) then the type of the variable is inferred from the right hand side (e.g., x in x = 5+3 would be of type integer , and y in y = 5._dp would be of type real(dp) ). This rule only applies at the top level of global scope . Types must be fully specified inside main programs, modules, functions and subroutines, just like in F2008. The global scope has its own symbol table. The main program and module/submodule do not see any symbols from this symbol table. But functions, subroutines, statements and expressions at the top level of global scope use and operate on this symbol table. The global scope has the following symbols predefined in the symbol table: the usual standard set of Fortran functions (such as size , sin , cos , ...) the dp double precision symbol, so that one can use 5._dp for double precision. Each item in the global scope is interpreted as follows: main program is compiled into an executable with the same name and executed; modules, functions and subroutines are compiled and loaded; use statement and declaration adds those symbols with the proper type into the global scope symbol table, but do not generate any code; statement is wrapped into an anonymous subroutine with no arguments, compiled, loaded and executed; expression is wrapped into an anonymous function with no arguments returning the expression, compiled, loaded, executed and the return value is returned to the user. The global scope is always interpreted, item by item, per the previous paragraph. It is meant to allow interactive usage, experimentations and writing simple scripts. Code in global scope must be interpreted using lfortran . For more complex (production) code it is recommended to turn it into modules and programs (by wrapping loose statements into subroutines or functions and by adding type declarations) and compile it with lfortran or any other Fortran compiler. Here are some examples of valid code in global scope :","title":"LFortran Extension"},{"location":"design/#example-1","text":"a = 5 print *, a","title":"Example 1"},{"location":"design/#example-2","text":"a = 5 subroutine p() print *, a end subroutine call p()","title":"Example 2"},{"location":"design/#example-3","text":"module a implicit none integer :: i end module use a, only: i i = 5","title":"Example 3"},{"location":"design/#example-4","text":"x = [1, 2, 3] y = [1, 2, 1] call plot(x, y, \"o-\")","title":"Example 4"},{"location":"design/#design-considerations","text":"The LFortran extension of Fortran was chosen in a way so as to minimize the number of changes. In particular, only the top level of the global scope has relaxed some of the Fortran rules (such as making specifying types optional) so as to allow simple and quick interactive usage, but inside functions, subroutines, modules or programs this relaxation does not apply. The number of changes were kept to minimum in order to make it straightforward to turn code at global scope into standard compliant Fortran code using programs and modules, so that it can be compiled by any Fortran compiler.","title":"Design Considerations"},{"location":"developer_tutorial/","text":"Developer Tutorial This is a tutorial for anybody who wants to either develop LFortran or build tools on top. Introduction LFortran is structured around two independent modules, AST and ASR, both of which are standalone (completely independent of the rest of LFortran) and users are encouraged to use them independently for other applications and build tools on top: Abstract Syntax Tree (AST), module lfortran.ast : Represents any Fortran source code, strictly based on syntax, no semantic is included. The AST module can convert itself to Fortran source code. Abstract Semantic Representation (ASR), module lfortran.asr : Represents a valid Fortran source code, all semantic is included. Invalid Fortran code is not allowed (an error will be given). The ASR module can convert itself to an AST. Abstract Syntax Tree (AST) Fortran source code can be parsed into an AST using the src_to_ast() function: from lfortran.ast import src_to_ast, print_tree from lfortran.ast.ast_to_src import ast_to_src src = \"\"\"\\ integer function f(a, b) result(r) integer, intent(in) :: a, b r = a + b end function \"\"\" ast = src_to_ast(src, translation_unit=False) We can pretty print it using print_tree() ( #59 ): print_tree(ast) This will print (in color): Legend: Node, Field, Token program_unit.Function \u251c\u2500name='f' \u251c\u2500args=\u2193 \u2502 \u251c\u2500AST.arg \u2502 \u2502 \u2570\u2500arg='a' \u2502 \u2570\u2500AST.arg \u2502 \u2570\u2500arg='b' \u251c\u2500return_type=None \u251c\u2500return_var=expr.Name \u2502 \u2570\u2500id='r' \u251c\u2500bind=None \u251c\u2500use=[] \u251c\u2500decl=\u2193 \u2502 \u2570\u2500unit_decl2.Declaration \u2502 \u2570\u2500vars=\u2193 \u2502 \u251c\u2500AST.decl \u2502 \u2502 \u251c\u2500sym='a' \u2502 \u2502 \u251c\u2500sym_type='integer' \u2502 \u2502 \u251c\u2500dims=[] \u2502 \u2502 \u2570\u2500attrs=\u2193 \u2502 \u2502 \u2570\u2500attribute.Attribute \u2502 \u2502 \u251c\u2500name='intent' \u2502 \u2502 \u2570\u2500args=\u2193 \u2502 \u2502 \u2570\u2500AST.attribute_arg \u2502 \u2502 \u2570\u2500arg='in' \u2502 \u2570\u2500AST.decl \u2502 \u251c\u2500sym='b' \u2502 \u251c\u2500sym_type='integer' \u2502 \u251c\u2500dims=[] \u2502 \u2570\u2500attrs=\u2193 \u2502 \u2570\u2500attribute.Attribute \u2502 \u251c\u2500name='intent' \u2502 \u2570\u2500args=\u2193 \u2502 \u2570\u2500AST.attribute_arg \u2502 \u2570\u2500arg='in' \u251c\u2500body=\u2193 \u2502 \u2570\u2500stmt.Assignment \u2502 \u251c\u2500target=expr.Name \u2502 \u2502 \u2570\u2500id='r' \u2502 \u2570\u2500value=expr.BinOp \u2502 \u251c\u2500left=expr.Name \u2502 \u2502 \u2570\u2500id='a' \u2502 \u251c\u2500op=operator.Add \u2502 \u2570\u2500right=expr.Name \u2502 \u2570\u2500id='b' \u2570\u2500contains=[] We can convert AST to Fortran source code using ast_to_src() : print(ast_to_src(ast)) This will print: function f(a, b) result(r) integer, intent(in) :: a integer, intent(in) :: b r = a + b end function All AST nodes and their arguments are described in AST.asdl . Abstract Semantic Representation (ASR) We can convert AST to ASR using the ast_to_asr() function: from lfortran.semantic.ast_to_asr import ast_to_asr asr = ast_to_asr(ast) For example to print the variables defined in the function scope: print(asr.global_scope.symbols[\"f\"].symtab.symbols.keys()) it prints: dict_keys(['a', 'b', 'r']) We can convert ASR to AST and to source code: from lfortran.asr.asr_to_ast import asr_to_ast print(ast_to_src(asr_to_ast(asr))) it prints: integer function f(a, b) result(r) integer, intent(in) :: a integer, intent(in) :: b r = a + b end function All ASR nodes and their arguments are described in ASR.asdl .","title":"Developer Tutorial"},{"location":"developer_tutorial/#developer-tutorial","text":"This is a tutorial for anybody who wants to either develop LFortran or build tools on top.","title":"Developer Tutorial"},{"location":"developer_tutorial/#introduction","text":"LFortran is structured around two independent modules, AST and ASR, both of which are standalone (completely independent of the rest of LFortran) and users are encouraged to use them independently for other applications and build tools on top: Abstract Syntax Tree (AST), module lfortran.ast : Represents any Fortran source code, strictly based on syntax, no semantic is included. The AST module can convert itself to Fortran source code. Abstract Semantic Representation (ASR), module lfortran.asr : Represents a valid Fortran source code, all semantic is included. Invalid Fortran code is not allowed (an error will be given). The ASR module can convert itself to an AST.","title":"Introduction"},{"location":"developer_tutorial/#abstract-syntax-tree-ast","text":"Fortran source code can be parsed into an AST using the src_to_ast() function: from lfortran.ast import src_to_ast, print_tree from lfortran.ast.ast_to_src import ast_to_src src = \"\"\"\\ integer function f(a, b) result(r) integer, intent(in) :: a, b r = a + b end function \"\"\" ast = src_to_ast(src, translation_unit=False) We can pretty print it using print_tree() ( #59 ): print_tree(ast) This will print (in color): Legend: Node, Field, Token program_unit.Function \u251c\u2500name='f' \u251c\u2500args=\u2193 \u2502 \u251c\u2500AST.arg \u2502 \u2502 \u2570\u2500arg='a' \u2502 \u2570\u2500AST.arg \u2502 \u2570\u2500arg='b' \u251c\u2500return_type=None \u251c\u2500return_var=expr.Name \u2502 \u2570\u2500id='r' \u251c\u2500bind=None \u251c\u2500use=[] \u251c\u2500decl=\u2193 \u2502 \u2570\u2500unit_decl2.Declaration \u2502 \u2570\u2500vars=\u2193 \u2502 \u251c\u2500AST.decl \u2502 \u2502 \u251c\u2500sym='a' \u2502 \u2502 \u251c\u2500sym_type='integer' \u2502 \u2502 \u251c\u2500dims=[] \u2502 \u2502 \u2570\u2500attrs=\u2193 \u2502 \u2502 \u2570\u2500attribute.Attribute \u2502 \u2502 \u251c\u2500name='intent' \u2502 \u2502 \u2570\u2500args=\u2193 \u2502 \u2502 \u2570\u2500AST.attribute_arg \u2502 \u2502 \u2570\u2500arg='in' \u2502 \u2570\u2500AST.decl \u2502 \u251c\u2500sym='b' \u2502 \u251c\u2500sym_type='integer' \u2502 \u251c\u2500dims=[] \u2502 \u2570\u2500attrs=\u2193 \u2502 \u2570\u2500attribute.Attribute \u2502 \u251c\u2500name='intent' \u2502 \u2570\u2500args=\u2193 \u2502 \u2570\u2500AST.attribute_arg \u2502 \u2570\u2500arg='in' \u251c\u2500body=\u2193 \u2502 \u2570\u2500stmt.Assignment \u2502 \u251c\u2500target=expr.Name \u2502 \u2502 \u2570\u2500id='r' \u2502 \u2570\u2500value=expr.BinOp \u2502 \u251c\u2500left=expr.Name \u2502 \u2502 \u2570\u2500id='a' \u2502 \u251c\u2500op=operator.Add \u2502 \u2570\u2500right=expr.Name \u2502 \u2570\u2500id='b' \u2570\u2500contains=[] We can convert AST to Fortran source code using ast_to_src() : print(ast_to_src(ast)) This will print: function f(a, b) result(r) integer, intent(in) :: a integer, intent(in) :: b r = a + b end function All AST nodes and their arguments are described in AST.asdl .","title":"Abstract Syntax Tree (AST)"},{"location":"developer_tutorial/#abstract-semantic-representation-asr","text":"We can convert AST to ASR using the ast_to_asr() function: from lfortran.semantic.ast_to_asr import ast_to_asr asr = ast_to_asr(ast) For example to print the variables defined in the function scope: print(asr.global_scope.symbols[\"f\"].symtab.symbols.keys()) it prints: dict_keys(['a', 'b', 'r']) We can convert ASR to AST and to source code: from lfortran.asr.asr_to_ast import asr_to_ast print(ast_to_src(asr_to_ast(asr))) it prints: integer function f(a, b) result(r) integer, intent(in) :: a integer, intent(in) :: b r = a + b end function All ASR nodes and their arguments are described in ASR.asdl .","title":"Abstract Semantic Representation (ASR)"},{"location":"installation/","text":"Installation Dependencies End users (and distributions) are encouraged to use the tarball, which only depends on Python and a few Python packages ( llvmlite , pytest , prompt_toolkit and antlr4-python3-runtime ). The LFortran standard library needs to be compiled and it needs a C compiler. Down the road (see our roadmap ), LFortran will be gradually rewritten in C++, so it will also depend on a C++ compiler. The tarball is generated automatically by our CI (continuous integration) and contains some autogenerated files: the parser, which is generated by ANTLR4 (requires Java) and the AST and ASR nodes, which is generated by an ASDL translator (requires Python). The Java requirement is only needed when using git directly, the tarball does not depend on Java in any way. From a Tarball This is the easiest way. Install prerequisites and LFortran (works on both Linux and Mac): conda create -n lfortran python=3.7 pytest llvmlite prompt_toolkit conda activate lfortran pip install antlr4-python3-runtime tar xzf lfortran-0.1.tar.gz cd lfortran-0.1 pip install . Now the lfortran environment has the lfort compiler available. Optional: run tests: py.test --pyargs lfortran From Git This works both on Linux and a Mac: conda create -n lfortran python=3.7 pytest llvmlite prompt_toolkit conda activate lfortran pip install antlr4-python3-runtime Install Java and then ANTLR, say, into ~/ext : export CLASSPATH=\"$HOME/ext/antlr-4.7-complete.jar:$CLASSPATH\" Build: ./build.sh Run tests: py.test Run an interactive prompt: ./lfort","title":"Installation"},{"location":"installation/#installation","text":"","title":"Installation"},{"location":"installation/#dependencies","text":"End users (and distributions) are encouraged to use the tarball, which only depends on Python and a few Python packages ( llvmlite , pytest , prompt_toolkit and antlr4-python3-runtime ). The LFortran standard library needs to be compiled and it needs a C compiler. Down the road (see our roadmap ), LFortran will be gradually rewritten in C++, so it will also depend on a C++ compiler. The tarball is generated automatically by our CI (continuous integration) and contains some autogenerated files: the parser, which is generated by ANTLR4 (requires Java) and the AST and ASR nodes, which is generated by an ASDL translator (requires Python). The Java requirement is only needed when using git directly, the tarball does not depend on Java in any way.","title":"Dependencies"},{"location":"installation/#from-a-tarball","text":"This is the easiest way. Install prerequisites and LFortran (works on both Linux and Mac): conda create -n lfortran python=3.7 pytest llvmlite prompt_toolkit conda activate lfortran pip install antlr4-python3-runtime tar xzf lfortran-0.1.tar.gz cd lfortran-0.1 pip install . Now the lfortran environment has the lfort compiler available. Optional: run tests: py.test --pyargs lfortran","title":"From a Tarball"},{"location":"installation/#from-git","text":"This works both on Linux and a Mac: conda create -n lfortran python=3.7 pytest llvmlite prompt_toolkit conda activate lfortran pip install antlr4-python3-runtime Install Java and then ANTLR, say, into ~/ext : export CLASSPATH=\"$HOME/ext/antlr-4.7-complete.jar:$CLASSPATH\" Build: ./build.sh Run tests: py.test Run an interactive prompt: ./lfort","title":"From Git"},{"location":"language/","text":"Fortran Language Background and Motivation Fortran is built from the ground up to translate mathematics into simple, readable, and fast code \u2013 straightforwardly maintainable by the gamut of mathematicians, scientists, and engineers who actually produce/apply that mathematics. If that is the task at hand, it is the right tool for the job and, as right tools tend to do, can save enormous time and pain, with most excellent results. If, however, mathematics is not the main task, then almost certainly C/C++, or a host of other more general-purpose languages, will be much better. An important point is that having all the basic elements in the language itself greatly simplifies both writing and reading fast, robust code. Writing and reading is simplified because there is a single standard set of functions/constructs. No need to wonder what class the array operations are coming from, what the member functions are, how well it will be maintained in 5 years, how well optimized it is/will be, etc. All the basics are in the language itself: fast, robust, and standard for all to read and write \u2013 and for the compiler writers to optimize at the machine level. How to Learn Fortran Fortran is relatively quick to learn because it is so much simpler and smaller than C/C++ (in practice, that is, with all needed libraries included). A good online resource to learn modern Fortran is: fortran90.org The website provides the recommended practices for modern Fortran and also has side-by-side examples of using Fortran and Python for common numerical tasks, highliting the conceptual similarities between the two languages. The website also maintains a list of books and links to other online resources about Fortran.","title":"Fortran Language"},{"location":"language/#fortran-language","text":"","title":"Fortran Language"},{"location":"language/#background-and-motivation","text":"Fortran is built from the ground up to translate mathematics into simple, readable, and fast code \u2013 straightforwardly maintainable by the gamut of mathematicians, scientists, and engineers who actually produce/apply that mathematics. If that is the task at hand, it is the right tool for the job and, as right tools tend to do, can save enormous time and pain, with most excellent results. If, however, mathematics is not the main task, then almost certainly C/C++, or a host of other more general-purpose languages, will be much better. An important point is that having all the basic elements in the language itself greatly simplifies both writing and reading fast, robust code. Writing and reading is simplified because there is a single standard set of functions/constructs. No need to wonder what class the array operations are coming from, what the member functions are, how well it will be maintained in 5 years, how well optimized it is/will be, etc. All the basics are in the language itself: fast, robust, and standard for all to read and write \u2013 and for the compiler writers to optimize at the machine level.","title":"Background and Motivation"},{"location":"language/#how-to-learn-fortran","text":"Fortran is relatively quick to learn because it is so much simpler and smaller than C/C++ (in practice, that is, with all needed libraries included). A good online resource to learn modern Fortran is: fortran90.org The website provides the recommended practices for modern Fortran and also has side-by-side examples of using Fortran and Python for common numerical tasks, highliting the conceptual similarities between the two languages. The website also maintains a list of books and links to other online resources about Fortran.","title":"How to Learn Fortran"}]}