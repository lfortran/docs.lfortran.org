{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"LFortran Documentation LFortran is a modern open-source (BSD licensed) interactive Fortran compiler built on top of LLVM. It can execute user's code interactively to allow exploratory work (much like Python, MATLAB or Julia) as well as compile to binaries with the goal to run user's code on modern architectures such as multi-core CPUs and GPUs. Website: https://lfortran.org/ Main repository: https://gitlab.com/lfortran/lfortran Try online using Binder: Feature Highlights LFortran is in development, there are features that work today, and there are features that are being implemented. You can also check out the Development Status section for more information on features being supported and being worked on. Works today Interactive, Jupyter support LFortran can be used from Jupyter as a Fortran kernel, allowing a Python/Julia style rapid prototyping and exploratory workflow (see the static or interactive example notebook). Or it can be used from the command-line in an interactive prompt (REPL). Clean, modular design, usable as a library LFortran is structured around two independent modules, AST and ASR, both of which are standalone (completely independent of the rest of LFortran) and users are encouraged to use them independently for other applications and build tools on top. See the Design and Developer Tutorial documents for more details. Interoperation with GFortran LFortran can parse GFortran module files into an ASR and generate a Fortran wrapper that can be compiled with any Fortran compiler and linked with the original GFortran compiled module. Create executables It can create executables just like other Fortran compilers. Runs on Linux, Mac and Windows All three platforms are regularly tested by our CI. Planned These features are under development, there is a link to the corresponding issue so that you can track the progress by following it. Native interoperation with other languages (and other Fortran compilers) It can automatically call code written in other languages (such as C or Python) just by using the use statement, see #44 . It understands other Fortran compilers module files (one can just \"use\" them) and their ABI to link correctly (GFortran is supported, other compilers are planned, see #56 ), which allows to use LFortran with production codes today. Modern hardware support Thanks to LLVM, the goal of LFortran is to run on modern hardware and take advantage of native Fortran language constructs (such as do concurrent ) to run on multi-core CPUs and GPUs, see #57 . Full Fortran 2018 support Currently only a subset of Fortran is implemented, but the goal is to have a full implementation of the latest Fortran 2018 standard, see #58 . Please vote on issues in our issue tracker that you want us to prioritize (feel free to create new ones if we are missing anything). Roadmap Here is our roadmap how to get all the planned features above implemented: Port code generation to use ASR and pass all the current tests ( #74 ). Remove the old code generation and old semantics, that used to annotate the AST tree, which was messy. Get GFortran module files working with use module, both assumed-size and assumed-shape arrays ( #52 ). This will allow right away to use production codes with LFortran. Do these at the same time: a) Implement more Fortran features, until eventually full Fortran 2018 is supported ( #58 ). b) Gradually move to C++ for robustness and speed ( #70 ). The Python API will not change (or only minimally), so the user experience from Python will not change. c) Implement all the other cool features: use module for C and Python and automatic wrappers ( #44 ), modern hardware support ( #57 ), generating an older standard of Fortran ( #72 ), Fortran doctest feature ( #73 ), SymPy integration ( #71 ), language service for IDEs ( #12 ), and other ideas ( #29 ). The step 1. is an internal refactoring that will not take long. The step 2. will allow LFortran to be used interactively with production codes right away (the production code will get compiled with GFortran, then one \"uses\" any module in LFortran and functions/subroutines can be interactively called, the module itself can use any GFortran supported feature, but the API must fit into the subset that LFortran understands --- for large number of applications simple functions/subroutines with array arguments are enough). This will make LFortran usable for first users and one can always use GFortran temporarily until LFortran supports the given feature. We expect to be finished with the step 2. by the end of summer 2019, hopefully sooner. Finally the step 3. will improve LFortran overall, allowing the first users to contribute back, growing the community and making LFortran gradually useful for more and more people.","title":"Home"},{"location":"#lfortran-documentation","text":"LFortran is a modern open-source (BSD licensed) interactive Fortran compiler built on top of LLVM. It can execute user's code interactively to allow exploratory work (much like Python, MATLAB or Julia) as well as compile to binaries with the goal to run user's code on modern architectures such as multi-core CPUs and GPUs. Website: https://lfortran.org/ Main repository: https://gitlab.com/lfortran/lfortran Try online using Binder:","title":"LFortran Documentation"},{"location":"#feature-highlights","text":"LFortran is in development, there are features that work today, and there are features that are being implemented. You can also check out the Development Status section for more information on features being supported and being worked on.","title":"Feature Highlights"},{"location":"#works-today","text":"Interactive, Jupyter support LFortran can be used from Jupyter as a Fortran kernel, allowing a Python/Julia style rapid prototyping and exploratory workflow (see the static or interactive example notebook). Or it can be used from the command-line in an interactive prompt (REPL). Clean, modular design, usable as a library LFortran is structured around two independent modules, AST and ASR, both of which are standalone (completely independent of the rest of LFortran) and users are encouraged to use them independently for other applications and build tools on top. See the Design and Developer Tutorial documents for more details. Interoperation with GFortran LFortran can parse GFortran module files into an ASR and generate a Fortran wrapper that can be compiled with any Fortran compiler and linked with the original GFortran compiled module. Create executables It can create executables just like other Fortran compilers. Runs on Linux, Mac and Windows All three platforms are regularly tested by our CI.","title":"Works today"},{"location":"#planned","text":"These features are under development, there is a link to the corresponding issue so that you can track the progress by following it. Native interoperation with other languages (and other Fortran compilers) It can automatically call code written in other languages (such as C or Python) just by using the use statement, see #44 . It understands other Fortran compilers module files (one can just \"use\" them) and their ABI to link correctly (GFortran is supported, other compilers are planned, see #56 ), which allows to use LFortran with production codes today. Modern hardware support Thanks to LLVM, the goal of LFortran is to run on modern hardware and take advantage of native Fortran language constructs (such as do concurrent ) to run on multi-core CPUs and GPUs, see #57 . Full Fortran 2018 support Currently only a subset of Fortran is implemented, but the goal is to have a full implementation of the latest Fortran 2018 standard, see #58 . Please vote on issues in our issue tracker that you want us to prioritize (feel free to create new ones if we are missing anything).","title":"Planned"},{"location":"#roadmap","text":"Here is our roadmap how to get all the planned features above implemented: Port code generation to use ASR and pass all the current tests ( #74 ). Remove the old code generation and old semantics, that used to annotate the AST tree, which was messy. Get GFortran module files working with use module, both assumed-size and assumed-shape arrays ( #52 ). This will allow right away to use production codes with LFortran. Do these at the same time: a) Implement more Fortran features, until eventually full Fortran 2018 is supported ( #58 ). b) Gradually move to C++ for robustness and speed ( #70 ). The Python API will not change (or only minimally), so the user experience from Python will not change. c) Implement all the other cool features: use module for C and Python and automatic wrappers ( #44 ), modern hardware support ( #57 ), generating an older standard of Fortran ( #72 ), Fortran doctest feature ( #73 ), SymPy integration ( #71 ), language service for IDEs ( #12 ), and other ideas ( #29 ). The step 1. is an internal refactoring that will not take long. The step 2. will allow LFortran to be used interactively with production codes right away (the production code will get compiled with GFortran, then one \"uses\" any module in LFortran and functions/subroutines can be interactively called, the module itself can use any GFortran supported feature, but the API must fit into the subset that LFortran understands --- for large number of applications simple functions/subroutines with array arguments are enough). This will make LFortran usable for first users and one can always use GFortran temporarily until LFortran supports the given feature. We expect to be finished with the step 2. by the end of summer 2019, hopefully sooner. Finally the step 3. will improve LFortran overall, allowing the first users to contribute back, growing the community and making LFortran gradually useful for more and more people.","title":"Roadmap"},{"location":"AST%20and%20ASR/","text":"Difference between an AST and ASR Let us take a simple Fortran code: integer function f(a, b) result(r) integer, intent(in) :: a, b integer :: c, d c = a + b - d r = c * a end function and look at how the AST and ASR looks like. AST %%showast integer function f(a, b) result(r) integer, intent(in) :: a, b integer :: c, d c = a + b - d r = c * a end function ( TranslationUnit [( Function f [(a) (b)] [( AttrType TypeInteger [] () None )] r () () [] [] [] [( Declaration ( AttrType TypeInteger [] () None ) [( AttrIntent In )] [(a [] [] () None ()) (b [] [] () None ())] ()) ( Declaration ( AttrType TypeInteger [] () None ) [] [(c [] [] () None ()) (d [] [] () None ())] ())] [( = 0 c (- (+ a b ) d ) ()) ( = 0 r (* c a ) ())] [])]) The AST does not have any semantic information, but has nodes to represent declarations such as integer, intent(in) :: a . Variables such as a are represented by a Name node, and are not connected to their declarations yet. ASR %%showasr integer function f(a, b) result(r) integer, intent(in) :: a, b integer :: c, d c = a + b - d r = c * a end function ( TranslationUnit ( SymbolTable 1 {f: ( Function ( SymbolTable 2 {a: ( Variable 2 a In () () Default ( Integer 4 []) Source Public Required .false.), b: ( Variable 2 b In () () Default ( Integer 4 []) Source Public Required .false.), c: ( Variable 2 c Local () () Default ( Integer 4 []) Source Public Required .false.), d: ( Variable 2 d Local () () Default ( Integer 4 []) Source Public Required .false.), r: ( Variable 2 r ReturnVar () () Default ( Integer 4 []) Source Public Required .false.)}) f [( Var 2 a ) ( Var 2 b )] [( = ( Var 2 c ) ( BinOp ( BinOp ( Var 2 a ) Add ( Var 2 b ) ( Integer 4 []) ()) Sub ( Var 2 d ) ( Integer 4 []) ())) ( = ( Var 2 r ) ( BinOp ( Var 2 c ) Mul ( Var 2 a ) ( Integer 4 []) ()))] ( Var 2 r ) Source Public Implementation )}) []) The ASR has all the semantic information (types, etc.), nodes like Function have a symbol table and do not have any declaration nodes. Variables are simply pointers to the symbol table. Discussion The above was a simple example. Things get more apparent for more complicated examples, such as: integer function f2b(a) result(r) use gfort_interop, only: c_desc1_int32 integer, intent(in) :: a(:) interface integer function f2b_c_wrapper(a) bind(c, name=\"__mod1_MOD_f2b\") use gfort_interop, only: c_desc1_t type(c_desc1_t), intent(in) :: a end function end interface r = f2b_c_wrapper(c_desc1_int32(a)) end function AST must represent all the use statements and the interface block, and keep things semantically consistent. ASR, on the other hand, keeps track of the c_desc1_int32 , c_desc1_t and f2b_c_wrapper in the symbol table and it knows they are defined in the gfort_interop module, and so ASR does not have any of these declaration nodes. When converting from ASR to AST, LFortran will create all the appropriate AST declaration nodes automatically and correctly.","title":"Difference between an AST and ASR"},{"location":"AST%20and%20ASR/#difference-between-an-ast-and-asr","text":"Let us take a simple Fortran code: integer function f(a, b) result(r) integer, intent(in) :: a, b integer :: c, d c = a + b - d r = c * a end function and look at how the AST and ASR looks like.","title":"Difference between an AST and ASR"},{"location":"AST%20and%20ASR/#ast","text":"%%showast integer function f(a, b) result(r) integer, intent(in) :: a, b integer :: c, d c = a + b - d r = c * a end function ( TranslationUnit [( Function f [(a) (b)] [( AttrType TypeInteger [] () None )] r () () [] [] [] [( Declaration ( AttrType TypeInteger [] () None ) [( AttrIntent In )] [(a [] [] () None ()) (b [] [] () None ())] ()) ( Declaration ( AttrType TypeInteger [] () None ) [] [(c [] [] () None ()) (d [] [] () None ())] ())] [( = 0 c (- (+ a b ) d ) ()) ( = 0 r (* c a ) ())] [])]) The AST does not have any semantic information, but has nodes to represent declarations such as integer, intent(in) :: a . Variables such as a are represented by a Name node, and are not connected to their declarations yet.","title":"AST"},{"location":"AST%20and%20ASR/#asr","text":"%%showasr integer function f(a, b) result(r) integer, intent(in) :: a, b integer :: c, d c = a + b - d r = c * a end function ( TranslationUnit ( SymbolTable 1 {f: ( Function ( SymbolTable 2 {a: ( Variable 2 a In () () Default ( Integer 4 []) Source Public Required .false.), b: ( Variable 2 b In () () Default ( Integer 4 []) Source Public Required .false.), c: ( Variable 2 c Local () () Default ( Integer 4 []) Source Public Required .false.), d: ( Variable 2 d Local () () Default ( Integer 4 []) Source Public Required .false.), r: ( Variable 2 r ReturnVar () () Default ( Integer 4 []) Source Public Required .false.)}) f [( Var 2 a ) ( Var 2 b )] [( = ( Var 2 c ) ( BinOp ( BinOp ( Var 2 a ) Add ( Var 2 b ) ( Integer 4 []) ()) Sub ( Var 2 d ) ( Integer 4 []) ())) ( = ( Var 2 r ) ( BinOp ( Var 2 c ) Mul ( Var 2 a ) ( Integer 4 []) ()))] ( Var 2 r ) Source Public Implementation )}) []) The ASR has all the semantic information (types, etc.), nodes like Function have a symbol table and do not have any declaration nodes. Variables are simply pointers to the symbol table.","title":"ASR"},{"location":"AST%20and%20ASR/#discussion","text":"The above was a simple example. Things get more apparent for more complicated examples, such as: integer function f2b(a) result(r) use gfort_interop, only: c_desc1_int32 integer, intent(in) :: a(:) interface integer function f2b_c_wrapper(a) bind(c, name=\"__mod1_MOD_f2b\") use gfort_interop, only: c_desc1_t type(c_desc1_t), intent(in) :: a end function end interface r = f2b_c_wrapper(c_desc1_int32(a)) end function AST must represent all the use statements and the interface block, and keep things semantically consistent. ASR, on the other hand, keeps track of the c_desc1_int32 , c_desc1_t and f2b_c_wrapper in the symbol table and it knows they are defined in the gfort_interop module, and so ASR does not have any of these declaration nodes. When converting from ASR to AST, LFortran will create all the appropriate AST declaration nodes automatically and correctly.","title":"Discussion"},{"location":"design/","text":"LFortran Design High Level Overview LFortran is structured around two independent modules, AST and ASR, both of which are standalone (completely independent of the rest of LFortran) and users are encouraged to use them independently for other applications and build tools on top: Abstract Syntax Tree (AST), module lfortran.ast : Represents any Fortran source code, strictly based on syntax, no semantic is included. The AST module can convert itself to Fortran source code. Abstract Semantic Representation (ASR), module lfortran.asr : Represents a valid Fortran source code, all semantic is included. Invalid Fortran code is not allowed (an error will be given). The ASR module can convert itself to an AST. The LFortran compiler is then composed of the following independent stages: Parsing: converts Fortran source code to an AST Semantic: converts an AST to an ASR High level optimizations: optimize ASR to a possibly faster/simpler ASR (things like inlining functions, eliminating redundant expressions or statements, etc.) LLVM IR code generation and lower level optimizations: converts an ASR to an LLVM IR. This stage also does all other optimizations that do not produce an ASR, but still make sense to do before passing to LLVM IR. Machine code generation: LLVM then does all its optimizations and generates machine code (such as a binary executable, a library, an object file, or it is loaded and executed using JIT as part of the interactive LFortran session or in a Jupyter kernel). LFortran is structured as a library, and so one can for example use the parser to obtain an AST and do something with it, or one can then use the semantic analyzer to obtain ASR and do something with it. One can generate the ASR directly (e.g., from SymPy) and then either convert to AST and to a Fortran source code, or use LFortran to compile it to machine code directly. In other words, one can use LFortran to easily convert between the three equivalent representations: Fortran source code Abstract Syntax Tree (AST) Abstract Semantic Representation (ASR) They are all equivalent in the following sense: Any ASR can always be converted to an equivalent AST Any AST can always be converted to an equivalent Fortran source code Any Fortran source code can always be either converted to an equivalent AST or one gets a syntax error Any AST can always be either converted to an equivalent ASR or one gets a semantic error So when a conversion can be done, they are equivalent, and the conversion can always be done unless the code is invalid. ASR Design Details The ASR is designed to have the following features: ASR is still semantically equivalent to the original Fortran code (it did not lose any semantic information). ASR can be converted to AST, and AST to Fortran source code which is functionally equivalent to the original. ASR is as simple as possible: it does not contain any information that could not be inferred from ASR. The ASR C++ classes (down the road) are designed similarly to SymEngine: they are constructed once and after that they are immutable. The constructor checks in Debug more that all the requirements are met (e.g., that all Variables in a Function have a dummy argument set, that explicit-shape arrays are not allocatable and all other Fortran requirements to make it a valid code), but in Release mode it quickly constructs the class without checks. Then there are builder classes that construct the ASR C++ classes to meet requirements (checked in Debug mode) and the builder gives an error message if a code is not a valid Fortran code, and if it doesn't give an error message, then the ASR C++ classes are constructed correctly. Thus by construction, the ASR classes always contain valid Fortran code and the rest of LFortran can depend on it. Notes: Information that is lost when parsing source to AST: whitespace, multiline/single line if statement distinction, case sensitivity of keywords. Information that is lost when going from AST to ASR: detailed syntax how variables were defined and the order of type attributes (whether array dimension is using the dimension attribute, or parentheses at the variable; or how many variables there are per declaration line or their order), as ASR only represents the aggregated type information in the symbol table. ASR is the simplest way to generate Fortran code, as one does not have to worry about the detailed syntax (as in AST) about how and where things are declared. One specifies the symbol table for a module, then for each symbol (functions, global variables, types, ...) one specifies the local variables and if this is an interface then one needs to specify where one can find an implementation, otherwise a body is supplied with statements, those nodes are almost the same as in AST, except that each variable is just a reference to a symbol in the symbol table (so by construction one cannot have undefined variables). The symbol table for each node such as Function or Module also references its parent (for example a function references a module, a module references the global scope). The ASR can be directly converted to an AST without gathering any other information. And the AST directly to Fortran source code. The ASR is always representing a semantically valid Fortran code. This is enforced by checks in the ASR C++ constructors (in Debug build). When an ASR is used, one can assume it is valid. Fortran 2008 Fortran 2008 standard chapter 2 \"Fortran concepts\" specifies that Fortran code is a collection of program units (either all in one file, or in separate files), where each program unit is one of: main program module or submodule function or subroutine Note: It can also be a block data program unit, that is used to provide initial values for data objects in named common blocks , but we do not recommend the use of common blocks (use modules instead). LFortran Extension We extend the Fortran language by introducing a global scope , which is not only the list of program units (as in F2008) but can also include statements, declarations, use statements and expressions. We define global scope as a collection of the following items: main program module or submodule function or subroutine use statement declaration statement expression In addition, if a variable is not defined in an assignment statement (such as x = 5+3 ) then the type of the variable is inferred from the right hand side (e.g., x in x = 5+3 would be of type integer , and y in y = 5._dp would be of type real(dp) ). This rule only applies at the top level of global scope . Types must be fully specified inside main programs, modules, functions and subroutines, just like in F2008. The global scope has its own symbol table. The main program and module/submodule do not see any symbols from this symbol table. But functions, subroutines, statements and expressions at the top level of global scope use and operate on this symbol table. The global scope has the following symbols predefined in the symbol table: the usual standard set of Fortran functions (such as size , sin , cos , ...) the dp double precision symbol, so that one can use 5._dp for double precision. Each item in the global scope is interpreted as follows: main program is compiled into an executable with the same name and executed; modules, functions and subroutines are compiled and loaded; use statement and declaration adds those symbols with the proper type into the global scope symbol table, but do not generate any code; statement is wrapped into an anonymous subroutine with no arguments, compiled, loaded and executed; expression is wrapped into an anonymous function with no arguments returning the expression, compiled, loaded, executed and the return value is returned to the user. The global scope is always interpreted, item by item, per the previous paragraph. It is meant to allow interactive usage, experimentations and writing simple scripts. Code in global scope must be interpreted using lfortran . For more complex (production) code it is recommended to turn it into modules and programs (by wrapping loose statements into subroutines or functions and by adding type declarations) and compile it with lfortran or any other Fortran compiler. Here are some examples of valid code in global scope : Example 1 a = 5 print *, a Example 2 a = 5 subroutine p() print *, a end subroutine call p() Example 3 module a implicit none integer :: i end module use a, only: i i = 5 Example 4 x = [1, 2, 3] y = [1, 2, 1] call plot(x, y, \"o-\") Design Considerations The LFortran extension of Fortran was chosen in a way so as to minimize the number of changes. In particular, only the top level of the global scope has relaxed some of the Fortran rules (such as making specifying types optional) so as to allow simple and quick interactive usage, but inside functions, subroutines, modules or programs this relaxation does not apply. The number of changes were kept to minimum in order to make it straightforward to turn code at global scope into standard compliant Fortran code using programs and modules, so that it can be compiled by any Fortran compiler.","title":"LFortran Design"},{"location":"design/#lfortran-design","text":"","title":"LFortran Design"},{"location":"design/#high-level-overview","text":"LFortran is structured around two independent modules, AST and ASR, both of which are standalone (completely independent of the rest of LFortran) and users are encouraged to use them independently for other applications and build tools on top: Abstract Syntax Tree (AST), module lfortran.ast : Represents any Fortran source code, strictly based on syntax, no semantic is included. The AST module can convert itself to Fortran source code. Abstract Semantic Representation (ASR), module lfortran.asr : Represents a valid Fortran source code, all semantic is included. Invalid Fortran code is not allowed (an error will be given). The ASR module can convert itself to an AST. The LFortran compiler is then composed of the following independent stages: Parsing: converts Fortran source code to an AST Semantic: converts an AST to an ASR High level optimizations: optimize ASR to a possibly faster/simpler ASR (things like inlining functions, eliminating redundant expressions or statements, etc.) LLVM IR code generation and lower level optimizations: converts an ASR to an LLVM IR. This stage also does all other optimizations that do not produce an ASR, but still make sense to do before passing to LLVM IR. Machine code generation: LLVM then does all its optimizations and generates machine code (such as a binary executable, a library, an object file, or it is loaded and executed using JIT as part of the interactive LFortran session or in a Jupyter kernel). LFortran is structured as a library, and so one can for example use the parser to obtain an AST and do something with it, or one can then use the semantic analyzer to obtain ASR and do something with it. One can generate the ASR directly (e.g., from SymPy) and then either convert to AST and to a Fortran source code, or use LFortran to compile it to machine code directly. In other words, one can use LFortran to easily convert between the three equivalent representations: Fortran source code Abstract Syntax Tree (AST) Abstract Semantic Representation (ASR) They are all equivalent in the following sense: Any ASR can always be converted to an equivalent AST Any AST can always be converted to an equivalent Fortran source code Any Fortran source code can always be either converted to an equivalent AST or one gets a syntax error Any AST can always be either converted to an equivalent ASR or one gets a semantic error So when a conversion can be done, they are equivalent, and the conversion can always be done unless the code is invalid.","title":"High Level Overview"},{"location":"design/#asr-design-details","text":"The ASR is designed to have the following features: ASR is still semantically equivalent to the original Fortran code (it did not lose any semantic information). ASR can be converted to AST, and AST to Fortran source code which is functionally equivalent to the original. ASR is as simple as possible: it does not contain any information that could not be inferred from ASR. The ASR C++ classes (down the road) are designed similarly to SymEngine: they are constructed once and after that they are immutable. The constructor checks in Debug more that all the requirements are met (e.g., that all Variables in a Function have a dummy argument set, that explicit-shape arrays are not allocatable and all other Fortran requirements to make it a valid code), but in Release mode it quickly constructs the class without checks. Then there are builder classes that construct the ASR C++ classes to meet requirements (checked in Debug mode) and the builder gives an error message if a code is not a valid Fortran code, and if it doesn't give an error message, then the ASR C++ classes are constructed correctly. Thus by construction, the ASR classes always contain valid Fortran code and the rest of LFortran can depend on it.","title":"ASR Design Details"},{"location":"design/#notes","text":"Information that is lost when parsing source to AST: whitespace, multiline/single line if statement distinction, case sensitivity of keywords. Information that is lost when going from AST to ASR: detailed syntax how variables were defined and the order of type attributes (whether array dimension is using the dimension attribute, or parentheses at the variable; or how many variables there are per declaration line or their order), as ASR only represents the aggregated type information in the symbol table. ASR is the simplest way to generate Fortran code, as one does not have to worry about the detailed syntax (as in AST) about how and where things are declared. One specifies the symbol table for a module, then for each symbol (functions, global variables, types, ...) one specifies the local variables and if this is an interface then one needs to specify where one can find an implementation, otherwise a body is supplied with statements, those nodes are almost the same as in AST, except that each variable is just a reference to a symbol in the symbol table (so by construction one cannot have undefined variables). The symbol table for each node such as Function or Module also references its parent (for example a function references a module, a module references the global scope). The ASR can be directly converted to an AST without gathering any other information. And the AST directly to Fortran source code. The ASR is always representing a semantically valid Fortran code. This is enforced by checks in the ASR C++ constructors (in Debug build). When an ASR is used, one can assume it is valid.","title":"Notes:"},{"location":"design/#fortran-2008","text":"Fortran 2008 standard chapter 2 \"Fortran concepts\" specifies that Fortran code is a collection of program units (either all in one file, or in separate files), where each program unit is one of: main program module or submodule function or subroutine Note: It can also be a block data program unit, that is used to provide initial values for data objects in named common blocks , but we do not recommend the use of common blocks (use modules instead).","title":"Fortran 2008"},{"location":"design/#lfortran-extension","text":"We extend the Fortran language by introducing a global scope , which is not only the list of program units (as in F2008) but can also include statements, declarations, use statements and expressions. We define global scope as a collection of the following items: main program module or submodule function or subroutine use statement declaration statement expression In addition, if a variable is not defined in an assignment statement (such as x = 5+3 ) then the type of the variable is inferred from the right hand side (e.g., x in x = 5+3 would be of type integer , and y in y = 5._dp would be of type real(dp) ). This rule only applies at the top level of global scope . Types must be fully specified inside main programs, modules, functions and subroutines, just like in F2008. The global scope has its own symbol table. The main program and module/submodule do not see any symbols from this symbol table. But functions, subroutines, statements and expressions at the top level of global scope use and operate on this symbol table. The global scope has the following symbols predefined in the symbol table: the usual standard set of Fortran functions (such as size , sin , cos , ...) the dp double precision symbol, so that one can use 5._dp for double precision. Each item in the global scope is interpreted as follows: main program is compiled into an executable with the same name and executed; modules, functions and subroutines are compiled and loaded; use statement and declaration adds those symbols with the proper type into the global scope symbol table, but do not generate any code; statement is wrapped into an anonymous subroutine with no arguments, compiled, loaded and executed; expression is wrapped into an anonymous function with no arguments returning the expression, compiled, loaded, executed and the return value is returned to the user. The global scope is always interpreted, item by item, per the previous paragraph. It is meant to allow interactive usage, experimentations and writing simple scripts. Code in global scope must be interpreted using lfortran . For more complex (production) code it is recommended to turn it into modules and programs (by wrapping loose statements into subroutines or functions and by adding type declarations) and compile it with lfortran or any other Fortran compiler. Here are some examples of valid code in global scope :","title":"LFortran Extension"},{"location":"design/#example-1","text":"a = 5 print *, a","title":"Example 1"},{"location":"design/#example-2","text":"a = 5 subroutine p() print *, a end subroutine call p()","title":"Example 2"},{"location":"design/#example-3","text":"module a implicit none integer :: i end module use a, only: i i = 5","title":"Example 3"},{"location":"design/#example-4","text":"x = [1, 2, 3] y = [1, 2, 1] call plot(x, y, \"o-\")","title":"Example 4"},{"location":"design/#design-considerations","text":"The LFortran extension of Fortran was chosen in a way so as to minimize the number of changes. In particular, only the top level of the global scope has relaxed some of the Fortran rules (such as making specifying types optional) so as to allow simple and quick interactive usage, but inside functions, subroutines, modules or programs this relaxation does not apply. The number of changes were kept to minimum in order to make it straightforward to turn code at global scope into standard compliant Fortran code using programs and modules, so that it can be compiled by any Fortran compiler.","title":"Design Considerations"},{"location":"developer_tutorial/","text":"Developer Tutorial This is a tutorial for anybody who wants to either develop LFortran or build tools on top. Introduction LFortran is structured around two independent modules, AST and ASR, both of which are standalone (completely independent of the rest of LFortran) and users are encouraged to use them independently for other applications and build tools on top: Abstract Syntax Tree (AST): Represents any Fortran source code, strictly based on syntax, no semantic is included. The AST module can convert itself to Fortran source code. Abstract Semantic Representation (ASR): Represents a valid Fortran source code, all semantic is included. Invalid Fortran code is not allowed (an error will be given). The ASR module can convert itself to an AST. Abstract Syntax Tree (AST) Fortran source code can be parsed into an AST using the src_to_ast() function: integer function f(a, b) result(r) integer, intent(in) :: a, b r = a + b end function We can pretty print it using the %%showast magic: %%showast integer function f(a, b) result(r) integer, intent(in) :: a, b r = a + b end function ( TranslationUnit [( Function f [(a) (b)] [( AttrType TypeInteger [] () None )] r () () [] [] [] [( Declaration ( AttrType TypeInteger [] () None ) [( AttrIntent In )] [(a [] [] () None ()) (b [] [] () None ())] ())] [( = 0 r (+ a b ) ())] [])]) We can convert AST to Fortran source code using %%showfmt : %%showfmt integer function f(a, b) result(r) integer, intent(in) :: a, b r = a + b end function integer function f(a, b) result (r) integer , intent ( in ) :: a, b r = a + b end function f All AST nodes and their arguments are described in AST.asdl . Abstract Semantic Representation (ASR) We can pretty print using the %%showasr magic: %%showasr integer function f(a, b) result(r) integer, intent(in) :: a, b r = a + b end function ( TranslationUnit ( SymbolTable 1 {f: ( Function ( SymbolTable 3 {a: ( Variable 3 a In () () Default ( Integer 4 []) Source Public Required .false.), b: ( Variable 3 b In () () Default ( Integer 4 []) Source Public Required .false.), r: ( Variable 3 r ReturnVar () () Default ( Integer 4 []) Source Public Required .false.)}) f [( Var 3 a ) ( Var 3 b )] [( = ( Var 3 r ) ( BinOp ( Var 3 a ) Add ( Var 3 b ) ( Integer 4 []) ()))] ( Var 3 r ) Source Public Implementation )}) []) All ASR nodes and their arguments are described in ASR.asdl .","title":"Developer Tutorial"},{"location":"developer_tutorial/#developer-tutorial","text":"This is a tutorial for anybody who wants to either develop LFortran or build tools on top.","title":"Developer Tutorial"},{"location":"developer_tutorial/#introduction","text":"LFortran is structured around two independent modules, AST and ASR, both of which are standalone (completely independent of the rest of LFortran) and users are encouraged to use them independently for other applications and build tools on top: Abstract Syntax Tree (AST): Represents any Fortran source code, strictly based on syntax, no semantic is included. The AST module can convert itself to Fortran source code. Abstract Semantic Representation (ASR): Represents a valid Fortran source code, all semantic is included. Invalid Fortran code is not allowed (an error will be given). The ASR module can convert itself to an AST.","title":"Introduction"},{"location":"developer_tutorial/#abstract-syntax-tree-ast","text":"Fortran source code can be parsed into an AST using the src_to_ast() function: integer function f(a, b) result(r) integer, intent(in) :: a, b r = a + b end function We can pretty print it using the %%showast magic: %%showast integer function f(a, b) result(r) integer, intent(in) :: a, b r = a + b end function ( TranslationUnit [( Function f [(a) (b)] [( AttrType TypeInteger [] () None )] r () () [] [] [] [( Declaration ( AttrType TypeInteger [] () None ) [( AttrIntent In )] [(a [] [] () None ()) (b [] [] () None ())] ())] [( = 0 r (+ a b ) ())] [])]) We can convert AST to Fortran source code using %%showfmt : %%showfmt integer function f(a, b) result(r) integer, intent(in) :: a, b r = a + b end function integer function f(a, b) result (r) integer , intent ( in ) :: a, b r = a + b end function f All AST nodes and their arguments are described in AST.asdl .","title":"Abstract Syntax Tree (AST)"},{"location":"developer_tutorial/#abstract-semantic-representation-asr","text":"We can pretty print using the %%showasr magic: %%showasr integer function f(a, b) result(r) integer, intent(in) :: a, b r = a + b end function ( TranslationUnit ( SymbolTable 1 {f: ( Function ( SymbolTable 3 {a: ( Variable 3 a In () () Default ( Integer 4 []) Source Public Required .false.), b: ( Variable 3 b In () () Default ( Integer 4 []) Source Public Required .false.), r: ( Variable 3 r ReturnVar () () Default ( Integer 4 []) Source Public Required .false.)}) f [( Var 3 a ) ( Var 3 b )] [( = ( Var 3 r ) ( BinOp ( Var 3 a ) Add ( Var 3 b ) ( Integer 4 []) ()))] ( Var 3 r ) Source Public Implementation )}) []) All ASR nodes and their arguments are described in ASR.asdl .","title":"Abstract Semantic Representation (ASR)"},{"location":"installation/","text":"Installation All the instructions below work on Linux, macOS and Windows. Binaries The recommended way to install LFortran is using Conda. Install Conda for example by installing the Miniconda installation by following instructions there for your platform. Then create a new environment (you can choose any name, here we chose lf ) and activate it: conda create -n lf conda activate lf Then install LFortran by: conda install lfortran -c conda-forge Now the lf environment has the lfortran compiler available, you can start the interactive prompt by executing lfortran , or see the command line options using lfortran -h . The Jupyter kernel is automatically installed by the above command, so after installing Jupyter itself: conda install jupyter -c conda-forge You can create a Fortran based Jupyter notebook by executing: jupyter notebook and selecting New->Fortran . Build From a Source Tarball This method is the recommended method if you just want to install LFortran, either yourself or in a package manager (Spack, Conda, Debian, etc.). The source tarball has all the generated files included and has minimal dependencies. First we have to install dependencies, for example using Conda: conda create -n lf python cmake llvmdev conda activate lf Then download a tarball from https://lfortran.org/download/ , e.g.: wget https://lfortran.github.io/tarballs/dev/lfortran-0.9.0.tar.gz tar xzf lfortran-0.9.0.tar.gz cd lfortran-0.9.0 And build: cmake -DWITH_LLVM=yes -DCMAKE_INSTALL_PREFIX=`pwd`/inst . make -j8 make install This will install the lfortran into the inst/bin . Build From Git We assume you have C++ compilers installed, as well as git and wget . In Ubuntu, you can also install binutils-dev for stacktraces. If you do not have Conda installed, you can do so on Linux (and similarly on other platforms): wget --no-check-certificate https://repo.continuum.io/miniconda/Miniconda3-latest-Linux-x86_64.sh -O miniconda.sh bash miniconda.sh -b -p $HOME/conda_root export PATH=\"$HOME/conda_root/bin:$PATH\" Then prepare the environment: conda create -n lf -c conda-forge llvmdev=11.0.1 bison=3.4 re2c python cmake make toml conda activate lf Clone the LFortran git repository: git clone https://gitlab.com/lfortran/lfortran.git cd lfortran Generate files that are needed for the build (this step depends on re2c , bison and python ): ./build0.sh Now the process is the same as installing from the source tarball. For example to build in Debug mode: cmake -DCMAKE_BUILD_TYPE=Debug -DWITH_LLVM=yes -DCMAKE_INSTALL_PREFIX=`pwd`/inst . make -j8 Run tests: ctest ./run_tests.py Run an interactive prompt: ./src/bin/lfortran Enabling the Jupyter Kernel To install the Jupyter kernel, install the following Conda packages also: conda install xeus xtl nlohmann_json cppzmq and enable the kernel by -DWITH_XEUS=yes and install into $CONDA_PREFIX . For example: cmake \\ -DCMAKE_BUILD_TYPE=Debug \\ -DWITH_LLVM=yes \\ -DWITH_XEUS=yes \\ -DCMAKE_PREFIX_PATH=\"$CONDA_PREFIX\" \\ -DCMAKE_INSTALL_PREFIX=\"$CONDA_PREFIX\" \\ . cmake --build . -j4 --target install To use it, install Jupyter ( conda install jupyter ) and test that the LFortran kernel was found: jupyter kernelspec list --json Then launch a Jupyter notebook as follows: jupyter notebook Click New->Fortran . To launch a terminal jupyter LFortran console: jupyter console --kernel=fortran Build From Git with Nix One of the ways to ensure exact environment and dependencies is with nix . This will ensure that system dependencies do not interfere with the development environment. If you want, you can report bugs in a nix-shell environment to make it easier for others to reproduce. With Root We start by getting nix . The following multi-user installation will work on any machine with a Linux distribution, MacOS or Windows (via WSL): sh <(curl -L https://nixos.org/nix/install) --daemon Without Root If you would like to not provide nix with root access to your machine, on Linux distributions we can use nix-portable . wget https://github.com/DavHau/nix-portable/releases/download/v003/nix-portable Now just prepend all nix-shell commands with NP_RUNTIME=bwrap ./nix-portable . So: # Do not nix-shell --run \"bash\" # Do NP_RUNTIME=bwrap ./nix-portable nix-shell --run \"bash\" Development Now we can enter the development environment: nix-shell --run \"bash\" --cores 4 -j4 --pure ci/shell.nix The --pure flag ensures no system dependencies are used in the environment. The build steps are the same as with the ci : ./build0.sh ./build1.sh To change the compilation environment from gcc (default) to clang we can use --argstr : nix-shell --run \"bash\" --cores 4 -j4 --pure ci/shell.nix --argstr clangOnly \"yes\" Note About Dependencies End users (and distributions) are encouraged to use the tarball from https://lfortran.org/download/ , which only depends on LLVM, CMake and a C++ compiler. The tarball is generated automatically by our CI (continuous integration) and contains some autogenerated files: the parser, the AST and ASR nodes, which is generated by an ASDL translator (requires Python). The instructions from git are to be used when developing LFortran itself. Note for users who do not use Conda Following are the dependencies necessary for installing this repository in development mode, Bison - 3.5.1 LLVM - 11.0.1 re2c - 2.0.3 binutils - 2.31.90 - Make sure that you should enable the required options related to this dependency to build the dynamic libraries (the ones ending with .so ). Stacktraces LFortran can print stacktraces when there is an unhandled exception, as well as on any compiler error with the --show-stacktrace option. This is very helpful for developing the compiler itself to see where in LFortran the problem is. The stacktrace support is turned off by default, to enable it, compile LFortran with the -DWITH_STACKTRACE=yes cmake option after installing the prerequisites on each platform per the instructions below. Ubuntu In Ubuntu, apt install binutils-dev . macOS If you use the default Clang compiler on macOS, then the stacktraces should just work on both Intel and M1 based macOS (the CMake build system automatically invokes the dsymtuil tool and our Python scripts to store the debug information, see src/bin/CMakeLists.txt for more details). If it does not work, please report a bug. If you do not like the default way, an alternative is to use bintutils. For that, first install Spack , then: spack install binutils spack find -p binutils The last command will show a full path to the installed binutils package. Add this path to your shell config file, e.g.: export CMAKE_PREFIX_PATH_LFORTRAN=/Users/ondrej/repos/spack/opt/spack/darwin-catalina-broadwell/apple-clang-11.0.0/binutils-2.36.1-wy6osfm6bp2323g3jpv2sjuttthwx3gd and compile LFortran with the -DCMAKE_PREFIX_PATH=\"$CMAKE_PREFIX_PATH_LFORTRAN;$CONDA_PREFIX\" cmake option. The $CONDA_PREFIX is there if you install some other dependencies (such as llvm ) using Conda, otherwise you can remove it.","title":"Installation"},{"location":"installation/#installation","text":"All the instructions below work on Linux, macOS and Windows.","title":"Installation"},{"location":"installation/#binaries","text":"The recommended way to install LFortran is using Conda. Install Conda for example by installing the Miniconda installation by following instructions there for your platform. Then create a new environment (you can choose any name, here we chose lf ) and activate it: conda create -n lf conda activate lf Then install LFortran by: conda install lfortran -c conda-forge Now the lf environment has the lfortran compiler available, you can start the interactive prompt by executing lfortran , or see the command line options using lfortran -h . The Jupyter kernel is automatically installed by the above command, so after installing Jupyter itself: conda install jupyter -c conda-forge You can create a Fortran based Jupyter notebook by executing: jupyter notebook and selecting New->Fortran .","title":"Binaries"},{"location":"installation/#build-from-a-source-tarball","text":"This method is the recommended method if you just want to install LFortran, either yourself or in a package manager (Spack, Conda, Debian, etc.). The source tarball has all the generated files included and has minimal dependencies. First we have to install dependencies, for example using Conda: conda create -n lf python cmake llvmdev conda activate lf Then download a tarball from https://lfortran.org/download/ , e.g.: wget https://lfortran.github.io/tarballs/dev/lfortran-0.9.0.tar.gz tar xzf lfortran-0.9.0.tar.gz cd lfortran-0.9.0 And build: cmake -DWITH_LLVM=yes -DCMAKE_INSTALL_PREFIX=`pwd`/inst . make -j8 make install This will install the lfortran into the inst/bin .","title":"Build From a Source Tarball"},{"location":"installation/#build-from-git","text":"We assume you have C++ compilers installed, as well as git and wget . In Ubuntu, you can also install binutils-dev for stacktraces. If you do not have Conda installed, you can do so on Linux (and similarly on other platforms): wget --no-check-certificate https://repo.continuum.io/miniconda/Miniconda3-latest-Linux-x86_64.sh -O miniconda.sh bash miniconda.sh -b -p $HOME/conda_root export PATH=\"$HOME/conda_root/bin:$PATH\" Then prepare the environment: conda create -n lf -c conda-forge llvmdev=11.0.1 bison=3.4 re2c python cmake make toml conda activate lf Clone the LFortran git repository: git clone https://gitlab.com/lfortran/lfortran.git cd lfortran Generate files that are needed for the build (this step depends on re2c , bison and python ): ./build0.sh Now the process is the same as installing from the source tarball. For example to build in Debug mode: cmake -DCMAKE_BUILD_TYPE=Debug -DWITH_LLVM=yes -DCMAKE_INSTALL_PREFIX=`pwd`/inst . make -j8 Run tests: ctest ./run_tests.py Run an interactive prompt: ./src/bin/lfortran","title":"Build From Git"},{"location":"installation/#enabling-the-jupyter-kernel","text":"To install the Jupyter kernel, install the following Conda packages also: conda install xeus xtl nlohmann_json cppzmq and enable the kernel by -DWITH_XEUS=yes and install into $CONDA_PREFIX . For example: cmake \\ -DCMAKE_BUILD_TYPE=Debug \\ -DWITH_LLVM=yes \\ -DWITH_XEUS=yes \\ -DCMAKE_PREFIX_PATH=\"$CONDA_PREFIX\" \\ -DCMAKE_INSTALL_PREFIX=\"$CONDA_PREFIX\" \\ . cmake --build . -j4 --target install To use it, install Jupyter ( conda install jupyter ) and test that the LFortran kernel was found: jupyter kernelspec list --json Then launch a Jupyter notebook as follows: jupyter notebook Click New->Fortran . To launch a terminal jupyter LFortran console: jupyter console --kernel=fortran","title":"Enabling the Jupyter Kernel"},{"location":"installation/#build-from-git-with-nix","text":"One of the ways to ensure exact environment and dependencies is with nix . This will ensure that system dependencies do not interfere with the development environment. If you want, you can report bugs in a nix-shell environment to make it easier for others to reproduce.","title":"Build From Git with Nix"},{"location":"installation/#with-root","text":"We start by getting nix . The following multi-user installation will work on any machine with a Linux distribution, MacOS or Windows (via WSL): sh <(curl -L https://nixos.org/nix/install) --daemon","title":"With Root"},{"location":"installation/#without-root","text":"If you would like to not provide nix with root access to your machine, on Linux distributions we can use nix-portable . wget https://github.com/DavHau/nix-portable/releases/download/v003/nix-portable Now just prepend all nix-shell commands with NP_RUNTIME=bwrap ./nix-portable . So: # Do not nix-shell --run \"bash\" # Do NP_RUNTIME=bwrap ./nix-portable nix-shell --run \"bash\"","title":"Without Root"},{"location":"installation/#development","text":"Now we can enter the development environment: nix-shell --run \"bash\" --cores 4 -j4 --pure ci/shell.nix The --pure flag ensures no system dependencies are used in the environment. The build steps are the same as with the ci : ./build0.sh ./build1.sh To change the compilation environment from gcc (default) to clang we can use --argstr : nix-shell --run \"bash\" --cores 4 -j4 --pure ci/shell.nix --argstr clangOnly \"yes\"","title":"Development"},{"location":"installation/#note-about-dependencies","text":"End users (and distributions) are encouraged to use the tarball from https://lfortran.org/download/ , which only depends on LLVM, CMake and a C++ compiler. The tarball is generated automatically by our CI (continuous integration) and contains some autogenerated files: the parser, the AST and ASR nodes, which is generated by an ASDL translator (requires Python). The instructions from git are to be used when developing LFortran itself.","title":"Note About Dependencies"},{"location":"installation/#note-for-users-who-do-not-use-conda","text":"Following are the dependencies necessary for installing this repository in development mode, Bison - 3.5.1 LLVM - 11.0.1 re2c - 2.0.3 binutils - 2.31.90 - Make sure that you should enable the required options related to this dependency to build the dynamic libraries (the ones ending with .so ).","title":"Note for users who do not use Conda"},{"location":"installation/#stacktraces","text":"LFortran can print stacktraces when there is an unhandled exception, as well as on any compiler error with the --show-stacktrace option. This is very helpful for developing the compiler itself to see where in LFortran the problem is. The stacktrace support is turned off by default, to enable it, compile LFortran with the -DWITH_STACKTRACE=yes cmake option after installing the prerequisites on each platform per the instructions below.","title":"Stacktraces"},{"location":"installation/#ubuntu","text":"In Ubuntu, apt install binutils-dev .","title":"Ubuntu"},{"location":"installation/#macos","text":"If you use the default Clang compiler on macOS, then the stacktraces should just work on both Intel and M1 based macOS (the CMake build system automatically invokes the dsymtuil tool and our Python scripts to store the debug information, see src/bin/CMakeLists.txt for more details). If it does not work, please report a bug. If you do not like the default way, an alternative is to use bintutils. For that, first install Spack , then: spack install binutils spack find -p binutils The last command will show a full path to the installed binutils package. Add this path to your shell config file, e.g.: export CMAKE_PREFIX_PATH_LFORTRAN=/Users/ondrej/repos/spack/opt/spack/darwin-catalina-broadwell/apple-clang-11.0.0/binutils-2.36.1-wy6osfm6bp2323g3jpv2sjuttthwx3gd and compile LFortran with the -DCMAKE_PREFIX_PATH=\"$CMAKE_PREFIX_PATH_LFORTRAN;$CONDA_PREFIX\" cmake option. The $CONDA_PREFIX is there if you install some other dependencies (such as llvm ) using Conda, otherwise you can remove it.","title":"macOS"},{"location":"language/","text":"Fortran Language Background and Motivation Fortran was designed from the ground up to naturally and simply translate mathematics to code that compiles and runs at maximum speed. And being specifically targeted for such fundamentally computational tasks, it contains a broad range of key functionality within the language itself, standard across all platforms, with no need for external libraries that may or may not be well optimized or maintained, at present or down the road. Some highlights: Multidimensional arrays which can be allocated and indexed as the math/science dictates (not restricted to start at 0 or 1) and can be sliced as desired (as, e.g., in MATLAB); Operators which operate naturally upon the aforementioned arrays/matrices, as they do scalars; Complex numbers; Special functions; Structures and pointers for more general data representation. Because the essentials are contained in the language itself, it is simple to read and write, without need of choosing from among or deciphering a proliferation of external classes to do the same thing. And because the essentials are self-contained, compilers can provide detailed compile-time (e.g., argument mismatch) and run-time (e.g., memory access) checks, as well as highly optimized executables, directly from natural, readable code without need of extensive optimization heroics by the developer. See our blog posts for more information: Why We Created LFortran Why to Use Fortran For New Projects How to Learn Fortran Fortran is relatively quick to learn because it is so much simpler and smaller than C/C++ (in practice, that is, with all needed libraries included). If you are interested in learning more, please see our webpage at fortran90.org with recommended practices for writing code, side by side comparison with Python/NumPy, links to other online Fortran resources and books, and an FAQ.","title":"Fortran Language"},{"location":"language/#fortran-language","text":"","title":"Fortran Language"},{"location":"language/#background-and-motivation","text":"Fortran was designed from the ground up to naturally and simply translate mathematics to code that compiles and runs at maximum speed. And being specifically targeted for such fundamentally computational tasks, it contains a broad range of key functionality within the language itself, standard across all platforms, with no need for external libraries that may or may not be well optimized or maintained, at present or down the road. Some highlights: Multidimensional arrays which can be allocated and indexed as the math/science dictates (not restricted to start at 0 or 1) and can be sliced as desired (as, e.g., in MATLAB); Operators which operate naturally upon the aforementioned arrays/matrices, as they do scalars; Complex numbers; Special functions; Structures and pointers for more general data representation. Because the essentials are contained in the language itself, it is simple to read and write, without need of choosing from among or deciphering a proliferation of external classes to do the same thing. And because the essentials are self-contained, compilers can provide detailed compile-time (e.g., argument mismatch) and run-time (e.g., memory access) checks, as well as highly optimized executables, directly from natural, readable code without need of extensive optimization heroics by the developer. See our blog posts for more information: Why We Created LFortran Why to Use Fortran For New Projects","title":"Background and Motivation"},{"location":"language/#how-to-learn-fortran","text":"Fortran is relatively quick to learn because it is so much simpler and smaller than C/C++ (in practice, that is, with all needed libraries included). If you are interested in learning more, please see our webpage at fortran90.org with recommended practices for writing code, side by side comparison with Python/NumPy, links to other online Fortran resources and books, and an FAQ.","title":"How to Learn Fortran"},{"location":"progress/","text":"LFortran Development Status Development LFortran is currently under development and some of the features of Fortran might not be supported currently. The information regarding which functions are currently supported and which one's are still being worked on will be available in this section. You can submit any new issue you find while using LFortran to our issue tracker . You can also check out any of the issues mentioned in the sections below and provide suggestions and ideas to help us get the feature implemented. Fortran Standards Supported LFortran currently supports a subset of the latest Fortran standard Fortran 2018 standard . This document describes details about which features are supported and which are not. Related Issues: #120 Features Supported LFortran is currently in development and you might find some unsupported features while using it. We are working on fixing the issues and improving and expanding LFortran. You can also help out by reporting any new bug you find or you can check out any of the issues mentioned in the section and help us implement the feature faster. Currently Supported: AST Generation ASR Generation for most nodes Fortran Modules Functions Subroutines Basic data types like int, float, character Binary Operations Conditional and iterative statements Printing Not Supported/Currently in Development Strings and Arrays Nested Function Definitions Complex Numbers Optional Arguments ASR not created for a few features supported by LFortran Conditional and iterative statements Function Calls Arithmetic assignment(like a = 10) Assignments with binary operations including any number Logical Variables Print Statements Some intrinsic Fortran Functions (see below) Related Issues #114 Strings #121 ASR #122 Nested Function Definitions #125 Complex Numbers #126 Optional Arguments Intrinsic Functions LFortran does not support some of the standard intrinsic functions for the Fortran standard. Work is being done on having support for these functions. The testing for the functions is still being done. The list will be updated with the rest of the functions soon. Currently Supported: log sin cos tan sinh cosh tanh Not Supported/Currently in Development: abs sqrt asin acos atan exp int real nint floor fraction real max min mod Implementation Details This section is still subject to change. At the moment; the intrinsic functions are dispatched to libm and glibc . However, all functions are also being implemented so as to be usable from the Fortran runtime as well.","title":"LFortran Development Status"},{"location":"progress/#lfortran-development-status","text":"","title":"LFortran Development Status"},{"location":"progress/#development","text":"LFortran is currently under development and some of the features of Fortran might not be supported currently. The information regarding which functions are currently supported and which one's are still being worked on will be available in this section. You can submit any new issue you find while using LFortran to our issue tracker . You can also check out any of the issues mentioned in the sections below and provide suggestions and ideas to help us get the feature implemented.","title":"Development"},{"location":"progress/#fortran-standards-supported","text":"LFortran currently supports a subset of the latest Fortran standard Fortran 2018 standard . This document describes details about which features are supported and which are not.","title":"Fortran Standards Supported"},{"location":"progress/#related-issues","text":"#120","title":"Related Issues:"},{"location":"progress/#features-supported","text":"LFortran is currently in development and you might find some unsupported features while using it. We are working on fixing the issues and improving and expanding LFortran. You can also help out by reporting any new bug you find or you can check out any of the issues mentioned in the section and help us implement the feature faster.","title":"Features Supported"},{"location":"progress/#currently-supported","text":"AST Generation ASR Generation for most nodes Fortran Modules Functions Subroutines Basic data types like int, float, character Binary Operations Conditional and iterative statements Printing","title":"Currently Supported:"},{"location":"progress/#not-supportedcurrently-in-development","text":"Strings and Arrays Nested Function Definitions Complex Numbers Optional Arguments ASR not created for a few features supported by LFortran Conditional and iterative statements Function Calls Arithmetic assignment(like a = 10) Assignments with binary operations including any number Logical Variables Print Statements Some intrinsic Fortran Functions (see below)","title":"Not Supported/Currently in Development"},{"location":"progress/#related-issues_1","text":"#114 Strings #121 ASR #122 Nested Function Definitions #125 Complex Numbers #126 Optional Arguments","title":"Related Issues"},{"location":"progress/#intrinsic-functions","text":"LFortran does not support some of the standard intrinsic functions for the Fortran standard. Work is being done on having support for these functions. The testing for the functions is still being done. The list will be updated with the rest of the functions soon.","title":"Intrinsic Functions"},{"location":"progress/#currently-supported_1","text":"log sin cos tan sinh cosh tanh","title":"Currently Supported:"},{"location":"progress/#not-supportedcurrently-in-development_1","text":"abs sqrt asin acos atan exp int real nint floor fraction real max min mod","title":"Not Supported/Currently in Development:"},{"location":"progress/#implementation-details","text":"This section is still subject to change. At the moment; the intrinsic functions are dispatched to libm and glibc . However, all functions are also being implemented so as to be usable from the Fortran runtime as well.","title":"Implementation Details"}]}